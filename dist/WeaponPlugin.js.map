{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f027873473f17eead247","webpack:///./consts.js","webpack:///./Bullet.js","webpack:///./main.js","webpack:///./Weapon.js"],"names":["module","exports","KILL_NEVER","KILL_LIFESPAN","KILL_DISTANCE","KILL_WEAPON_BOUNDS","KILL_CAMERA_BOUNDS","KILL_WORLD_BOUNDS","KILL_STATIC_BOUNDS","ANGLE_UP","ANGLE_DOWN","ANGLE_LEFT","ANGLE_RIGHT","ANGLE_NORTH_EAST","ANGLE_NORTH_WEST","ANGLE_SOUTH_EAST","ANGLE_SOUTH_WEST","BULLET_FRAME_STABLE","BULLET_FRAME_CYCLE","BULLET_FRAME_RANDOM","consts","require","bulletID","Bullet","scene","x","y","key","frame","physics","add","existing","data","timeEvent","bulletManager","fromX","fromY","bodyDirty","rotateToVelocity","killType","killDistance","bodyBounds","Phaser","Geom","Rectangle","setActive","setVisible","body","enable","reset","debugShowBody","debugPhysics","debugShowVelocity","console","log","stop","destroy","eventEmitter","emit","active","Math","Vector2","distance","kill","Intersects","RectangleToRectangle","bulletBounds","getBounds","rotation","velocity","atan","bulletWorldWrap","world","wrap","bulletWorldWrapPadding","GameObjects","Sprite","Weapon","WeaponPlugin","pluginManager","weapons","bulletLimit","group","weaponClass","weapon","push","on","postRender","systems","events","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","time","delta","forEach","game","Plugins","ScenePlugin","bullets","autoExpandBulletsGroup","autofire","shots","fireLimit","fireRate","fireRateVariance","fireFrom","fireAngle","bulletInheritSpriteSpeed","bulletAnimation","bulletFrameRandom","bulletFrameCycle","bulletAngleOffset","bulletAngleVariance","bulletSpeed","bulletSpeedVariance","bulletLifespan","bulletKillDistance","bulletGravity","bulletRotateToVelocity","bulletKey","bulletFrame","_bulletClass","_bulletCollideWorldBounds","_bulletKillType","_data","customBody","width","height","offsetX","offsetY","bounds","bulletFrames","bulletFrameIndex","anims","trackedSprite","trackedPointer","multiFire","_hasFired","trackRotation","trackOffset","_nextFire","_tempNextFire","_rotatedPoint","Events","EventEmitter","createBullets","quantity","bulletClass","undefined","classType","maxSize","runChildUpdate","createMultiple","repeat","visible","children","each","child","addMultiple","entries","callback","callbackContext","extraArgs","arguments","call","paused","newLimit","sprite","set","pointer","input","activePointer","positions","from","fire","offset","position","now","speed","Between","CenterOn","RotateAround","randomX","random","randomY","angle","RadToDeg","atan2","moveX","moveY","cos","DegToRad","sin","bullet","getFirstDead","prepare","bulletKillType","Error","addEvent","delay","bind","lifespan","play","length","setTexture","nextFrame","floor","setSize","setOffset","collideWorldBounds","bulletCollideWorldBounds","setVelocity","setGravity","next","rate","min","max","selectionMethod","Utils","Array","NumberArray","name","frames","frameRate","loop","sys","contains","create","debugBodies","updateTransform","centerOn","Object","defineProperty","prototype","get","type","cameras","main","_bounds","value"],"mappings":"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","file":"WeaponPlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WeaponPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WeaponPlugin\"] = factory();\n\telse\n\t\troot[\"WeaponPlugin\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f027873473f17eead247","module.exports = {\r\n  /**\r\n   * A {@link #bulletKillType} constant that stops the bullets from ever being destroyed automatically.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_NEVER: 0,\r\n\r\n  /**\r\n   * A {@link #bulletKillType} constant that automatically kills the bullets when their {@link #bulletLifespan} expires.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_LIFESPAN: 1,\r\n\r\n  /**\r\n   * A {@link #bulletKillType} constant that automatically kills the bullets after they\r\n   * exceed the {@link #bulletDistance} from their original firing position.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_DISTANCE: 2,\r\n\r\n  /**\r\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link #bounds} rectangle.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_WEAPON_BOUNDS: 3,\r\n\r\n  /**\r\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link Phaser.Camera#bounds} rectangle.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_CAMERA_BOUNDS: 4,\r\n\r\n  /**\r\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link Phaser.World#bounds} rectangle.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_WORLD_BOUNDS: 5,\r\n\r\n  /**\r\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link #bounds} rectangle.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  KILL_STATIC_BOUNDS: 6,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face up.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_UP: 270,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face down.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_DOWN: 90,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face left.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_LEFT: 180,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face right.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_RIGHT: 0,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\r\n   * @constant Phaser.ANGLE_NORTH_EAST\r\n   * @type {integer}\r\n   */\r\n  ANGLE_NORTH_EAST: 315,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_NORTH_WEST: 225,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_SOUTH_EAST: 45,\r\n\r\n  /**\r\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\r\n   * @constant\r\n   * @type {integer}\r\n   */\r\n  ANGLE_SOUTH_WEST: 135,\r\n\r\n  /**\r\n   * When selecting a bullet frame the same frame should always be used. This\r\n   * is the default value.\r\n   * @constant\r\n   * @type { integer }\r\n   */\r\n  BULLET_FRAME_STABLE: 0,\r\n\r\n  /**\r\n   * When selecting a bullet frame the next frame should be used\r\n   * @constant\r\n   * @type { integer }\r\n   */\r\n  BULLET_FRAME_CYCLE: 1,\r\n\r\n  /**\r\n   * When selecting a bullet frame a random frame should be used.\r\n   * @constant\r\n   * @type { integer }\r\n   */\r\n  BULLET_FRAME_RANDOM: 2,\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// ./consts.js","/**\r\n * @author       Patrick Sletvold\r\n * @author       jdotr <https://github.com/jdotrjs>\r\n * @author       Richard Davey\r\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n */\r\n\r\nconst consts = require('./consts');\r\n\r\nlet bulletID = 0\r\n\r\nclass Bullet extends Phaser.GameObjects.Sprite {\r\n  /**\r\n   * Create a new `Bullet` object. Bullets are used by the `Weapon` class, and are normal Sprites,\r\n   * with a few extra properties in the data object to handle Weapon specific features.\r\n   *\r\n   * @param {Phaser.Scene} scene - A reference to the currently running scene.\r\n   * @param {number} x - The x coordinate (in world space) to position the Particle at.\r\n   * @param {number} y - The y coordinate (in world space) to position the Particle at.\r\n   * @param {string} key - This is the image or texture used by the Particle during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\r\n   * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\r\n   */\r\n  constructor(scene, x, y, key, frame) {\r\n    super(scene, x, y, key, frame);\r\n    this.bulletID = bulletID\r\n    bulletID++\r\n    this.scene.physics.add.existing(this);\r\n\r\n    this.data = {\r\n      timeEvent: null,\r\n      bulletManager: null,\r\n      fromX: 0,\r\n      fromY: 0,\r\n      bodyDirty: true,\r\n      rotateToVelocity: false,\r\n      killType: 0,\r\n      killDistance: 0,\r\n      bodyBounds: new Phaser.Geom.Rectangle()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Prepares this bullet to be fired and interact with the rest of the scene\r\n   * again.\r\n   */\r\n  prepare(x, y) {\r\n    this.setActive(true);\r\n    this.setVisible(true);\r\n    this.body.enable = true;\r\n    this.body.reset(x, y);\r\n    this.body.debugShowBody = this.data.bulletManager.debugPhysics;\r\n    this.body.debugShowVelocity = this.data.bulletManager.debugPhysics;\r\n  }\r\n\r\n  /**\r\n   * Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.\r\n   * Also dispatches the `Weapon`s kill signal.\r\n   * @returns {Bullet} This instance of the bullet class\r\n   */\r\n  kill() {\r\n    console.log(`Killing bullet ${this.bulletID}`)\r\n\r\n    // Reproduce Phaser.Physics.Arcade.Components.Enable.disableBody because\r\n    // we can't assume that the bullet class has it built in.\r\n    this.body.stop();\r\n    this.body.enable = false;\r\n    this.setActive(false);\r\n    this.setVisible(false);\r\n    this.body.debugShowBody = false;\r\n    this.body.debugShowVelocity = false;\r\n\r\n    // TODO: potentially we don't need to destroy the time event and we can\r\n    // just pause when the bullet is killed and restart it when it's refired.\r\n    // For now though do the simple thing and discard it.\r\n    // Another option would be to use Date.now() and manually process pause\r\n    // events with a flag and some math.\r\n    // Both of those are probably premature optimizations.\r\n    if (this.data.timeEvent !== null) {\r\n      this.data.timeEvent.destroy();\r\n      this.data.timeEvent = null;\r\n    }\r\n\r\n    this.data.bulletManager.eventEmitter.emit('kill', this);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates the Bullet, killing as required.\r\n   * @returns {Bullet} This instance of the bullet class\r\n   */\r\n  update() {\r\n    if (!this.active) {\r\n      // this was previously a check to this.exists\r\n      return;\r\n    }\r\n\r\n    if (this.data.killType > consts.KILL_LIFESPAN) {\r\n      if (this.data.killType === consts.KILL_DISTANCE) {\r\n        if (\r\n          new Phaser.Math.Vector2(this.data.fromX, this.data.fromY).distance(this) >\r\n          this.data.killDistance\r\n        ) {\r\n          this.kill();\r\n        }\r\n      } else if (!Phaser.Geom.Intersects.RectangleToRectangle(\r\n          this.data.bulletManager.bulletBounds,\r\n          this.body.getBounds(this.data.bodyBounds)\r\n        )) {\r\n        this.kill();\r\n      }\r\n    }\r\n\r\n    if (this.data.rotateToVelocity) {\r\n      this.rotation = this.body.velocity.atan();\r\n    }\r\n\r\n    if (this.data.bulletManager.bulletWorldWrap) {\r\n      this.scene.physics.world.wrap(\r\n        this,\r\n        this.data.bulletManager.bulletWorldWrapPadding\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Bullet;\r\n\n\n\n// WEBPACK FOOTER //\n// ./Bullet.js","/**\r\n * @author       Patrick Sletvold\r\n * @author       jdotr <https://github.com/jdotrjs>\r\n * @author       Richard Davey\r\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n */\r\nconst Weapon = require('./Weapon');\r\nconst Bullet = require('./Bullet');\r\nconst consts = require('./consts');\r\n\r\n/**\r\n * The Weapon Plugin provides the ability to easily create a bullet pool\r\n * and manager.\r\n *\r\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\r\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\r\n * not currently work with Impact or Matter Physics.\r\n *\r\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\r\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\r\n * with a Group, such as move it around the display list, iterate it, etc can\r\n * be done to the bullets Group too.\r\n *\r\n * Bullets can have textures and even animations. You can control the speed at\r\n * which they are fired, the firing rate, the firing angle, and even set things\r\n * like gravity for them.\r\n *\r\n * A small example, using add.weapon, assumed to be running from within a\r\n * {@link Phaser.Scene#create} method:\r\n *\r\n * ```javascript\r\n * var weapon = this.add.weapon(10, 'bullet');\r\n * weapon.fireFrom.set(300, 300);\r\n * this.input.onDown.add(weapon.fire, this); // Update this\r\n * ```\r\n */\r\nclass WeaponPlugin extends Phaser.Plugins.ScenePlugin {\r\n  /**\r\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\r\n   * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the\r\n   *  Phaser.Plugins.PluginManager instance.\r\n   */\r\n  constructor(scene, pluginManager) {\r\n    super(scene, pluginManager);\r\n\r\n    this.weapons = [];\r\n\r\n    // Register our new Game Object type\r\n    // pluginManager.registerGameObject('weapon', this.add);\r\n  }\r\n\r\n  add(bulletLimit, key, frame, group, weaponClass) {\r\n    if (!weaponClass) {\r\n      weaponClass = Weapon\r\n    }\r\n    const weapon = new weaponClass(this.scene, bulletLimit, key, frame, group);\r\n\r\n    this.weapons.push(weapon);\r\n\r\n    return weapon;\r\n  }\r\n\r\n  /**\r\n   * Called by the PluginManager when this plugin is started.\r\n   * If a plugin is stopped, and then started again, this will get called again.\r\n   * Typically called immediately after `BasePlugin.init`.\r\n   *\r\n   * @returns {void}\r\n   */\r\n  start() {\r\n    eventEmitter.on('postrender', this.postRender, this);\r\n  }\r\n\r\n  /**\r\n   * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\r\n   * By this point the plugin properties `scene` and `systems` will have already been set.\r\n   * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\r\n   * @returns {void}\r\n   */\r\n  boot() {\r\n    const eventEmitter = this.systems.events;\r\n\r\n    //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\r\n    //  If you don't need any of these events then remove the listeners and the relevant methods too.\r\n\r\n    eventEmitter.on('preupdate', this.preUpdate, this);\r\n    eventEmitter.on('update', this.update, this);\r\n    eventEmitter.on('postupdate', this.postUpdate, this);\r\n\r\n    eventEmitter.on('pause', this.pause, this);\r\n    eventEmitter.on('resume', this.resume, this);\r\n\r\n    eventEmitter.on('sleep', this.sleep, this);\r\n    eventEmitter.on('wake', this.wake, this);\r\n\r\n    eventEmitter.on('shutdown', this.shutdown, this);\r\n    eventEmitter.on('destroy', this.destroy, this);\r\n  }\r\n\r\n  //  Called every Scene step - phase 1\r\n  preUpdate(time, delta) {\r\n    // Empty\r\n  }\r\n\r\n  /**\r\n   * Internal update method, called by the PluginManager.\r\n   *\r\n   * @protected\r\n   * @param {number} time - Current game time\r\n   * @param {number} delta - Time since last call\r\n   * @returns {void}\r\n   */\r\n  update(time, delta) {\r\n    this.weapons.forEach(weapon => {\r\n      weapon.update();\r\n    });\r\n  }\r\n\r\n  //  Called every Scene step - phase 3\r\n  postUpdate(time, delta) {\r\n    // Empty\r\n  }\r\n\r\n  /**\r\n   * Internal update method, called by the PluginManager.\r\n   *\r\n   * @protected\r\n   * @returns {void}\r\n   */\r\n  postRender() {\r\n    this.weapons.forEach(weapon => {\r\n      weapon.postRender();\r\n    });\r\n  }\r\n\r\n  //  Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\r\n  pause() {\r\n    // Empty\r\n  }\r\n\r\n  //  Called when a Scene is resumed from a paused state.\r\n  resume() {\r\n    // Empty\r\n  }\r\n\r\n  //  Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\r\n  sleep() {\r\n    // Empty\r\n  }\r\n\r\n  //  Called when a Scene is woken from a sleeping state.\r\n  wake() {\r\n    // Empty\r\n  }\r\n\r\n  //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\r\n  shutdown() {\r\n    // Empty\r\n  }\r\n\r\n  /**\r\n   * Destroys this Weapon.\r\n   * You must release everything in here, all references, all objects, free it all up.\r\n   * @returns {void}\r\n   */\r\n  destroy() {\r\n    this.pluginManager = null;\r\n    this.game = null;\r\n    this.scene = null;\r\n    this.systems = null;\r\n  }\r\n}\r\n\r\nWeaponPlugin.Weapon = Weapon;\r\nWeaponPlugin.Bullet = Bullet;\r\n\r\nWeaponPlugin.consts = consts\r\n\r\n//  Make sure you export the plugin for webpack to expose\r\n\r\nmodule.exports = WeaponPlugin;\r\n\n\n\n// WEBPACK FOOTER //\n// ./main.js","/**\r\n * @author       Patrick Sletvold\r\n * @author       jdotr <https://github.com/jdotrjs>\r\n * @author       Richard Davey\r\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\r\n */\r\nconst Bullet = require('./Bullet');\r\nconst consts = require('./consts');\r\n\r\n/**\r\n * The Weapon provides the ability to easily create a bullet pool and manager.\r\n *\r\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\r\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\r\n * not currently work with P2 Physics.\r\n *\r\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\r\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\r\n * with a Group, such as move it around the display list, iterate it, etc can\r\n * be done to the bullets Group too.\r\n *\r\n * Bullets can have textures and even animations. You can control the speed at\r\n * which they are fired, the firing rate, the firing angle, and even set things\r\n * like gravity for them.\r\n *\r\n * A small example, using add.weapon, assumed to be running from within a\r\n * {@link Phaser.Scene#create} method:\r\n *\r\n * ```javascript\r\n * var weapon = this.add.weapon(10, 'bullet');\r\n * weapon.fireFrom.set(300, 300);\r\n * this.input.onDown.add(weapon.fire, this); // Update this\r\n * ```\r\n */\r\nclass Weapon {\r\n  /**\r\n   * TODO: a builder style interface would be neat. Can be kicked way forward\r\n   * into polishing.\r\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\r\n   * @param {number} bulletLimit - The number of bullets to create.\r\n   * @param {String} key - The texture key for the bullet.\r\n   * @param {String} frame - The frame name for the bullet.\r\n   * @param {Phaser.GameObjects.Group} group - A group to add the bullets to.\r\n   */\r\n  constructor(scene, bulletLimit, key, frame, group) {\r\n    this.scene = scene;\r\n\r\n    this.debugPhysics = null;\r\n\r\n    /**\r\n     * This is the Phaser.Group that contains all of the bullets managed by this plugin.\r\n     * @type {Phaser.GameObjects.Group}\r\n     */\r\n    this.bullets = null;\r\n\r\n    /**\r\n     * Should the bullet pool run out of bullets (i.e. they are all in flight) then this\r\n     * boolean controls if the Group will create a brand new bullet object or not.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.autoExpandBulletsGroup = false;\r\n\r\n    /**\r\n     * Will this weapon auto fire? If set to true then a new bullet will be fired\r\n     * based on the {@link #fireRate} value.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.autofire = false;\r\n\r\n    /**\r\n     * The total number of bullets this Weapon has fired so far.\r\n     * You can limit the number of shots allowed (via {@link #fireLimit}), and reset\r\n     * this total via {@link #resetShots}.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.shots = 0;\r\n\r\n    /**\r\n     * The maximum number of shots that this Weapon is allowed to fire before it stops.\r\n     * When the limit is his the {@link #onFireLimit} Signal is dispatched.\r\n     * You can reset the shot counter via {@link #resetShots}.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.fireLimit = 0;\r\n\r\n    /**\r\n     * The minimum interval between shots, in milliseconds.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.fireRate = 100;\r\n\r\n    /**\r\n     * This is a modifier that is added to the {@link #fireRate} each update to add variety\r\n     * to the firing rate of the Weapon. The value is given in milliseconds.\r\n     * If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual\r\n     * firing rate of the Weapon will be between 150 and 250.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.fireRateVariance = 0;\r\n\r\n    /**\r\n     * This is a Rectangle from within which the bullets are fired. By default it's a 1x1\r\n     * rectangle, the equivalent of a Point. But you can change the width and height, and if\r\n     * larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.\r\n     * @type {Phaser.Geom.Rectangle}\r\n     */\r\n    this.fireFrom = new Phaser.Geom.Rectangle(0, 0, 1, 1);\r\n\r\n    /**\r\n     * The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP\r\n     * or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.\r\n     * @type {integer}\r\n     * @default\r\n     */\r\n    this.fireAngle = consts.ANGLE_UP;\r\n\r\n    /**\r\n     * When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.bulletInheritSpriteSpeed = false;\r\n\r\n    /**\r\n     * The string based name of the animation that the Bullet will be given on launch.\r\n     * This is set via {@link #addBulletAnimation}.\r\n     * @type {string}\r\n     * @default\r\n     */\r\n    this.bulletAnimation = '';\r\n\r\n    /**\r\n     * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\r\n     * chose for each Bullet fired to pick a random frame from the set.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.bulletFrameRandom = false;\r\n\r\n    /**\r\n     * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\r\n     * chose for each Bullet fired to use the next frame in the set. The frame index is then\r\n     * advanced one frame until it reaches the end of the set, then it starts from the start\r\n     * again. Cycling frames like this allows you to create varied bullet effects via\r\n     * sprite sheets.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.bulletFrameCycle = false;\r\n\r\n    /**\r\n     * Should the Bullets wrap around the world bounds? This automatically calls\r\n     * `World.wrap` on the Bullet each frame. See the docs for that method for details.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.bulletWorldWrap = false;\r\n\r\n    /**\r\n     * If `bulletWorldWrap` is true then you can provide an optional padding value with this\r\n     * property. It's added to the calculations determining when the Bullet should wrap around\r\n     * the world or not. The value is given in pixels.\r\n     * @type {integer}\r\n     * @default\r\n     */\r\n    this.bulletWorldWrapPadding = 0;\r\n\r\n    /**\r\n     * An optional angle offset applied to the Bullets when they are launched.\r\n     * This is useful if for example your bullet sprites have been drawn facing up, instead of\r\n     * to the right, and you want to fire them at an angle. In which case you can set the\r\n     * angle offset to be 90 and they'll be properly rotated when fired.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.bulletAngleOffset = 0;\r\n\r\n    /**\r\n     * This is a variance added to the angle of Bullets when they are fired.\r\n     * If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual\r\n     * angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a\r\n     * great 'spread' effect to a Weapon.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.bulletAngleVariance = 0;\r\n\r\n    /**\r\n     * The initial velocity of fired bullets, in pixels per second.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.bulletSpeed = 200;\r\n\r\n    /**\r\n     * This is a variance added to the speed of Bullets when they are fired.\r\n     * If bullets have a {@link #bulletSpeed} value of 200, and a `bulletSpeedVariance` of 50\r\n     * then the actual speed of the Bullets will be between 150 and 250 pixels per second.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.bulletSpeedVariance = 0;\r\n\r\n    /**\r\n     * If you've set {@link #bulletKillType} to `consts.KILL_LIFESPAN` this controls the amount\r\n     * of lifespan the Bullets have set on launch. The value is given in milliseconds.\r\n     * When a Bullet hits its lifespan limit it will be automatically killed.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.bulletLifespan = 0;\r\n\r\n    /**\r\n     * If you've set {@link #bulletKillType} to `consts.KILL_DISTANCE` this controls the distance\r\n     * the Bullet can travel before it is automatically killed. The distance is given in pixels.\r\n     * @type {number}\r\n     * @default\r\n     */\r\n    this.bulletKillDistance = 0;\r\n\r\n    /**\r\n     * This is the amount of {@link Phaser.Physics.Arcade.Body#gravity} added to the Bullets physics body when fired.\r\n     * Gravity is expressed in pixels / second / second.\r\n     * @type {Phaser.Math.Vector2}\r\n     */\r\n    this.bulletGravity = new Phaser.Math.Vector2(0, 0);\r\n\r\n    /**\r\n     * Bullets can optionally adjust their rotation in-flight to match their velocity.\r\n     * This can create the effect of a bullet 'pointing' to the path it is following, for example\r\n     * an arrow being fired from a bow, and works especially well when added to {@link #bulletGravity}.\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.bulletRotateToVelocity = false;\r\n\r\n    /**\r\n     * The Texture Key that the Bullets use when rendering.\r\n     * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\r\n     * @type {string}\r\n     * @default\r\n     */\r\n    this.bulletKey = key || '';\r\n\r\n    /**\r\n     * The Texture Frame that the Bullets use when rendering.\r\n     * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\r\n     * @type {string|integer}\r\n     * @default\r\n     */\r\n    this.bulletFrame = frame || '';\r\n\r\n    /**\r\n     * Private var that holds the public `bulletClass` property.\r\n     * @type {function}\r\n     * @private\r\n     */\r\n    this._bulletClass = Bullet;\r\n\r\n    /**\r\n     * Private var that holds the public `bulletCollideWorldBounds` property.\r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    this._bulletCollideWorldBounds = false;\r\n\r\n    /**\r\n     * Private var that holds the public `bulletKillType` property.\r\n     * @type {integer}\r\n     * @private\r\n     */\r\n    this._bulletKillType = consts.KILL_WORLD_BOUNDS;\r\n\r\n    /**\r\n     * Holds internal data about custom bullet body sizes.\r\n     *\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    this._data = {\r\n      customBody: false,\r\n      width: 0,\r\n      height: 0,\r\n      offsetX: 0,\r\n      offsetY: 0,\r\n    };\r\n\r\n    /**\r\n     * This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.\r\n     * It's used in combination with {@link #bulletKillType} when that is set to either `consts.KILL_WEAPON_BOUNDS`\r\n     * or `consts.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.\r\n     * If you are tracking a Sprite or Point then the bounds are centered on that object every frame.\r\n     *\r\n     * @type {Phaser.Geom.Rectangle}\r\n     */\r\n    this.bounds = new Phaser.Geom.Rectangle();\r\n\r\n    /**\r\n     * The Rectangle used to calculate the bullet bounds from.\r\n     *\r\n     * @type {Phaser.Geom.Rectangle}\r\n     * @private\r\n     */\r\n    this.bulletBounds = this.scene.physics.world.bounds;\r\n\r\n    /**\r\n     * This array stores the frames added via @link #setBulletFrames.\r\n     *\r\n     * @type {Array}\r\n     * @protected\r\n     */\r\n    this.bulletFrames = [];\r\n\r\n    /**\r\n     * The index of the frame within {@link #bulletFrames} that is currently being used.\r\n     * This value is only used if {@link #bulletFrameCycle} is set to `true`.\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.bulletFrameIndex = 0;\r\n\r\n    /**\r\n     * An internal object that stores the animation data added via {@link #addBulletAnimation}.\r\n     * @type {Object}\r\n     * @private\r\n     */\r\n    this.anims = {};\r\n\r\n    /**\r\n     * The Sprite currently being tracked by the Weapon, if any.\r\n     * This is set via the {@link #trackSprite} method.\r\n     *\r\n     * @type {Phaser.GameObjects.Sprite|Object}\r\n     */\r\n    this.trackedSprite = null;\r\n\r\n    /**\r\n     * The Pointer currently being tracked by the Weapon, if any.\r\n     * This is set via the {@link #trackPointer} method.\r\n     *\r\n     * @type {Phaser.Input.Pointer}\r\n     */\r\n    this.trackedPointer = null;\r\n\r\n    /**\r\n     * If you want this Weapon to be able to fire more than 1 bullet in a single\r\n     * update, then set this property to `true`. When `true` the Weapon plugin won't\r\n     * set the shot / firing timers until the `postRender` phase of the game loop.\r\n     * This means you can call `fire` (and similar methods) as often as you like in one\r\n     * single game update.\r\n     *\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.multiFire = false;\r\n\r\n    /**\r\n     * Internal multiFire test flag.\r\n     *\r\n     * @type {boolean}\r\n     */\r\n    this._hasFired = false;\r\n\r\n    /**\r\n     * If the Weapon is tracking a Sprite, should it also track the Sprites rotation?\r\n     * This is useful for a game such as Asteroids, where you want the weapon to fire based\r\n     * on the sprites rotation.\r\n     *\r\n     * @type {boolean}\r\n     * @default\r\n     */\r\n    this.trackRotation = false;\r\n\r\n    /**\r\n     * The Track Offset is a Vector2 object that allows you to specify a pixel offset that bullets use\r\n     * when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels\r\n     * in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have\r\n     * the bullet launched from the center of the Sprite.\r\n     *\r\n     * @type {Phaser.Math.Vector2}\r\n     */\r\n    this.trackOffset = new Phaser.Math.Vector2();\r\n\r\n    /**\r\n     * Internal firing rate time tracking variable.\r\n     *\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._nextFire = 0;\r\n\r\n    /**\r\n     * Internal firing rate time tracking variable used by multiFire.\r\n     *\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this._tempNextFire = 0;\r\n\r\n    /**\r\n     * Internal firing rotation tracking point.\r\n     *\r\n     * @type {Phaser.Math.Vector2}\r\n     * @private\r\n     */\r\n    this._rotatedPoint = new Phaser.Math.Vector2();\r\n\r\n    this.eventEmitter = new Phaser.Events.EventEmitter();\r\n\r\n    this.createBullets(bulletLimit, key, frame, group);\r\n  }\r\n\r\n  /**\r\n   * This method performs two actions: First it will check to see if the {@link #bullets} Group exists or not,\r\n   * and if not it creates it, adding it the `group` given as the 4th argument.\r\n   *\r\n   * Then it will seed the bullet pool with the `quantity` number of Bullets, using the texture key and frame\r\n   * provided (if any).\r\n   *\r\n   * If for example you set the quantity to be 10, then this Weapon will only ever be able to have 10 bullets\r\n   * in-flight simultaneously. If you try to fire an 11th bullet then nothing will happen until one, or more, of\r\n   * the in-flight bullets have been killed, freeing them up for use by the Weapon again.\r\n   *\r\n   * If you do not wish to have a limit set, then pass in -1 as the quantity. In this instance the Weapon will\r\n   * keep increasing the size of the bullet pool as needed. It will never reduce the size of the pool however,\r\n   * so be careful it doesn't grow too large.\r\n   *\r\n   * You can either set the texture key and frame here, or via the {@link #bulletKey} and {@link #bulletFrame}\r\n   * properties. You can also animate bullets, or set them to use random frames. All Bullets belonging to a\r\n   * single Weapon instance must share the same texture key however.\r\n   *\r\n   * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon with. If -1 it will set the pool to automatically expand.\r\n   * @param {string} [key] - The Game.cache key of the image that this Sprite will use.\r\n   * @param {integer|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.\r\n   * @param {Phaser.GameObjects.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  createBullets(quantity, key, frame, group, bulletClass) {\r\n    if (quantity === undefined) {\r\n      quantity = 1;\r\n    }\r\n    if (bulletClass) {\r\n      this._bulletClass = bulletClass\r\n    }\r\n    /*if (group === undefined) {\r\n      group = this.game.world;\r\n    }*/\r\n\r\n    if (this.bullets && !this.bullets.scene) {\r\n      this.bullets = null;\r\n    }\r\n\r\n    if (!this.bullets) {\r\n      this.bullets = this.scene.add.group({\r\n        classType: this._bulletClass,\r\n        maxSize: quantity,\r\n        runChildUpdate: true\r\n      });\r\n    }\r\n\r\n    if (quantity !== 0) {\r\n      if (quantity === -1) {\r\n        this.autoExpandBulletsGroup = true;\r\n        quantity = 1;\r\n      }\r\n\r\n      this.bullets.createMultiple({\r\n        key,\r\n        frame,\r\n        repeat: quantity,\r\n        active: false,\r\n        visible: false\r\n      });\r\n\r\n      this.bullets.children.each(function (child) {\r\n        child.data.bulletManager = this\r\n      }, this);\r\n\r\n      this.bulletKey = key;\r\n      this.bulletFrame = frame;\r\n\r\n      if (group) {\r\n        group.addMultiple(this.bullets.children.entries)\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Call a function on each in-flight bullet in this Weapon.\r\n   *\r\n   * See {@link Phaser.GameObjects.Group#forEachExists forEachExists} for more details.\r\n   *\r\n   * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\r\n   * @param {object} callbackContext - The context in which the function should be called (usually 'this').\r\n   * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  forEach(callback, callbackContext) {\r\n    const extraArgs = arguments;\r\n\r\n    this.bullets.children.each(child => {\r\n      if (child.active) {\r\n        callback.call(callbackContext, child, extraArgs);\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `false` on each bullet in this Weapon.\r\n   * This has the effect of stopping them in-flight should they be moving.\r\n   * It also stops them being able to be checked for collision.\r\n   *\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  pauseAll() {\r\n    this.bullets.children.each(child => {\r\n      child.body.enable = false;\r\n      if (child.data.timeEvent !== null) {\r\n        child.data.timeEvent.paused = true;\r\n      }\r\n    }, this);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `true` on each bullet in this Weapon.\r\n   * This has the effect of resuming their motion should they be in-flight.\r\n   * It also enables them for collision checks again.\r\n   *\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  resumeAll() {\r\n    this.bullets.children.each(child => {\r\n      child.body.enable = true;\r\n      if (child.data.timeEvent !== null) {\r\n        child.data.timeEvent.paused = false;\r\n      }\r\n    }, this);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Calls {@link Phaser.Bullet#kill} on every in-flight bullet in this Weapon.\r\n   * Also re-enables their physics bodies, should they have been disabled via {@link #pauseAll}.\r\n   *\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  killAll() {\r\n    this.bullets.children.each(child => {\r\n      if (child.active) {\r\n        child.kill();\r\n      }\r\n      child.body.enable = true;\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Resets the {@link #shots} counter back to zero. This is used when you've set\r\n   * {@link #fireLimit} and have hit (or just wish to reset) your limit.\r\n   *\r\n   * @param {integer} [newLimit] - Optionally set a new {@link #fireLimit}.\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  resetShots(newLimit) {\r\n    this.shots = 0;\r\n\r\n    if (newLimit !== undefined) {\r\n      this.fireLimit = newLimit;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets this Weapon to track the given Sprite, or any Object with a public {@link Phaser.Component.Core#world world} Point object.\r\n   * When a Weapon tracks a Sprite it will automatically update its {@link #fireFrom} value to match the Sprite's\r\n   * position within the Game World, adjusting the coordinates based on the offset arguments.\r\n   *\r\n   * This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.\r\n   *\r\n   * Calling `trackSprite` will reset {@link #trackedPointer} to null, should it have been set, as you can\r\n   * only track _either_ a Sprite, or a Pointer, at once, but not both.\r\n   *\r\n   * @param {Phaser.GameObjects.Sprite|Object} sprite - The Sprite to track the position of.\r\n   * @param {integer} [offsetX=0] - The horizontal offset from the Sprites position to be applied to the Weapon.\r\n   * @param {integer} [offsetY=0] - The vertical offset from the Sprites position to be applied to the Weapon.\r\n   * @param {boolean} [trackRotation=false] - Should the Weapon also track the Sprites rotation?\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  trackSprite(sprite, offsetX, offsetY, trackRotation) {\r\n    if (offsetX === undefined) {\r\n      offsetX = 0;\r\n    }\r\n    if (offsetY === undefined) {\r\n      offsetY = 0;\r\n    }\r\n    if (trackRotation === undefined) {\r\n      trackRotation = false;\r\n    }\r\n\r\n    this.trackedPointer = null;\r\n    this.trackedSprite = sprite;\r\n    this.trackRotation = trackRotation;\r\n\r\n    this.trackOffset.set(offsetX, offsetY);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets this Weapon to track the given Pointer.\r\n   * When a Weapon tracks a Pointer it will automatically update its {@link #fireFrom} value to match the Pointer's\r\n   * position within the Game World, adjusting the coordinates based on the offset arguments.\r\n   *\r\n   * This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.\r\n   *\r\n   * Calling `trackPointer` will reset {@link #trackedSprite} to null, should it have been set, as you can\r\n   * only track _either_ a Pointer, or a Sprite, at once, but not both.\r\n   *\r\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to track the position of. Defaults to `Input.activePointer` if not specified.\r\n   * @param {integer} [offsetX=0] - The horizontal offset from the Pointers position to be applied to the Weapon.\r\n   * @param {integer} [offsetY=0] - The vertical offset from the Pointers position to be applied to the Weapon.\r\n   * @return {Weapon} This Weapon instance.\r\n   */\r\n  trackPointer(pointer, offsetX, offsetY) {\r\n    if (pointer === undefined && this.scene.input) {\r\n      pointer = this.scene.input.activePointer;\r\n    }\r\n    if (offsetX === undefined) {\r\n      offsetX = 0;\r\n    }\r\n    if (offsetY === undefined) {\r\n      offsetY = 0;\r\n    }\r\n\r\n    this.trackedPointer = pointer;\r\n    this.trackedSprite = null;\r\n    this.trackRotation = false;\r\n\r\n    this.trackOffset.set(offsetX, offsetY);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Attempts to fire multiple bullets from the positions defined in the given array.\r\n   *\r\n   * If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then\r\n   * the positions are treated as __offsets__ from the given objects position.\r\n   *\r\n   * If `from` is undefined, and there is no tracked object, then the bullets are fired\r\n   * from the given positions, as they exist in the world.\r\n   *\r\n   * Calling this method sets {@link #multiFire} to `true`.\r\n   *\r\n   * If there are not enough bullets available in the pool, and the pool cannot be extended,\r\n   * then this method may not fire from all of the given positions.\r\n   *\r\n   * When the bullets are launched they have their texture and frame updated, as required.\r\n   * The velocity of the bullets are calculated based on Weapon properties like {@link #bulletSpeed}.\r\n   *\r\n   * @param {array} positions - An array of positions. Each position can be any Object, as long as it has public `x` and `y` properties, such as Phaser.Point, { x: 0, y: 0 }, Phaser.Sprite, etc.\r\n   * @param {Phaser.GameObject.Sprite|Phaser.Math.Vector2|Object|string} [from] - Optionally fires the bullets **from** the `x` and `y` properties of this object, _instead_ of any {@link #trackedSprite} or `trackedPointer` that is set.\r\n   * @return {array} An array containing all of the fired Phaser.Bullet objects, if a launch was successful, otherwise an empty array.\r\n   */\r\n  fireMany(positions, from) {\r\n    this.multiFire = true;\r\n\r\n    const bullets = [];\r\n\r\n    if (from || this.trackedSprite || this.trackedPointer) {\r\n      positions.forEach(offset => {\r\n        bullets.push(this.fire(from, null, null, offset.x, offset.y));\r\n      });\r\n    } else {\r\n      positions.forEach(position => {\r\n        bullets.push(this.fire(position));\r\n      });\r\n    }\r\n\r\n    return bullets;\r\n  }\r\n\r\n  /**\r\n   * Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset\r\n   * to the position first. This is the same as calling {@link #fire} and passing in the offset arguments.\r\n   *\r\n   * If there are no more bullets available in the pool, and the pool cannot be extended,\r\n   * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\r\n   * the Weapon was fired, as defined in the {@link #fireRate} property.\r\n   *\r\n   * Otherwise the first available bullet is selected, launched, and returned.\r\n   *\r\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\r\n   * calculated based on Weapon properties like {@link #bulletSpeed}.\r\n   *\r\n   * If you wish to fire multiple bullets in a single game update, then set {@link #multiFire} to `true`\r\n   * and you can call this method as many times as you like, per loop. See also {@link #fireMany}.\r\n   *\r\n   * @param {number} [offsetX=0] - The horizontal offset from the position of the tracked Sprite or Pointer, as set with {@link #trackSprite}.\r\n   * @param {number} [offsetY=0] - The vertical offset from the position of the tracked Sprite or Pointer, as set with {@link #trackSprite}.\r\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\r\n   */\r\n  fireOffset(offsetX, offsetY) {\r\n    if (offsetX === undefined) {\r\n      offsetX = 0;\r\n    }\r\n    if (offsetY === undefined) {\r\n      offsetY = 0;\r\n    }\r\n\r\n    return this.fire(null, null, null, offsetX, offsetY);\r\n  }\r\n\r\n  /**\r\n   * Fires a bullet **at** the given Pointer. The bullet will be launched from the {@link #fireFrom} position,\r\n   * or from a Tracked Sprite or Pointer, if you have one set.\r\n   *\r\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to fire the bullet towards.\r\n   * @return {Bullet} The fired bullet if successful, null otherwise.\r\n   */\r\n  fireAtPointer(pointer) {\r\n    if (pointer === undefined && this.scene.input) {\r\n      pointer = this.scene.input.activePointer;\r\n    }\r\n\r\n    return this.fire(null, pointer.x, pointer.y);\r\n  }\r\n\r\n  /**\r\n   * Fires a bullet **at** the given Sprite. The bullet will be launched from the {@link #fireFrom} position,\r\n   * or from a Tracked Sprite or Pointer, if you have one set.\r\n   *\r\n   * @param {Phaser.GameObjects.Sprite} [sprite] - The Sprite to fire the bullet towards.\r\n   * @return {Bullet} The fired bullet if successful, null otherwise.\r\n   */\r\n  fireAtSprite(sprite) {\r\n    return this.fire(null, sprite.x, sprite.y);\r\n  }\r\n\r\n  /**\r\n   * Fires a bullet **at** the given coordinates. The bullet will be launched from the {@link #fireFrom} position,\r\n   * or from a Tracked Sprite or Pointer, if you have one set.\r\n   *\r\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet towards.\r\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet towards.\r\n   * @return {Bullet} The fired bullet if successful, null otherwise.\r\n   */\r\n  fireAtXY(x, y) {\r\n    return this.fire(null, x, y);\r\n  }\r\n\r\n  /**\r\n   * Attempts to fire a single Bullet. If there are no more bullets available in the pool, and the pool cannot be extended,\r\n   * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\r\n   * the Weapon was fired, as defined in the {@link #fireRate} property.\r\n   *\r\n   * Otherwise the first available bullet is selected, launched, and returned.\r\n   *\r\n   * The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.\r\n   *\r\n   * If you don't provide any of the arguments then it uses those set via properties such as {@link #trackedSprite},\r\n   * {@link #bulletAngle} and so on.\r\n   *\r\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\r\n   * calculated based on Weapon properties like `bulletSpeed`.\r\n   *\r\n   * If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`\r\n   * and you can call `fire` as many times as you like, per loop. Multiple fires in a single update\r\n   * only counts once towards the `shots` total, but you will still receive a Signal for each bullet.\r\n   *\r\n   * @param {Phaser.GameObjects.Sprite|Phaser.Math.Vector2|Object|string} [from] - Optionally fires the bullet **from** the `x` and `y` properties of this object. If set this overrides {@link #trackedSprite} or `trackedPointer`. Pass `null` to ignore it.\r\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet **towards**. If left as `undefined`, or `null`, the bullet direction is based on its angle.\r\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet **towards**. If left as `undefined`, or `null`, the bullet direction is based on its angle.\r\n   * @param {number} [offsetX=0] - If the bullet is fired from a tracked Sprite or Pointer, or the `from` argument is set, this applies a horizontal offset from the launch position.\r\n   * @param {number} [offsetY=0] - If the bullet is fired from a tracked Sprite or Pointer, or the `from` argument is set, this applies a vertical offset from the launch position.\r\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\r\n   */\r\n  fire(from, x, y, offsetX, offsetY) {\r\n    if (x === undefined) {\r\n      x = null;\r\n    }\r\n    if (y === undefined) {\r\n      y = null;\r\n    }\r\n\r\n    if (\r\n      this.scene.time.now < this._nextFire ||\r\n      (this.fireLimit > 0 && this.shots === this.fireLimit)\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    let speed = this.bulletSpeed;\r\n\r\n    //  Apply +- speed variance\r\n    if (this.bulletSpeedVariance !== 0) {\r\n      speed += Phaser.Math.Between(-this.bulletSpeedVariance, this.bulletSpeedVariance);\r\n    }\r\n\r\n    if (from) {\r\n      if (this.fireFrom.width > 1) {\r\n        this.fireFrom.CenterOn(from.x, from.y);\r\n      } else {\r\n        this.fireFrom.x = from.x;\r\n        this.fireFrom.y = from.y;\r\n      }\r\n    } else if (this.trackedSprite) {\r\n      if (this.trackRotation) {\r\n        this._rotatedPoint.set(\r\n          this.trackedSprite.x + this.trackOffset.x,\r\n          this.trackedSprite.y + this.trackOffset.y\r\n        );\r\n        Phaser.Math.RotateAround(this._rotatedPoint,\r\n          this.trackedSprite.x,\r\n          this.trackedSprite.y,\r\n          this.trackedSprite.rotation\r\n        );\r\n\r\n        if (this.fireFrom.width > 1) {\r\n          this.fireFrom.CenterOn(this._rotatedPoint.x, this._rotatedPoint.y);\r\n        } else {\r\n          this.fireFrom.x = this._rotatedPoint.x;\r\n          this.fireFrom.y = this._rotatedPoint.y;\r\n        }\r\n      } else if (this.fireFrom.width > 1) {\r\n        this.fireFrom.CenterOn(\r\n          this.trackedSprite.x + this.trackOffset.x,\r\n          this.trackedSprite.y + this.trackOffset.y\r\n        );\r\n      } else {\r\n        this.fireFrom.x = this.trackedSprite.x + this.trackOffset.x;\r\n        this.fireFrom.y = this.trackedSprite.y + this.trackOffset.y;\r\n      }\r\n\r\n      if (this.bulletInheritSpriteSpeed) {\r\n        speed += this.trackedSprite.body.speed;\r\n      }\r\n    } else if (this.trackedPointer) {\r\n      if (this.fireFrom.width > 1) {\r\n        this.fireFrom.CenterOn(\r\n          this.trackedPointer.x + this.trackOffset.x,\r\n          this.trackedPointer.y + this.trackOffset.y\r\n        );\r\n      } else {\r\n        this.fireFrom.x = this.trackedPointer.x + this.trackOffset.x;\r\n        this.fireFrom.y = this.trackedPointer.y + this.trackOffset.y;\r\n      }\r\n    }\r\n\r\n    if (offsetX !== undefined) {\r\n      this.fireFrom.x += offsetX;\r\n    }\r\n\r\n    if (offsetY !== undefined) {\r\n      this.fireFrom.y += offsetY;\r\n    }\r\n\r\n    const randomX = this.fireFrom.x + Math.random() * this.fireFrom.width;\r\n    const randomY = this.fireFrom.y + Math.random() * this.fireFrom.height;\r\n\r\n    const fromX = this.fireFrom.width > 1 ? randomX : this.fireFrom.x;\r\n    const fromY = this.fireFrom.height > 1 ? randomY : this.fireFrom.y;\r\n\r\n    let angle = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;\r\n\r\n    //  The position (in world space) to fire the bullet towards, if set\r\n    if (x !== null && y !== null) {\r\n      angle = Phaser.Math.RadToDeg(Math.atan2(y - fromY, x - fromX));\r\n    }\r\n\r\n    //  Apply +- angle variance\r\n    if (this.bulletAngleVariance !== 0) {\r\n      angle += Phaser.Math.Between(-this.bulletAngleVariance, this.bulletAngleVariance);\r\n    }\r\n\r\n    let moveX = 0;\r\n    let moveY = 0;\r\n\r\n    //  Avoid sin/cos for right-angled shots\r\n    if (angle === 0 || angle === 180) {\r\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\r\n    } else if (angle === 90 || angle === 270) {\r\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\r\n    } else {\r\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\r\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\r\n    }\r\n\r\n    let bullet = null;\r\n\r\n    if (this.autoExpandBulletsGroup) {\r\n      bullet = this.bullets.getFirstDead(true, fromX, fromY, this.bulletKey, this.bulletFrame);\r\n\r\n      bullet.data.bulletManager = this;\r\n    } else {\r\n      bullet = this.bullets.getFirstDead(false);\r\n    }\r\n\r\n    if (bullet) {\r\n      bullet.prepare(fromX, fromY);\r\n      bullet.data.fromX = fromX;\r\n      bullet.data.fromY = fromY;\r\n      bullet.data.killType = this.bulletKillType;\r\n      bullet.data.killDistance = this.bulletKillDistance;\r\n      bullet.data.rotateToVelocity = this.bulletRotateToVelocity;\r\n\r\n      if (this.bulletKillType === consts.KILL_LIFESPAN) {\r\n        if (this.bulletLifespan <= 0) {\r\n          throw new Error('Invalid bulletLifespan; must be > 0')\r\n        }\r\n        bullet.data.timeEvent = this.scene.time.addEvent({\r\n          delay: this.bulletLifespan,\r\n          callback: bullet.kill.bind(bullet),\r\n        })\r\n        bullet.lifespan = this.bulletLifespan;\r\n      }\r\n\r\n      bullet.angle = angle + this.bulletAngleOffset;\r\n\r\n      //  Frames and Animations\r\n      if (this.bulletAnimation) {\r\n        bullet.anims.play(this.bulletAnimation);\r\n      } else if (this.bulletFrameCycle) {\r\n        if (this.bulletFrameIndex >= this.bulletFrames.length) {\r\n          this.bulletFrameIndex = 0;\r\n        }\r\n        bullet.setTexture(this.bulletKey, this.bulletFrameIndex);\r\n        this.bulletFrameIndex++;\r\n      } else if (this.bulletFrameRandom) {\r\n        const nextFrame = Math.floor(Math.random() * this.bulletFrames.length);\r\n        bullet.setTexture(this.bulletKey, nextFrame)\r\n      }\r\n\r\n      if (bullet.data.bodyDirty) {\r\n        if (this._data.customBody) {\r\n          bullet.body.setSize(this._data.width, this._data.height);\r\n          bullet.body.setOffset(this._data.offsetX, this._data.offsetY);\r\n        }\r\n\r\n        bullet.body.collideWorldBounds = this.bulletCollideWorldBounds;\r\n\r\n        bullet.data.bodyDirty = false;\r\n      }\r\n\r\n      bullet.body.setVelocity(moveX, moveY);\r\n      bullet.body.setGravity(this.bulletGravity.x, this.bulletGravity.y);\r\n\r\n      let next = 0;\r\n\r\n      if (this.bulletSpeedVariance !== 0) {\r\n        let rate = this.fireRate;\r\n\r\n        rate += Phaser.Math.Between(-this.fireRateVariance, this.fireRateVariance);\r\n\r\n        if (rate < 0) {\r\n          rate = 0;\r\n        }\r\n\r\n        next = this.scene.time.now + rate;\r\n      } else {\r\n        next = this.scene.time.now + this.fireRate;\r\n      }\r\n\r\n      if (this.multiFire) {\r\n        if (!this._hasFired) {\r\n          //  We only add 1 to the 'shots' count for multiFire shots\r\n          this._hasFired = true;\r\n          this._tempNextFire = next;\r\n          this.shots++;\r\n        }\r\n      } else {\r\n        this._nextFire = next;\r\n\r\n        this.shots++;\r\n      }\r\n\r\n      this.eventEmitter.emit('fire', bullet, this, speed);\r\n\r\n      if (this.fireLimit > 0 && this.shots === this.fireLimit) {\r\n        this.eventEmitter('firelimit', this, this.fireLimit);\r\n      }\r\n    }\r\n\r\n    return bullet;\r\n  }\r\n\r\n  /**\r\n   * You can modify the size of the physics Body the Bullets use to be any dimension you need.\r\n   * This allows you to make it smaller, or larger, than the parent Sprite.\r\n   * You can also control the x and y offset of the Body. This is the position of the\r\n   * Body relative to the top-left of the Sprite _texture_.\r\n   *\r\n   * For example: If you have a Sprite with a texture that is 80x100 in size,\r\n   * and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:\r\n   *\r\n   * `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`\r\n   *\r\n   * Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.\r\n   * 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34\r\n   * is the vertical offset.\r\n   *\r\n   * @param {number} width - The width of the Body.\r\n   * @param {number} height - The height of the Body.\r\n   * @param {number} [offsetX] - The X offset of the Body from the top-left of the Sprites texture.\r\n   * @param {number} [offsetY] - The Y offset of the Body from the top-left of the Sprites texture.\r\n   * @return {Weapon} The Weapon Plugin.\r\n   */\r\n  setBulletBodyOffset(width, height, offsetX, offsetY) {\r\n    if (offsetX === undefined) {\r\n      offsetX = 0;\r\n    }\r\n    if (offsetY === undefined) {\r\n      offsetY = 0;\r\n    }\r\n\r\n    this._data.customBody = true;\r\n    this._data.width = width;\r\n    this._data.height = height;\r\n    this._data.offsetX = offsetX;\r\n    this._data.offsetY = offsetY;\r\n\r\n    //  Update all bullets in the pool\r\n    this.bullets.children.each(child => {\r\n      child.body.setSize(width, height);\r\n      child.body.setOffset(offsetX, offsetY);\r\n    });\r\n    //this.bullets.setAll('data.bodyDirty', false);\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the texture frames that the bullets can use when being launched.\r\n   *\r\n   * This is intended for use when you've got numeric based frames, such as\r\n   * those loaded via a Sprite Sheet.\r\n   *\r\n   * It works by calling `Phaser.Utils.Array.NumberArray` internally, using\r\n   * the min and max values provided. Then it sets the frame index to be zero.\r\n   *\r\n   * You can optionally set the cycle and random booleans, to allow bullets to\r\n   * cycle through the frames when they're fired, or pick one at random.\r\n   *\r\n   * @param {integer} min - The minimum value the frame can be. Usually zero.\r\n   * @param {integer} max - The maximum value the frame can be.\r\n   * @param {integer} [selcetionMethod=BULLET_FRAME_STABLE] - Specifies how the\r\n   *  frame for the fired bullet will be selected. See consts.BULLET_FRAME_XYZ\r\n   *  for options.\r\n   * @return {Weapon} The Weapon Plugin.\r\n   */\r\n  setBulletFrames(min, max, selectionMethod) {\r\n    if (selectionMethod === undefined) {\r\n      selectionMethod = consts.BULLET_FRAME_STABLE;\r\n    }\r\n    if (\r\n      typeof selectionMethod !== 'number' ||\r\n      selectionMethod < consts.BULLET_FRAME_STABLE ||\r\n      selectionMethod > consts.BULLET_FRAME_RANDOM\r\n    ) {\r\n      throw new Error(`Invalid bullet frame selection method specified: ${selectionMethod}`)\r\n    }\r\n\r\n    if (min > max) {\r\n      throw new Error(`min frame (${min}) must be <= max frame ${max}`)\r\n    }\r\n\r\n    this.bulletFrames = Phaser.Utils.Array.NumberArray(min, max);\r\n    this.bulletFrameIndex = 0;\r\n    this.bulletFrameCycle = selectionMethod === consts.BULLET_FRAME_CYCLE;\r\n    this.bulletFrameRandom = selectionMethod === consts.BULLET_FRAME_RANDOM;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\r\n   * The arguments are all the same as for `Animation.add`, and work in the same way.\r\n   *\r\n   * {@link #bulletAnimation} will be set to this animation after it's created. From that point on, all\r\n   * bullets fired will play using this animation. You can swap between animations by calling this method\r\n   * several times, and then just changing the {@link #bulletAnimation} property to the name of the animation\r\n   * you wish to play for the next launched bullet.\r\n   *\r\n   * If you wish to stop using animations at all, set {@link #bulletAnimation} to '' (an empty string).\r\n   *\r\n   * @param {string} name - The unique (within the Weapon instance) name for the animation, i.e. \"fire\", \"blast\".\r\n   * @param {Array} [frames=null] - An array of numbers/strings that correspond to the frames to add to this animation and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\r\n   * @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.\r\n   * @param {number} [loop=1] - Number of times to repeat the animation. Set to -1 to repeat forever.\r\n   * @return {Weapon} The Weapon Plugin.\r\n   */\r\n  addBulletAnimation(name, frames, frameRate, loop) {\r\n    if (!this.scene.sys.anims.anims.contains(name)) {\r\n      this.scene.sys.anims.create({\r\n        key: name,\r\n        frames,\r\n        frameRate,\r\n        loop,\r\n      });\r\n\r\n      this.anims[name] = this.scene.sys.anims.anims.entries[name];\r\n    }\r\n\r\n    this.bulletAnimation = name;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Uses `Game.Debug` to draw some useful information about this Weapon, including the number of bullets\r\n   * both in-flight, and available. And optionally the physics debug bodies of the bullets.\r\n   *\r\n   * @param {integer} [x=16] - The coordinate, in screen space, at which to draw the Weapon debug data.\r\n   * @param {integer} [y=32] - The coordinate, in screen space, at which to draw the Weapon debug data.\r\n   * @param {boolean} [debugBodies=false] - Optionally draw the physics body of every bullet in-flight.\r\n   */\r\n  debug(x, y, debugBodies) {\r\n    /*if (x === undefined) {\r\n      x = 16;\r\n    }\r\n    if (y === undefined) {\r\n      y = 32;\r\n    }\r\n    if (debugBodies === undefined) {\r\n      debugBodies = false;\r\n    }\r\n\r\n    this.game.debug.text('Weapon Plugin', x, y);\r\n    this.game.debug.text(\r\n      'Bullets Alive: ' + this.bullets.total + ' - Total: ' + this.bullets.length,\r\n      x,\r\n      y + 24\r\n    );\r\n\r\n    if (debugBodies) {\r\n      this.bullets.forEachExists(this.game.debug.body, this.game.debug, 'rgba(255, 0, 255, 0.8)');\r\n    }*/\r\n  }\r\n\r\n  /**\r\n   * Internal update method, called by the Weapon Plugin.\r\n   * @returns {void}\r\n   */\r\n  update() {\r\n    if (this._bulletKillType === consts.KILL_WEAPON_BOUNDS) {\r\n      if (this.trackedSprite) {\r\n        this.trackedSprite.updateTransform();\r\n        this.bounds.centerOn(this.trackedSprite.x, this.trackedSprite.y);\r\n      } else if (this.trackedPointer) {\r\n        this.bounds.centerOn(this.trackedPointer.x, this.trackedPointer.y);\r\n      }\r\n    }\r\n\r\n    if (this.autofire) {\r\n      this.fire();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal update method, called by the Weapon Plugin.\r\n   *\r\n   * @protected\r\n   * @returns {void}\r\n   */\r\n  postRender() {\r\n    if (!this.multiFire || !this._hasFired) {\r\n      return;\r\n    }\r\n\r\n    this._hasFired = false;\r\n\r\n    this._nextFire = this._tempNextFire;\r\n  }\r\n\r\n  /**\r\n   * Destroys this Weapon.\r\n   * You must release everything in here, all references, all objects, free it all up.\r\n   * @returns {void}\r\n   */\r\n  destroy() {\r\n    this.scene = null;\r\n\r\n    this.bullets.destroy(true);\r\n  }\r\n}\r\n\r\n/**\r\n * The Class of the bullets that are launched by this Weapon. Defaults to {@link Phaser.Bullet}, but can be\r\n * overridden before calling `createBullets` and set to your own class type.\r\n *\r\n * It should be a constructor function accepting `(game, x, y, key, frame)`.\r\n *\r\n * @name Weapon#bulletClass\r\n * @property {function} bulletClass\r\n */\r\nObject.defineProperty(Weapon.prototype, 'bulletClass', {\r\n  get() {\r\n    return this._bulletClass;\r\n  },\r\n\r\n  set(classType) {\r\n    this._bulletClass = classType;\r\n\r\n    // `this.bullets` exists only after createBullets()\r\n    if (this.bullets) {\r\n      this.bullets.classType = this._bulletClass;\r\n    }\r\n  },\r\n});\r\n\r\n/**\r\n * This controls how the bullets will be killed. The default is `consts.KILL_WORLD_BOUNDS`.\r\n *\r\n * There are 7 different \"kill types\" available:\r\n *\r\n * * `consts.KILL_NEVER`\r\n * The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.\r\n *\r\n * * `consts.KILL_LIFESPAN`\r\n * The bullets are automatically killed when their `bulletLifespan` amount expires.\r\n *\r\n * * `consts.KILL_DISTANCE`\r\n * The bullets are automatically killed when they exceed `bulletDistance` pixels away from their original launch position.\r\n *\r\n * * `consts.KILL_WEAPON_BOUNDS`\r\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\r\n *\r\n * * `consts.KILL_CAMERA_BOUNDS`\r\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.Camera#bounds} rectangle.\r\n *\r\n * * `consts.KILL_WORLD_BOUNDS`\r\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.World#bounds} rectangle.\r\n *\r\n * * `consts.KILL_STATIC_BOUNDS`\r\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\r\n * The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to\r\n * match the position of a tracked sprite or pointer.\r\n *\r\n * @name Weapon#bulletKillType\r\n * @property {integer} bulletKillType\r\n */\r\nObject.defineProperty(Weapon.prototype, 'bulletKillType', {\r\n  get() {\r\n    return this._bulletKillType;\r\n  },\r\n\r\n  set(type) {\r\n    switch (type) {\r\n      case consts.KILL_STATIC_BOUNDS:\r\n      case consts.KILL_WEAPON_BOUNDS:\r\n        this.bulletBounds = this.bounds;\r\n        break;\r\n\r\n      case consts.KILL_CAMERA_BOUNDS:\r\n        this.bulletBounds = this.scene.sys.cameras.main._bounds;\r\n        break;\r\n\r\n      case consts.KILL_WORLD_BOUNDS:\r\n        this.bulletBounds = this.scene.physics.world.bounds;\r\n        break;\r\n    }\r\n\r\n    this._bulletKillType = type;\r\n  },\r\n});\r\n\r\n/**\r\n * Should bullets collide with the World bounds or not?\r\n *\r\n * @name Weapon#bulletCollideWorldBounds\r\n * @property {boolean} bulletCollideWorldBounds\r\n */\r\nObject.defineProperty(Weapon.prototype, 'bulletCollideWorldBounds', {\r\n  get() {\r\n    return this._bulletCollideWorldBounds;\r\n  },\r\n\r\n  set(value) {\r\n    this._bulletCollideWorldBounds = value;\r\n\r\n    this.bullets.children.each(child => {\r\n      child.body.collideWorldBounds = value;\r\n      child.data.bodyDirty = false;\r\n    });\r\n  },\r\n});\r\n\r\n/**\r\n * The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and\r\n * can be overridden by the {@link #fire} arguments.\r\n *\r\n * @name Weapon#x\r\n * @property {number} x\r\n */\r\nObject.defineProperty(Weapon.prototype, 'x', {\r\n  get() {\r\n    return this.fireFrom.x;\r\n  },\r\n\r\n  set(value) {\r\n    this.fireFrom.x = value;\r\n  },\r\n});\r\n\r\n/**\r\n * The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and\r\n * can be overridden by the {@link #fire} arguments.\r\n *\r\n * @name Weapon#y\r\n * @property {number} y\r\n */\r\nObject.defineProperty(Weapon.prototype, 'y', {\r\n  get() {\r\n    return this.fireFrom.y;\r\n  },\r\n\r\n  set(value) {\r\n    this.fireFrom.y = value;\r\n  },\r\n});\r\n\r\nmodule.exports = Weapon;\r\n\n\n\n// WEBPACK FOOTER //\n// ./Weapon.js"],"sourceRoot":""}