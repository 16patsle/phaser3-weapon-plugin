{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///WeaponPlugin.min.js","webpack:///webpack/bootstrap a98f8ebfdf2be11a4972","webpack:///./consts.js","webpack:///./Bullet.js","webpack:///./main.js","webpack:///./Weapon.js","webpack:///./validateConfig.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","KILL_NEVER","KILL_LIFESPAN","KILL_DISTANCE","KILL_WEAPON_BOUNDS","KILL_CAMERA_BOUNDS","KILL_WORLD_BOUNDS","KILL_STATIC_BOUNDS","ANGLE_UP","ANGLE_DOWN","ANGLE_LEFT","ANGLE_RIGHT","ANGLE_NORTH_EAST","ANGLE_NORTH_WEST","ANGLE_SOUTH_EAST","ANGLE_SOUTH_WEST","BULLET_FRAME_STABLE","BULLET_FRAME_CYCLE","BULLET_FRAME_RANDOM","_typeof","obj","Symbol","iterator","constructor","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","writable","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","_assertThisInitialized","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","ReferenceError","_inherits","subClass","superClass","create","value","_setPrototypeOf","__WEBPACK_IMPORTED_MODULE_0__consts__","bulletID","Bullet","_Phaser$GameObjects$S","scene","x","y","frame","_this","physics","add","existing","setDataEnabled","setData","timeEvent","bulletManager","fromX","fromY","bodyDirty","rotateToVelocity","killType","killDistance","bodyBounds","Phaser","Geom","Rectangle","setActive","setVisible","body","enable","reset","debugShowBody","getData","debugPhysics","debugShowVelocity","stop","destroy","eventEmitter","emit","active","Math","Vector2","distance","kill","Intersects","RectangleToRectangle","bulletBounds","getBounds","rotation","velocity","atan","bulletWorldWrap","world","wrap","bulletWorldWrapPadding","GameObjects","Sprite","__WEBPACK_IMPORTED_MODULE_0__Weapon__","__WEBPACK_IMPORTED_MODULE_1__Bullet__","__WEBPACK_IMPORTED_MODULE_2__consts__","WeaponPlugin","_Phaser$Plugins$Scene","pluginManager","weapons","registerGameObject","bind","config","bulletLimit","group","weaponClass","weapon","push","systems","events","on","postRender","update","forEach","game","Plugins","ScenePlugin","Weapon","consts","__WEBPACK_IMPORTED_MODULE_0__Bullet__","__WEBPACK_IMPORTED_MODULE_1__consts__","__WEBPACK_IMPORTED_MODULE_2__validateConfig__","_bullets","_autoExpandBulletsGroup","_autofire","_shots","_fireLimit","_fireRate","_fireRateVariance","_fireFrom","_fireAngle","_bulletInheritSpriteSpeed","_bulletAnimation","_bulletFrameRandom","_bulletFrameCycle","_bulletWorldWrap","_bulletWorldWrapPadding","_bulletAngleOffset","_bulletAngleVariance","_bulletSpeed","_bulletSpeedVariance","_bulletLifespan","_bulletKillDistance","_bulletGravity","_bulletRotateToVelocity","_bulletKey","_bulletFrame","_bulletClass","_bulletCollideWorldBounds","_bulletKillType","_data","customBody","width","height","offsetX","offsetY","_bounds","_bulletBounds","bounds","_bulletFrames","_bulletFrameIndex","anims","_trackedSprite","_trackedPointer","_multiFire","_hasFired","_trackRotation","_trackOffset","_nextFire","_tempNextFire","_rotatedPoint","logLevel","Events","EventEmitter","createBullets","quantity","arguments","undefined","bulletClass","bullets","classType","maxSize","runChildUpdate","autoExpandBulletsGroup","createMultiple","repeat","visible","children","each","child","bulletKey","bulletFrame","addMultiple","entries","callback","callbackContext","extraArgs","paused","newLimit","shots","fireLimit","sprite","trackRotation","trackedPointer","trackedSprite","trackOffset","set","pointer","input","activePointer","positions","from","multiFire","offset","fire","position","time","now","speed","bulletSpeed","bulletSpeedVariance","Between","updateFireFrom","RotateAround","bulletInheritSpriteSpeed","fireFrom","randomX","random","randomY","angle","fireAngle","RadToDeg","atan2","bulletAngleVariance","moveX","moveY","cos","DegToRad","sin","bullet","getFirstDead","prepare","bulletKillType","bulletKillDistance","bulletRotateToVelocity","addEvent","delay","bulletLifespan","callbackScope","lifespan","bulletAngleOffset","bulletAnimation","play","bulletFrameCycle","bulletFrameIndex","bulletFrames","setTexture","bulletFrameRandom","nextFrame","floor","setSize","setOffset","collideWorldBounds","bulletCollideWorldBounds","setVelocity","setGravity","bulletGravity","next","rate","fireRate","fireRateVariance","CenterOn","min","max","selectionMethod","concat","Utils","Array","NumberArray","frames","frameRate","loop","sys","contains","updateTransform","autofire","type","cameras","main","log","text","console","warn","Error","validateConfig","includes"],"mappings":"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","file":"WeaponPlugin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WeaponPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WeaponPlugin\"] = factory();\n\telse\n\t\troot[\"WeaponPlugin\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WeaponPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WeaponPlugin\"] = factory();\n\telse\n\t\troot[\"WeaponPlugin\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  /**\n   * A {@link #bulletKillType} constant that stops the bullets from ever being destroyed automatically.\n   * @constant\n   * @type {integer}\n   */\n  KILL_NEVER: 0,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when their {@link #bulletLifespan} expires.\n   * @constant\n   * @type {integer}\n   */\n  KILL_LIFESPAN: 1,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets after they\n   * exceed the {@link #bulletDistance} from their original firing position.\n   * @constant\n   * @type {integer}\n   */\n  KILL_DISTANCE: 2,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WEAPON_BOUNDS: 3,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link Phaser.Camera#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_CAMERA_BOUNDS: 4,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link Phaser.World#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WORLD_BOUNDS: 5,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_STATIC_BOUNDS: 6,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face up.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_UP: 270,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face down.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_DOWN: 90,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face left.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_LEFT: 180,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face right.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_RIGHT: 0,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\n   * @constant Phaser.ANGLE_NORTH_EAST\n   * @type {integer}\n   */\n  ANGLE_NORTH_EAST: 315,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_NORTH_WEST: 225,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_EAST: 45,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_WEST: 135,\n\n  /**\n   * When selecting a bullet frame the same frame should always be used. This\n   * is the default value.\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_STABLE: 0,\n\n  /**\n   * When selecting a bullet frame the next frame should be used\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_CYCLE: 1,\n\n  /**\n   * When selecting a bullet frame a random frame should be used.\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_RANDOM: 2\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__consts__ = __webpack_require__(0);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar bulletID = 0;\n\nvar Bullet =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$S) {\n  _inherits(Bullet, _Phaser$GameObjects$S);\n\n  /**\n   * Create a new `Bullet` object. Bullets are used by the `Weapon` class, and are normal Sprites,\n   * with a few extra properties in the data manager to handle Weapon specific features.\n   *\n   * @param {Phaser.Scene} scene - A reference to the currently running scene.\n   * @param {number} x - The x coordinate (in world space) to position the Particle at.\n   * @param {number} y - The y coordinate (in world space) to position the Particle at.\n   * @param {string} key - This is the image or texture used by the Particle during rendering.\n   * It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas\n   * you can specify the exact frame to use by giving a string or numeric index.\n   */\n  function Bullet(scene, x, y, key, frame) {\n    var _this;\n\n    _classCallCheck(this, Bullet);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Bullet).call(this, scene, x, y, key, frame));\n    _this.bulletID = bulletID;\n    bulletID++;\n\n    _this.scene.physics.add.existing(_assertThisInitialized(_this));\n\n    _this.setDataEnabled();\n\n    _this.setData({\n      timeEvent: null,\n      bulletManager: null,\n      fromX: 0,\n      fromY: 0,\n      bodyDirty: true,\n      rotateToVelocity: false,\n      killType: 0,\n      killDistance: 0,\n      bodyBounds: new Phaser.Geom.Rectangle()\n    });\n\n    return _this;\n  }\n  /**\n   * Prepares this bullet to be fired and interact with the rest of the scene\n   * again.\n   * @returns {void}\n   */\n\n\n  _createClass(Bullet, [{\n    key: \"prepare\",\n    value: function prepare(x, y) {\n      this.setActive(true);\n      this.setVisible(true);\n      this.body.enable = true;\n      this.body.reset(x, y);\n      this.body.debugShowBody = this.getData('bulletManager').debugPhysics;\n      this.body.debugShowVelocity = this.getData('bulletManager').debugPhysics;\n    }\n    /**\n     * Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.\n     * Also dispatches the `Weapon`s kill signal.\n     * @returns {Bullet} This instance of the bullet class\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Reproduce Phaser.Physics.Arcade.Components.Enable.disableBody because\n      // we can't assume that the bullet class has it built in.\n      this.body.stop();\n      this.body.enable = false;\n      this.setActive(false);\n      this.setVisible(false);\n      this.body.debugShowBody = false;\n      this.body.debugShowVelocity = false; // TODO: potentially we don't need to destroy the time event and we can\n      // just pause when the bullet is killed and restart it when it's refired.\n      // For now though do the simple thing and discard it.\n      // Another option would be to use Date.now() and manually process pause\n      // events with a flag and some math.\n      // Both of those are probably premature optimizations.\n\n      if (this.getData('timeEvent') !== null) {\n        this.getData('timeEvent').destroy();\n        this.setData('timeEvent', null);\n      }\n\n      this.getData('bulletManager').eventEmitter.emit('kill', this);\n      return this;\n    }\n    /**\n     * Updates the Bullet, killing as required.\n     * @returns {Bullet} This instance of the bullet class\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.active) {\n        // this was previously a check to this.exists\n        return;\n      }\n\n      if (this.getData('killType') > __WEBPACK_IMPORTED_MODULE_0__consts__[\"a\" /* default */].KILL_LIFESPAN) {\n        if (this.getData('killType') === __WEBPACK_IMPORTED_MODULE_0__consts__[\"a\" /* default */].KILL_DISTANCE) {\n          if (new Phaser.Math.Vector2(this.getData('fromX'), this.getData('fromY')).distance(this) > this.getData('killDistance')) {\n            this.kill();\n          }\n        } else if (!Phaser.Geom.Intersects.RectangleToRectangle(this.getData('bulletManager').bulletBounds, this.body.getBounds(this.getData('bodyBounds')))) {\n          this.kill();\n        }\n      }\n\n      if (this.getData('rotateToVelocity')) {\n        this.rotation = this.body.velocity.atan();\n      }\n\n      if (this.getData('bulletManager').bulletWorldWrap) {\n        this.scene.physics.world.wrap(this, this.getData('bulletManager').bulletWorldWrapPadding);\n      }\n    }\n  }]);\n\n  return Bullet;\n}(Phaser.GameObjects.Sprite);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Bullet);\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Weapon__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Bullet__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__consts__ = __webpack_require__(0);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/16patsle/phaser3-weapon-plugin/blob/master/LICENSE|MIT License}\n */\n\n\n\n/**\n * The Weapon Plugin provides the ability to easily create a bullet pool\n * and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, like iterate it, etc can be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.setPosition(300, 300);\n * this.input.on('pointerdown', weapon.fire, this);\n * ```\n */\n\nvar WeaponPlugin =\n/*#__PURE__*/\nfunction (_Phaser$Plugins$Scene) {\n  _inherits(WeaponPlugin, _Phaser$Plugins$Scene);\n\n  /**\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the\n   *  Phaser.Plugins.PluginManager instance.\n   */\n  function WeaponPlugin(scene, pluginManager) {\n    var _this;\n\n    _classCallCheck(this, WeaponPlugin);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WeaponPlugin).call(this, scene, pluginManager));\n    _this.weapons = []; // Register our new Game Object type\n\n    pluginManager.registerGameObject('weapon', _this.add.bind(_assertThisInitialized(_this)), function (config) {\n      return _this.add(config.bulletLimit, config.key, config.frame, config.group, config.weaponClass);\n    });\n    return _this;\n  }\n\n  _createClass(WeaponPlugin, [{\n    key: \"add\",\n    value: function add(bulletLimit, key, frame, group, weaponClass) {\n      if (!weaponClass) {\n        weaponClass = __WEBPACK_IMPORTED_MODULE_0__Weapon__[\"a\" /* default */];\n      }\n\n      var weapon = new weaponClass(this.scene, bulletLimit, key, frame, group);\n      this.weapons.push(weapon);\n      return weapon;\n    }\n    /**\n     * Called by the PluginManager when this plugin is started.\n     * If a plugin is stopped, and then started again, this will get called again.\n     * Typically called immediately after `BasePlugin.init`.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.systems.events.on('postrender', this.postRender, this);\n    }\n    /**\n     * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\n     * By this point the plugin properties `scene` and `systems` will have already been set.\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"boot\",\n    value: function boot() {\n      var eventEmitter = this.systems.events;\n      eventEmitter.on('update', this.update, this);\n      eventEmitter.on('destroy', this.destroy, this);\n    }\n    /**\n     * Internal update method, called by the PluginManager.\n     *\n     * @protected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.weapons.forEach(function (weapon) {\n        weapon.update();\n      });\n    }\n    /**\n     * Internal update method, called by the PluginManager.\n     *\n     * @protected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"postRender\",\n    value: function postRender() {\n      this.weapons.forEach(function (weapon) {\n        weapon.postRender();\n      });\n    }\n    /**\n     * Destroys this Weapon.\n     * You must release everything in here, all references, all objects, free it all up.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.pluginManager = null;\n      this.game = null;\n      this.scene = null;\n      this.systems = null;\n    }\n  }]);\n\n  return WeaponPlugin;\n}(Phaser.Plugins.ScenePlugin); // Set up shortcuts to the classes and constants\n\n\nWeaponPlugin.Weapon = __WEBPACK_IMPORTED_MODULE_0__Weapon__[\"a\" /* default */];\nWeaponPlugin.Bullet = __WEBPACK_IMPORTED_MODULE_1__Bullet__[\"a\" /* default */];\nWeaponPlugin.consts = __WEBPACK_IMPORTED_MODULE_2__consts__[\"a\" /* default */];\n/* harmony default export */ __webpack_exports__[\"default\"] = (WeaponPlugin);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Bullet__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__consts__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__validateConfig__ = __webpack_require__(4);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n/**\n * The Weapon provides the ability to easily create a bullet pool and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, like iterate it, etc can be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.setPosition(300, 300);\n * this.input.on('pointerdown', weapon.fire, this);\n * ```\n */\n\nvar Weapon =\n/*#__PURE__*/\nfunction () {\n  /**\n   * TODO: a builder style interface would be neat. Can be kicked way forward\n   * into polishing.\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {number} bulletLimit - The number of bullets to create.\n   * @param {String} key - The texture key for the bullet.\n   * @param {String} frame - The frame name for the bullet.\n   * @param {Phaser.GameObjects.Group} group - A group to add the bullets to.\n   */\n  function Weapon(scene, bulletLimit, key, frame, group) {\n    _classCallCheck(this, Weapon);\n\n    this.scene = scene;\n    this.debugPhysics = null;\n    /**\n     * Private var that holds the public `bullets` property.\n     * @type {Phaser.GameObjects.Group}\n     * @private\n     */\n\n    this._bullets = null;\n    /**\n     * Private var that holds the public `autoExpandBulletsGroup` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._autoExpandBulletsGroup = false;\n    /**\n     * Private var that holds the public `autofire` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._autofire = false;\n    /**\n     * Private var that holds the public `shots` property.\n     * @type {number}\n     * @private\n     */\n\n    this._shots = 0;\n    /**\n     * Private var that holds the public `fireLimit` property.\n     * @type {number}\n     * @private\n     */\n\n    this._fireLimit = 0;\n    /**\n     * Private var that holds the public `fireRate` property.\n     * @type {number}\n     * @private\n     */\n\n    this._fireRate = 100;\n    /**\n     * Private var that holds the public `fireRateVariance` property.\n     * @type {number}\n     * @private\n     */\n\n    this._fireRateVariance = 0;\n    /**\n     * Private var that holds the public `fireFrom` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n\n    this._fireFrom = new Phaser.Geom.Rectangle(0, 0, 1, 1);\n    /**\n     * Private var that holds the public `fireAngle` property.\n     * @type {integer}\n     * @private\n     */\n\n    this._fireAngle = __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].ANGLE_UP;\n    /**\n     * Private var that holds the public `bulletInheritSpriteSpeed` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletInheritSpriteSpeed = false;\n    /**\n     * Private var that holds the public `bulletAnimation` property.\n     * @type {string}\n     * @private\n     */\n\n    this._bulletAnimation = '';\n    /**\n     * Private var that holds the public `bulletFrameRandom` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletFrameRandom = false;\n    /**\n     * Private var that holds the public `bulletFrameCycle` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletFrameCycle = false;\n    /**\n     * Private var that holds the public `bulletWorldWrap` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletWorldWrap = false;\n    /**\n     * Private var that holds the public `bulletWorldWrapPadding` property.\n     * @type {integer}\n     * @private\n     */\n\n    this._bulletWorldWrapPadding = 0;\n    /**\n     * Private var that holds the public `bulletAngleOffset` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletAngleOffset = 0;\n    /**\n     * Private var that holds the public `bulletAngleVariance` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletAngleVariance = 0;\n    /**\n     * Private var that holds the public `bulletSpeed` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletSpeed = 200;\n    /**\n     * Private var that holds the public `bulletSpeedVariance` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletSpeedVariance = 0;\n    /**\n     * Private var that holds the public `bulletLifespan` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletLifespan = 0;\n    /**\n     * Private var that holds the public `bulletKillDistance` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletKillDistance = 0;\n    /**\n     * Private var that holds the public `bulletGravity` property.\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n\n    this._bulletGravity = new Phaser.Math.Vector2(0, 0);\n    /**\n     * Private var that holds the public `bulletRotateToVelocity` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletRotateToVelocity = false;\n    /**\n     * Private var that holds the public `bulletKey` property.\n     * @type {string}\n     * @private\n     */\n\n    this._bulletKey = key || '';\n    /**\n     * Private var that holds the public `bulletFrame` property.\n     * @type {string|integer}\n     * @private\n     */\n\n    this._bulletFrame = frame || '';\n    /**\n     * Private var that holds the public `bulletClass` property.\n     * @type {function}\n     * @private\n     */\n\n    this._bulletClass = __WEBPACK_IMPORTED_MODULE_0__Bullet__[\"a\" /* default */];\n    /**\n     * Private var that holds the public `bulletCollideWorldBounds` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletCollideWorldBounds = false;\n    /**\n     * Private var that holds the public `bulletKillType` property.\n     * @type {integer}\n     * @private\n     */\n\n    this._bulletKillType = __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_WORLD_BOUNDS;\n    /**\n     * Holds internal data about custom bullet body sizes.\n     *\n     * @type {Object}\n     * @private\n     */\n\n    this._data = {\n      customBody: false,\n      width: 0,\n      height: 0,\n      offsetX: 0,\n      offsetY: 0\n    };\n    /**\n     * Private var that holds the public `bounds` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n\n    this._bounds = new Phaser.Geom.Rectangle();\n    /**\n     * Private var that holds the public `bulletBounds` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n\n    this._bulletBounds = this.scene.physics.world.bounds;\n    /**\n     * This array stores the frames added via @link #setBulletFrames.\n     *\n     * @type {Array}\n     * @protected\n     */\n\n    this._bulletFrames = [];\n    /**\n     * Private var that holds the public `bulletFrameIndex` property.\n     * @type {number}\n     * @private\n     */\n\n    this._bulletFrameIndex = 0;\n    /**\n     * An internal object that stores the animation data added via {@link #addBulletAnimation}.\n     * @type {Object}\n     * @private\n     */\n\n    this.anims = {};\n    /**\n     * Private var that holds the public `trackedSprite` property.\n     * @type {Phaser.GameObjects.Sprite|Object}\n     * @private\n     */\n\n    this._trackedSprite = null;\n    /**\n     * Private var that holds the public `trackedPointer` property.\n     * @type {Phaser.Input.Pointer}\n     * @private\n     */\n\n    this._trackedPointer = null;\n    /**\n     * Private var that holds the public `multiFire` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._multiFire = false;\n    /**\n     * Internal multiFire test flag.\n     *\n     * @type {boolean}\n     * @private\n     */\n\n    this._hasFired = false;\n    /**\n     * Private var that holds the public `trackRotation` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._trackRotation = false;\n    /**\n     * Private var that holds the public `trackOffset` property.\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n\n    this._trackOffset = new Phaser.Math.Vector2();\n    /**\n     * Internal firing rate time tracking variable.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._nextFire = 0;\n    /**\n     * Internal firing rate time tracking variable used by multiFire.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._tempNextFire = 0;\n    /**\n     * Internal firing rotation tracking point.\n     *\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n\n    this._rotatedPoint = new Phaser.Math.Vector2();\n    /**\n     * Log level for this weapon. Either `warn`, `error' or `off`. `warn` is the default.\n     * If you change this, please do so before setting any other properties.\n     * \n     * @type {string}\n     */\n\n    this.logLevel = 'warn';\n    this.eventEmitter = new Phaser.Events.EventEmitter();\n    Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this);\n    this.createBullets(bulletLimit, key, frame, group);\n  }\n  /**\n   * This is the Phaser.Group that contains all of the bullets managed by this plugin.\n   * @type {Phaser.GameObjects.Group}\n   */\n\n\n  _createClass(Weapon, [{\n    key: \"createBullets\",\n\n    /**\n     * This method performs two actions: First it will check to see if the\n     * {@link #bullets} Group exists or not, and if not it creates it, adding its\n     * children to the `group` given as the 4th argument.\n     *\n     * Then it will seed the bullet pool with the `quantity` number of Bullets,\n     * using the texture key and frame provided (if any).\n     *\n     * If for example you set the quantity to be 10, then this Weapon will only\n     * ever be able to have 10 bullets in-flight simultaneously. If you try to\n     * fire an 11th bullet then nothing will happen until one, or more, of the\n     * in-flight bullets have been killed, freeing them up for use by the Weapon\n     * again.\n     *\n     * If you do not wish to have a limit set, then pass in -1 as the quantity.\n     * In this instance the Weapon will keep increasing the size of the bullet\n     * pool as needed. It will never reduce the size of the pool however, so be\n     * careful it doesn't grow too large.\n     *\n     * You can either set the texture key and frame here, or via the\n     * {@link #bulletKey} and {@link #bulletFrame} properties. You can also\n     * animate bullets, or set them to use random frames. All Bullets belonging\n     * to a single Weapon instance must share the same texture key however.\n     *\n     * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon\n     *  with. If -1 it will set the pool to automatically expand.\n     * @param {string} [key] - The Game.cache key of the image that this Sprite\n     *  will use.\n     * @param {integer|string} [frame] - If the Sprite image contains multiple\n     *  frames you can specify which one to use here.\n     * @param {Phaser.GameObjects.Group} [group] - Optional Group to add the\n     *  object to. If not specified it will be added to the World group.\n     * @return {Weapon} This Weapon instance.\n     */\n    value: function createBullets() {\n      var quantity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var key = arguments.length > 1 ? arguments[1] : undefined;\n      var frame = arguments.length > 2 ? arguments[2] : undefined;\n      var group = arguments.length > 3 ? arguments[3] : undefined;\n      var bulletClass = arguments.length > 4 ? arguments[4] : undefined;\n\n      if (bulletClass) {\n        this._bulletClass = bulletClass;\n      }\n\n      if (this.bullets && !this.bullets.scene) {\n        this.bullets = null;\n      }\n\n      if (!this.bullets) {\n        this.bullets = this.scene.add.group({\n          classType: this._bulletClass,\n          maxSize: quantity,\n          runChildUpdate: true\n        });\n      }\n\n      if (quantity !== 0) {\n        if (quantity === -1) {\n          this.autoExpandBulletsGroup = true;\n          quantity = 1;\n        }\n\n        this.bullets.createMultiple({\n          key: key,\n          frame: frame,\n          repeat: quantity,\n          active: false,\n          visible: false\n        });\n        this.bullets.children.each(function (child) {\n          child.setData('bulletManager', this);\n        }, this);\n        this.bulletKey = key;\n        this.bulletFrame = frame;\n\n        if (group) {\n          group.addMultiple(this.bullets.children.entries);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Call a function on each in-flight bullet in this Weapon.\n     *\n     * See {@link Phaser.GameObjects.Group#forEachExists forEachExists} for more details.\n     *\n     * @param {function} callback - The function that will be called for each applicable child.\n     * The child will be passed as the first argument.\n     * @param {object} callbackContext - The context in which the function should be called (usually 'this').\n     * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, callbackContext) {\n      var extraArgs = arguments;\n      this.bullets.children.each(function (child) {\n        if (child.active) {\n          callback.call(callbackContext, child, extraArgs);\n        }\n      });\n      return this;\n    }\n    /**\n     * Sets {@link Phaser.Physics.Arcade.Body#enable} to `false` on each bullet in this Weapon.\n     * This has the effect of stopping them in-flight should they be moving.\n     * It also stops them being able to be checked for collision.\n     *\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"pauseAll\",\n    value: function pauseAll() {\n      this.bullets.children.each(function (child) {\n        child.body.enable = false;\n\n        if (child.getData('timeEvent') !== null) {\n          child.getData('timeEvent').paused = true;\n        }\n      }, this);\n      return this;\n    }\n    /**\n     * Sets {@link Phaser.Physics.Arcade.Body#enable} to `true` on each bullet in this Weapon.\n     * This has the effect of resuming their motion should they be in-flight.\n     * It also enables them for collision checks again.\n     *\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"resumeAll\",\n    value: function resumeAll() {\n      this.bullets.children.each(function (child) {\n        child.body.enable = true;\n\n        if (child.getData('timeEvent') !== null) {\n          child.getData('timeEvent').paused = false;\n        }\n      }, this);\n      return this;\n    }\n    /**\n     * Calls {@link Phaser.Bullet#kill} on every in-flight bullet in this Weapon.\n     * Also re-enables their physics bodies, should they have been disabled via {@link #pauseAll}.\n     *\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"killAll\",\n    value: function killAll() {\n      this.bullets.children.each(function (child) {\n        if (child.active) {\n          child.kill();\n        }\n\n        child.body.enable = true;\n      });\n      return this;\n    }\n    /**\n     * Resets the {@link #shots} counter back to zero. This is used when you've set\n     * {@link #fireLimit} and have hit (or just wish to reset) your limit.\n     *\n     * @param {integer} [newLimit] - Optionally set a new {@link #fireLimit}.\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"resetShots\",\n    value: function resetShots(newLimit) {\n      this.shots = 0;\n\n      if (newLimit !== undefined) {\n        this.fireLimit = newLimit;\n      }\n\n      return this;\n    }\n    /**\n     * Sets this Weapon to track the given Sprite, or any Object with a public {@link Phaser.Component.Core#world world}\n     * Point object. When a Weapon tracks a Sprite it will automatically update its {@link #fireFrom} value to match the\n     * Sprite's position within the Game World, adjusting the coordinates based on the offset arguments.\n     *\n     * This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.\n     *\n     * Calling `trackSprite` will reset {@link #trackedPointer} to null, should it have been set, as you can\n     * only track _either_ a Sprite, or a Pointer, at once, but not both.\n     *\n     * @param {Phaser.GameObjects.Sprite|Object} sprite - The Sprite to track the position of.\n     * @param {integer} [offsetX=0] - The horizontal offset from the Sprites position to be applied to the Weapon.\n     * @param {integer} [offsetY=0] - The vertical offset from the Sprites position to be applied to the Weapon.\n     * @param {boolean} [trackRotation=false] - Should the Weapon also track the Sprites rotation?\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"trackSprite\",\n    value: function trackSprite(sprite) {\n      var offsetX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var offsetY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var trackRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this.trackedPointer = null;\n      this.trackedSprite = sprite;\n      this.trackRotation = trackRotation;\n      this.trackOffset.set(offsetX, offsetY);\n      return this;\n    }\n    /**\n     * Sets this Weapon to track the given Pointer.\n     * When a Weapon tracks a Pointer it will automatically update its {@link #fireFrom} value to match the Pointer's\n     * position within the Game World, adjusting the coordinates based on the offset arguments.\n     *\n     * This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.\n     *\n     * Calling `trackPointer` will reset {@link #trackedSprite} to null, should it have been set, as you can\n     * only track _either_ a Pointer, or a Sprite, at once, but not both.\n     *\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to track the position of.\n     * Defaults to `Input.activePointer` if not specified.\n     * @param {integer} [offsetX=0] - The horizontal offset from the Pointers position to be applied to the Weapon.\n     * @param {integer} [offsetY=0] - The vertical offset from the Pointers position to be applied to the Weapon.\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"trackPointer\",\n    value: function trackPointer(pointer) {\n      var offsetX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var offsetY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (pointer === undefined && this.scene.input) {\n        pointer = this.scene.input.activePointer;\n      }\n\n      this.trackedPointer = pointer;\n      this.trackedSprite = null;\n      this.trackRotation = false;\n      this.trackOffset.set(offsetX, offsetY);\n      return this;\n    }\n    /**\n     * Attempts to fire multiple bullets from the positions defined in the given array.\n     *\n     * If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then\n     * the positions are treated as __offsets__ from the given objects position.\n     *\n     * If `from` is undefined, and there is no tracked object, then the bullets are fired\n     * from the given positions, as they exist in the world.\n     *\n     * Calling this method sets {@link #multiFire} to `true`.\n     *\n     * If there are not enough bullets available in the pool, and the pool cannot be extended,\n     * then this method may not fire from all of the given positions.\n     *\n     * When the bullets are launched they have their texture and frame updated, as required.\n     * The velocity of the bullets are calculated based on Weapon properties like {@link #bulletSpeed}.\n     *\n     * @param {array} positions - An array of positions. Each position can be any Object,\n     * as long as it has public `x` and `y` properties, such as Phaser.Point, { x: 0, y: 0 }, Phaser.Sprite, etc.\n     * @param {Phaser.GameObject.Sprite|Phaser.Math.Vector2|Object|string} [from]\n     * Optionally fires the bullets **from** the `x` and `y` properties of this object,\n     * _instead_ of any {@link #trackedSprite} or `trackedPointer` that is set.\n     * @return {array} An array containing all of the fired Phaser.Bullet objects,\n     * if a launch was successful, otherwise an empty array.\n     */\n\n  }, {\n    key: \"fireMany\",\n    value: function fireMany(positions, from) {\n      var _this = this;\n\n      this.multiFire = true;\n      var bullets = [];\n\n      if (from || this.trackedSprite || this.trackedPointer) {\n        positions.forEach(function (offset) {\n          bullets.push(_this.fire(from, null, null, offset.x, offset.y));\n        });\n      } else {\n        positions.forEach(function (position) {\n          bullets.push(_this.fire(position));\n        });\n      }\n\n      return bullets;\n    }\n    /**\n     * Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset\n     * to the position first. This is the same as calling {@link #fire} and passing in the offset arguments.\n     *\n     * If there are no more bullets available in the pool, and the pool cannot be extended,\n     * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n     * the Weapon was fired, as defined in the {@link #fireRate} property.\n     *\n     * Otherwise the first available bullet is selected, launched, and returned.\n     *\n     * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n     * calculated based on Weapon properties like {@link #bulletSpeed}.\n     *\n     * If you wish to fire multiple bullets in a single game update, then set {@link #multiFire} to `true`\n     * and you can call this method as many times as you like, per loop. See also {@link #fireMany}.\n     *\n     * @param {number} [offsetX=0] - The horizontal offset from the position of the tracked Sprite or Pointer,\n     * as set with {@link #trackSprite}.\n     * @param {number} [offsetY=0] - The vertical offset from the position of the tracked Sprite or Pointer,\n     * as set with {@link #trackSprite}.\n     * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n     */\n\n  }, {\n    key: \"fireOffset\",\n    value: function fireOffset() {\n      var offsetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.fire(null, null, null, offsetX, offsetY);\n    }\n    /**\n     * Fires a bullet **at** the given Pointer. The bullet will be launched from the {@link #fireFrom} position,\n     * or from a Tracked Sprite or Pointer, if you have one set.\n     *\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to fire the bullet towards.\n     * @return {Bullet} The fired bullet if successful, null otherwise.\n     */\n\n  }, {\n    key: \"fireAtPointer\",\n    value: function fireAtPointer(pointer) {\n      if (pointer === undefined && this.scene.input) {\n        pointer = this.scene.input.activePointer;\n      }\n\n      return this.fire(null, pointer.x, pointer.y);\n    }\n    /**\n     * Fires a bullet **at** the given Sprite. The bullet will be launched from the {@link #fireFrom} position,\n     * or from a Tracked Sprite or Pointer, if you have one set.\n     *\n     * @param {Phaser.GameObjects.Sprite} [sprite] - The Sprite to fire the bullet towards.\n     * @return {Bullet} The fired bullet if successful, null otherwise.\n     */\n\n  }, {\n    key: \"fireAtSprite\",\n    value: function fireAtSprite(sprite) {\n      return this.fire(null, sprite.x, sprite.y);\n    }\n    /**\n     * Fires a bullet **at** the given coordinates. The bullet will be launched from the {@link #fireFrom} position,\n     * or from a Tracked Sprite or Pointer, if you have one set.\n     *\n     * @param {number} [x] - The x coordinate, in world space, to fire the bullet towards.\n     * @param {number} [y] - The y coordinate, in world space, to fire the bullet towards.\n     * @return {Bullet} The fired bullet if successful, null otherwise.\n     */\n\n  }, {\n    key: \"fireAtXY\",\n    value: function fireAtXY(x, y) {\n      return this.fire(null, x, y);\n    }\n    /**\n     * Attempts to fire a single Bullet. If there are no more bullets available in the pool,\n     * and the pool cannot be extended, then this method returns `null`. It will also return `null`\n     * if not enough time has expired since the last time the Weapon was fired,\n     * as defined in the {@link #fireRate} property.\n     *\n     * Otherwise the first available bullet is selected, launched, and returned.\n     *\n     * The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.\n     *\n     * If you don't provide any of the arguments then it uses those set via properties such as {@link #trackedSprite},\n     * {@link #bulletAngle} and so on.\n     *\n     * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n     * calculated based on Weapon properties like `bulletSpeed`.\n     *\n     * If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`\n     * and you can call `fire` as many times as you like, per loop. Multiple fires in a single update\n     * only counts once towards the `shots` total, but you will still receive a Signal for each bullet.\n     *\n     * @param {Phaser.GameObjects.Sprite|Phaser.Math.Vector2|Object|string} [from]\n     * Optionally fires the bullet **from** the `x` and `y` properties of this object.\n     * If set this overrides {@link #trackedSprite} or `trackedPointer`. Pass `null` to ignore it.\n     * @param {number} [x] - The x coordinate, in world space, to fire the bullet **towards**.\n     * If left as `undefined`, or `null`, the bullet direction is based on its angle.\n     * @param {number} [y] - The y coordinate, in world space, to fire the bullet **towards**.\n     * If left as `undefined`, or `null`, the bullet direction is based on its angle.\n     * @param {number} [offsetX=0] - If the bullet is fired from a tracked Sprite or Pointer,\n     * or the `from` argument is set, this applies a horizontal offset from the launch position.\n     * @param {number} [offsetY=0] - If the bullet is fired from a tracked Sprite or Pointer,\n     * or the `from` argument is set, this applies a vertical offset from the launch position.\n     * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(from) {\n      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n      if (this.scene.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) {\n        return null;\n      }\n\n      var speed = this.bulletSpeed; //  Apply +- speed variance\n\n      if (this.bulletSpeedVariance !== 0) {\n        speed += Phaser.Math.Between(-this.bulletSpeedVariance, this.bulletSpeedVariance);\n      } // Position the fireFrom rectangle\n\n\n      if (from) {\n        // Fire based on passed coordinates\n        this.updateFireFrom(from.x, from.y);\n      } else if (this.trackedSprite) {\n        // Fire based on tracked sprite\n        if (this.trackRotation) {\n          this._rotatedPoint.set(this.trackedSprite.x + this.trackOffset.x, this.trackedSprite.y + this.trackOffset.y);\n\n          Phaser.Math.RotateAround(this._rotatedPoint, this.trackedSprite.x, this.trackedSprite.y, this.trackedSprite.rotation);\n          this.updateFireFrom(this._rotatedPoint.x, this._rotatedPoint.y);\n        } else {\n          this.updateFireFrom(this.trackedSprite.x, this.trackedSprite.y);\n        }\n\n        if (this.bulletInheritSpriteSpeed) {\n          speed += this.trackedSprite.body.speed;\n        }\n      } else if (this.trackedPointer) {\n        // Fire based on tracked pointer\n        this.updateFireFrom(this.trackedPointer.x, this.trackedPointer.y);\n      } // Take offset into account\n\n\n      this.fireFrom.x += offsetX;\n      this.fireFrom.y += offsetY; // Pick a random coordinate inside the fireFrom rectangle\n\n      var randomX = this.fireFrom.x + Math.random() * this.fireFrom.width;\n      var randomY = this.fireFrom.y + Math.random() * this.fireFrom.height;\n      var fromX = this.fireFrom.width > 1 ? randomX : this.fireFrom.x;\n      var fromY = this.fireFrom.height > 1 ? randomY : this.fireFrom.y;\n      var angle = this.trackRotation ? this.trackedSprite.angle : this.fireAngle; //  The position (in world space) to fire the bullet towards, if set\n\n      if (x !== null && y !== null) {\n        angle = Phaser.Math.RadToDeg(Math.atan2(y - fromY, x - fromX));\n      } //  Apply +- angle variance\n\n\n      if (this.bulletAngleVariance !== 0) {\n        angle += Phaser.Math.Between(-this.bulletAngleVariance, this.bulletAngleVariance);\n      }\n\n      var moveX = 0;\n      var moveY = 0; //  Avoid unnecessary sin/cos for right-angled shots\n\n      if (angle === 0 || angle === 180) {\n        // Only cos needed\n        moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n      } else if (angle === 90 || angle === 270) {\n        // Only sin needed\n        moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n      } else {\n        // Need to calculate both\n        moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n        moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n      }\n\n      var bullet = null; // Attempt to get a bullet instance to use\n\n      if (this.autoExpandBulletsGroup) {\n        bullet = this.bullets.getFirstDead(true, fromX, fromY, this.bulletKey, this.bulletFrame);\n        bullet.setData('bulletManager', this);\n      } else {\n        bullet = this.bullets.getFirstDead(false);\n      } // Prepare and fire the bullet\n\n\n      if (bullet) {\n        bullet.prepare(fromX, fromY);\n        bullet.setData({\n          fromX: fromX,\n          fromY: fromY,\n          killType: this.bulletKillType,\n          killDistance: this.bulletKillDistance,\n          rotateToVelocity: this.bulletRotateToVelocity\n        }); // Prepare timer for bullet lifespan\n\n        if (this.bulletKillType === __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_LIFESPAN) {\n          bullet.setData('timeEvent', this.scene.time.addEvent({\n            delay: this.bulletLifespan,\n            callback: bullet.kill,\n            callbackScope: bullet\n          }));\n          bullet.lifespan = this.bulletLifespan;\n        }\n\n        bullet.angle = angle + this.bulletAngleOffset; //  Frames and Animations\n\n        if (this.bulletAnimation) {\n          bullet.anims.play(this.bulletAnimation);\n        } else if (this.bulletFrameCycle) {\n          // Calculate bullet frame to use\n          if (this.bulletFrameIndex >= this.bulletFrames.length) {\n            this.bulletFrameIndex = 0;\n          }\n\n          bullet.setTexture(this.bulletKey, this.bulletFrameIndex);\n          this.bulletFrameIndex++;\n        } else if (this.bulletFrameRandom) {\n          // Pick a bullet frame at random\n          var nextFrame = Math.floor(Math.random() * this.bulletFrames.length);\n          bullet.setTexture(this.bulletKey, nextFrame);\n        } // Set correct size and position for bullet body\n\n\n        if (bullet.getData('bodyDirty')) {\n          if (this._data.customBody) {\n            bullet.body.setSize(this._data.width, this._data.height);\n            bullet.body.setOffset(this._data.offsetX, this._data.offsetY);\n          }\n\n          bullet.body.collideWorldBounds = this.bulletCollideWorldBounds;\n          bullet.setData('bodyDirty', false);\n        }\n\n        bullet.body.setVelocity(moveX, moveY);\n        bullet.body.setGravity(this.bulletGravity.x, this.bulletGravity.y);\n        var next = 0; // Calculate when to fire next bullet, taking into account speed variance\n\n        if (this.bulletSpeedVariance !== 0) {\n          var rate = this.fireRate;\n          rate += Phaser.Math.Between(-this.fireRateVariance, this.fireRateVariance);\n\n          if (rate < 0) {\n            rate = 0;\n          }\n\n          next = this.scene.time.now + rate;\n        } else {\n          next = this.scene.time.now + this.fireRate;\n        } // Prepare for next shot\n\n\n        if (this.multiFire) {\n          if (!this._hasFired) {\n            //  We only add 1 to the 'shots' count for multiFire shots\n            this._hasFired = true;\n            this._tempNextFire = next;\n            this.shots++;\n          }\n        } else {\n          this._nextFire = next;\n          this.shots++;\n        } // Emit events\n\n\n        this.eventEmitter.emit('fire', bullet, this, speed);\n\n        if (this.fireLimit > 0 && this.shots === this.fireLimit) {\n          this.eventEmitter('firelimit', this, this.fireLimit);\n        }\n      }\n\n      return bullet;\n    }\n    /**\n     * Set the fireFrom rectangle based on passed coords\n     * @private\n     * @param {number} x - X coordinate for where to fire from\n     * @param {number} y - Y coordinate for where to fire from\n     * @return {void}\n     */\n\n  }, {\n    key: \"updateFireFrom\",\n    value: function updateFireFrom(x, y) {\n      if (this.fireFrom.width > 1) {\n        // If size is larger than 1, center on coordinates\n        Phaser.Geom.Rectangle.CenterOn(this.fireFrom, x + this.trackOffset.x, y + this.trackOffset.y);\n      } else {\n        this.fireFrom.x = x + this.trackOffset.x;\n        this.fireFrom.y = y + this.trackOffset.y;\n      }\n    }\n    /**\n     * You can modify the size of the physics Body the Bullets use to be any dimension you need.\n     * This allows you to make it smaller, or larger, than the parent Sprite.\n     * You can also control the x and y offset of the Body. This is the position of the\n     * Body relative to the top-left of the Sprite _texture_.\n     *\n     * For example: If you have a Sprite with a texture that is 80x100 in size,\n     * and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:\n     *\n     * `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`\n     *\n     * Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.\n     * 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34\n     * is the vertical offset.\n     *\n     * @param {number} width - The width of the Body.\n     * @param {number} height - The height of the Body.\n     * @param {number} [offsetX=0] - The X offset of the Body from the top-left of the Sprites texture.\n     * @param {number} [offsetY=0] - The Y offset of the Body from the top-left of the Sprites texture.\n     * @return {Weapon} The Weapon Plugin.\n     */\n\n  }, {\n    key: \"setBulletBodyOffset\",\n    value: function setBulletBodyOffset(width, height) {\n      var offsetX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var offsetY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this._data.customBody = true;\n      this._data.width = width;\n      this._data.height = height;\n      this._data.offsetX = offsetX;\n      this._data.offsetY = offsetY; //  Update all bullets in the pool\n\n      this.bullets.children.each(function (child) {\n        child.body.setSize(width, height);\n        child.body.setOffset(offsetX, offsetY);\n        child.setData('bodyDirty', false);\n      });\n      return this;\n    }\n    /**\n     * Sets the texture frames that the bullets can use when being launched.\n     *\n     * This is intended for use when you've got numeric based frames, such as\n     * those loaded via a Sprite Sheet.\n     *\n     * It works by calling `Phaser.Utils.Array.NumberArray` internally, using\n     * the min and max values provided. Then it sets the frame index to be zero.\n     *\n     * You can optionally set the cycle and random booleans, to allow bullets to\n     * cycle through the frames when they're fired, or pick one at random.\n     *\n     * @param {integer} min - The minimum value the frame can be. Usually zero.\n     * @param {integer} max - The maximum value the frame can be.\n     * @param {integer} [selcetionMethod=BULLET_FRAME_STABLE] - Specifies how the\n     *  frame for the fired bullet will be selected. See consts.BULLET_FRAME_XYZ\n     *  for options.\n     * @return {Weapon} The Weapon Plugin.\n     */\n\n  }, {\n    key: \"setBulletFrames\",\n    value: function setBulletFrames(min, max) {\n      var selectionMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].BULLET_FRAME_STABLE;\n\n      if (typeof selectionMethod !== 'number' || selectionMethod < __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].BULLET_FRAME_STABLE || selectionMethod > __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].BULLET_FRAME_RANDOM) {\n        Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"b\" /* log */])(\"Invalid bullet frame selection method specified: \".concat(selectionMethod), this.logLevel);\n      }\n\n      if (min > max) {\n        Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"b\" /* log */])(\"min frame (\".concat(min, \") must be <= max frame (\").concat(max, \")\"), this.logLevel);\n      }\n\n      this.bulletFrames = Phaser.Utils.Array.NumberArray(min, max);\n      this.bulletFrameIndex = 0;\n      this.bulletFrameCycle = selectionMethod === __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].BULLET_FRAME_CYCLE;\n      this.bulletFrameRandom = selectionMethod === __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].BULLET_FRAME_RANDOM;\n      return this;\n    }\n    /**\n     * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n     * The arguments are all the same as for `Animation.add`, and work in the same way.\n     *\n     * {@link #bulletAnimation} will be set to this animation after it's created. From that point on, all\n     * bullets fired will play using this animation. You can swap between animations by calling this method\n     * several times, and then just changing the {@link #bulletAnimation} property to the name of the animation\n     * you wish to play for the next launched bullet.\n     *\n     * If you wish to stop using animations at all, set {@link #bulletAnimation} to '' (an empty string).\n     *\n     * @param {string} name - The unique (within the Weapon instance) name for the animation, i.e. \"fire\", \"blast\".\n     * @param {Array} [frames=null] - An array of numbers/strings that correspond to the framesto add to this animation\n     * and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n     * @param {number} [frameRate=60] - The speed at which the animation should play.\n     * The speed is given in frames per second.\n     * @param {number} [loop=1] - Number of times to repeat the animation. Set to -1 to repeat forever.\n     * @return {Weapon} The Weapon Plugin.\n     */\n\n  }, {\n    key: \"addBulletAnimation\",\n    value: function addBulletAnimation(name, frames, frameRate, loop) {\n      if (!this.scene.sys.anims.anims.contains(name)) {\n        this.scene.sys.anims.create({\n          key: name,\n          frames: frames,\n          frameRate: frameRate,\n          loop: loop\n        });\n        this.anims[name] = this.scene.sys.anims.anims.entries[name];\n      }\n\n      this.bulletAnimation = name;\n      return this;\n    }\n    /**\n     * Internal update method, called by the Weapon Plugin.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this._bulletKillType === __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_WEAPON_BOUNDS) {\n        if (this.trackedSprite) {\n          this.trackedSprite.updateTransform();\n          Phaser.Geom.Rectangle.CenterOn(this.bounds, this.trackedSprite.x, this.trackedSprite.y);\n        } else if (this.trackedPointer) {\n          Phaser.Geom.Rectangle.CenterOn(this.bounds, this.trackedPointer.x, this.trackedPointer.y);\n        }\n      }\n\n      if (this.autofire) {\n        this.fire();\n      }\n    }\n    /**\n     * Internal update method, called by the Weapon Plugin.\n     *\n     * @protected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"postRender\",\n    value: function postRender() {\n      if (!this.multiFire || !this._hasFired) {\n        return;\n      }\n\n      this._hasFired = false;\n      this._nextFire = this._tempNextFire;\n    }\n    /**\n     * Destroys this Weapon.\n     * You must release everything in here, all references, all objects, free it all up.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.scene = null;\n      this.bullets.destroy(true);\n    }\n  }, {\n    key: \"bullets\",\n    get: function get() {\n      return this._bullets;\n    },\n    set: function set(value) {\n      this._bullets = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bullets');\n    }\n    /**\n     * Should the bullet pool run out of bullets (i.e. they are all in flight) then this\n     * boolean controls if the Group will create a brand new bullet object or not.\n     * @type {boolean}\n     * @default\n     */\n\n  }, {\n    key: \"autoExpandBulletsGroup\",\n    get: function get() {\n      return this._autoExpandBulletsGroup;\n    },\n    set: function set(value) {\n      this._autoExpandBulletsGroup = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'autoExpandBulletsGroup');\n    }\n    /**\n     * Will this weapon auto fire? If set to true then a new bullet will be fired\n     * based on the {@link #fireRate} value.\n     * @type {boolean}\n     * @default\n     */\n\n  }, {\n    key: \"autofire\",\n    get: function get() {\n      return this._autofire;\n    },\n    set: function set(value) {\n      this._autofire = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'autofire');\n    }\n    /**\n    * The total number of bullets this Weapon has fired so far.\n    * You can limit the number of shots allowed (via {@link #fireLimit}), and reset\n    * this total via {@link #resetShots}.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"shots\",\n    get: function get() {\n      return this._shots;\n    },\n    set: function set(value) {\n      this._shots = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'shots');\n    }\n    /**\n    * The maximum number of shots that this Weapon is allowed to fire before it stops.\n    * When the limit is hit the {@link #onFireLimit} event is dispatched.\n    * You can reset the shot counter via {@link #resetShots}.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"fireLimit\",\n    get: function get() {\n      return this._fireLimit;\n    },\n    set: function set(value) {\n      this._fireLimit = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'fireLimit');\n    }\n    /**\n    * The minimum interval between shots, in milliseconds.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"fireRate\",\n    get: function get() {\n      return this._fireRate;\n    },\n    set: function set(value) {\n      this._fireRate = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'fireRate');\n    }\n    /**\n    * This is a modifier that is added to the {@link #fireRate} each update to add variety\n    * to the firing rate of the Weapon. The value is given in milliseconds.\n    * If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual\n    * firing rate of the Weapon will be between 150 and 250.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"fireRateVariance\",\n    get: function get() {\n      return this._fireRateVariance;\n    },\n    set: function set(value) {\n      this._fireRateVariance = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'fireRateVariance');\n    }\n    /**\n    * This is a Rectangle from within which the bullets are fired. By default it's a 1x1\n    * rectangle, the equivalent of a Point. But you can change the width and height, and if\n    * larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.\n    * @type {Phaser.Geom.Rectangle}\n    */\n\n  }, {\n    key: \"fireFrom\",\n    get: function get() {\n      return this._fireFrom;\n    },\n    set: function set(value) {\n      this._fireFrom = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'fireFrom');\n    }\n    /**\n    * The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP\n    * or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.\n    * @type {integer}\n    * @default\n    */\n\n  }, {\n    key: \"fireAngle\",\n    get: function get() {\n      return this._fireAngle;\n    },\n    set: function set(value) {\n      this._fireAngle = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'fireAngle');\n    }\n    /**\n    * When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.\n    * @type {boolean}\n    * @default\n    */\n\n  }, {\n    key: \"bulletInheritSpriteSpeed\",\n    get: function get() {\n      return this._bulletInheritSpriteSpeed;\n    },\n    set: function set(value) {\n      this._bulletInheritSpriteSpeed = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletInheritSpriteSpeed');\n    }\n    /**\n    * The string based name of the animation that the Bullet will be given on launch.\n    * This is set via {@link #addBulletAnimation}.\n    * @type {string}\n    * @default\n    */\n\n  }, {\n    key: \"bulletAnimation\",\n    get: function get() {\n      return this._bulletAnimation;\n    },\n    set: function set(value) {\n      this._bulletAnimation = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletAnimation');\n    }\n    /**\n    * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n    * chose for each Bullet fired to pick a random frame from the set.\n    * @type {boolean}\n    * @default\n    */\n\n  }, {\n    key: \"bulletFrameRandom\",\n    get: function get() {\n      return this._bulletFrameRandom;\n    },\n    set: function set(value) {\n      this._bulletFrameRandom = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletFrameRandom');\n    }\n    /**\n    * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n    * chose for each Bullet fired to use the next frame in the set. The frame index is then\n    * advanced one frame until it reaches the end of the set, then it starts from the start\n    * again. Cycling frames like this allows you to create varied bullet effects via\n    * sprite sheets.\n    * @type {boolean}\n    * @default\n    */\n\n  }, {\n    key: \"bulletFrameCycle\",\n    get: function get() {\n      return this._bulletFrameCycle;\n    },\n    set: function set(value) {\n      this._bulletFrameCycle = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletFrameCycle');\n    }\n    /**\n     * Should the Bullets wrap around the world bounds? This automatically calls\n     * `World.wrap` on the Bullet each frame. See the docs for that method for details.\n     * @type {boolean}\n     * @default\n     */\n\n  }, {\n    key: \"bulletWorldWrap\",\n    get: function get() {\n      return this._bulletWorldWrap;\n    },\n    set: function set(value) {\n      this._bulletWorldWrap = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletWorldWrap');\n    }\n    /**\n    * If `bulletWorldWrap` is true then you can provide an optional padding value with this\n    * property. It's added to the calculations determining when the Bullet should wrap around\n    * the world or not. The value is given in pixels.\n    * @type {integer}\n    * @default\n    */\n\n  }, {\n    key: \"bulletWorldWrapPadding\",\n    get: function get() {\n      return this._bulletWorldWrapPadding;\n    },\n    set: function set(value) {\n      this._bulletWorldWrapPadding = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletWorldWrapPadding');\n    }\n    /**\n    * An optional angle offset applied to the Bullets when they are launched.\n    * This is useful if for example your bullet sprites have been drawn facing up, instead of\n    * to the right, and you want to fire them at an angle. In which case you can set the\n    * angle offset to be 90 and they'll be properly rotated when fired.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"bulletAngleOffset\",\n    get: function get() {\n      return this._bulletAngleOffset;\n    },\n    set: function set(value) {\n      this._bulletAngleOffset = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletAngleOffset');\n    }\n    /**\n    * This is a variance added to the angle of Bullets when they are fired.\n    * If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual\n    * angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a\n    * great 'spread' effect to a Weapon.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"bulletAngleVariance\",\n    get: function get() {\n      return this._bulletAngleVariance;\n    },\n    set: function set(value) {\n      this._bulletAngleVariance = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletAngleVariance');\n    }\n    /**\n    * The initial velocity of fired bullets, in pixels per second.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"bulletSpeed\",\n    get: function get() {\n      return this._bulletSpeed;\n    },\n    set: function set(value) {\n      this._bulletSpeed = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletSpeed');\n    }\n    /**\n    * This is a variance added to the speed of Bullets when they are fired.\n    * If bullets have a {@link #bulletSpeed} value of 200, and a `bulletSpeedVariance` of 50\n    * then the actual speed of the Bullets will be between 150 and 250 pixels per second.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"bulletSpeedVariance\",\n    get: function get() {\n      return this._bulletSpeedVariance;\n    },\n    set: function set(value) {\n      this._bulletSpeedVariance = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletSpeedVariance');\n    }\n    /**\n    * If you've set {@link #bulletKillType} to `consts.KILL_LIFESPAN` this controls the amount\n    * of lifespan the Bullets have set on launch. The value is given in milliseconds.\n    * When a Bullet hits its lifespan limit it will be automatically killed.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"bulletLifespan\",\n    get: function get() {\n      return this._bulletLifespan;\n    },\n    set: function set(value) {\n      this._bulletLifespan = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletLifespan');\n    }\n    /**\n    * If you've set {@link #bulletKillType} to `consts.KILL_DISTANCE` this controls the distance\n    * the Bullet can travel before it is automatically killed. The distance is given in pixels.\n    * @type {number}\n    * @default\n    */\n\n  }, {\n    key: \"bulletKillDistance\",\n    get: function get() {\n      return this._bulletKillDistance;\n    },\n    set: function set(value) {\n      this._bulletKillDistance = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletKillDistance');\n    }\n    /**\n    * This is the amount of {@link Phaser.Physics.Arcade.Body#gravity} added to the Bullets physics body when fired.\n    * Gravity is expressed in pixels / second / second.\n    * @type {Phaser.Math.Vector2}\n    */\n\n  }, {\n    key: \"bulletGravity\",\n    get: function get() {\n      return this._bulletGravity;\n    },\n    set: function set(value) {\n      this._bulletGravity = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletGravity');\n    }\n    /**\n    * Bullets can optionally adjust their rotation in-flight to match their velocity.\n    * This can create the effect of a bullet 'pointing' to the path it is following, for example\n    * an arrow being fired from a bow, and works especially well when added to {@link #bulletGravity}.\n    * @type {boolean}\n    * @default\n    */\n\n  }, {\n    key: \"bulletRotateToVelocity\",\n    get: function get() {\n      return this._bulletRotateToVelocity;\n    },\n    set: function set(value) {\n      this._bulletRotateToVelocity = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletRotateToVelocity');\n    }\n    /**\n    * The Texture Key that the Bullets use when rendering.\n    * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n    * @type {string}\n    * @default\n    */\n\n  }, {\n    key: \"bulletKey\",\n    get: function get() {\n      return this._bulletKey;\n    },\n    set: function set(value) {\n      this._bulletKey = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletKey');\n    }\n    /**\n    * The Texture Frame that the Bullets use when rendering.\n    * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n    * @type {string|integer}\n    * @default\n    */\n\n  }, {\n    key: \"bulletFrame\",\n    get: function get() {\n      return this._bulletFrame;\n    },\n    set: function set(value) {\n      this._bulletFrame = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletFrame');\n    }\n    /**\n     * The Class of the bullets that are launched by this Weapon. Defaults to {@link Phaser.Bullet}, but can be\n     * overridden before calling `createBullets` and set to your own class type.\n     *\n     * It should be a constructor function accepting `(game, x, y, key, frame)`.\n     *\n     * @property {function} bulletClass\n    */\n\n  }, {\n    key: \"bulletClass\",\n    get: function get() {\n      return this._bulletClass;\n    },\n    set: function set(classType) {\n      this._bulletClass = classType; // `this.bullets` exists only after createBullets()\n\n      if (this.bullets) {\n        this.bullets.classType = this._bulletClass;\n      }\n\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletClass');\n    }\n    /**\n    * Should bullets collide with the World bounds or not?\n    *\n    * @property {boolean} bulletCollideWorldBounds\n    */\n\n  }, {\n    key: \"bulletCollideWorldBounds\",\n    get: function get() {\n      return this._bulletCollideWorldBounds;\n    },\n    set: function set(value) {\n      this._bulletCollideWorldBounds = value;\n      this.bullets.children.each(function (child) {\n        child.body.collideWorldBounds = value;\n        child.setData('bodyDirty', false);\n      });\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletCollideWorldBounds');\n    }\n    /**\n    * This controls how the bullets will be killed. The default is `consts.KILL_WORLD_BOUNDS`.\n    *\n    * There are 7 different \"kill types\" available:\n    *\n    * * `consts.KILL_NEVER`\n    * The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.\n    *\n    * * `consts.KILL_LIFESPAN`\n    * The bullets are automatically killed when their `bulletLifespan` amount expires.\n    *\n    * * `consts.KILL_DISTANCE`\n    * The bullets are automatically killed when they\n    * exceed `bulletDistance` pixels away from their original launch position.\n    *\n    * * `consts.KILL_WEAPON_BOUNDS`\n    * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n    *\n    * * `consts.KILL_CAMERA_BOUNDS`\n    * The bullets are automatically killed when they no longer intersect with the {@link Phaser.Camera#bounds} rectangle.\n    *\n    * * `consts.KILL_WORLD_BOUNDS`\n    * The bullets are automatically killed when they no longer intersect with the {@link Phaser.World#bounds} rectangle.\n    *\n    * * `consts.KILL_STATIC_BOUNDS`\n    * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n    * The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to\n    * match the position of a tracked sprite or pointer.\n    *\n    * @property {integer} bulletKillType\n    */\n\n  }, {\n    key: \"bulletKillType\",\n    get: function get() {\n      return this._bulletKillType;\n    },\n    set: function set(type) {\n      switch (type) {\n        case __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_STATIC_BOUNDS:\n        case __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_WEAPON_BOUNDS:\n          this.bulletBounds = this.bounds;\n          break;\n\n        case __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_CAMERA_BOUNDS:\n          this.bulletBounds = this.scene.sys.cameras.main._bounds;\n          break;\n\n        case __WEBPACK_IMPORTED_MODULE_1__consts__[\"a\" /* default */].KILL_WORLD_BOUNDS:\n          this.bulletBounds = this.scene.physics.world.bounds;\n          break;\n      }\n\n      this._bulletKillType = type;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletKillType');\n    }\n    /**\n    * This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.\n    * It's used in combination with {@link #bulletKillType} when that is set to either `consts.KILL_WEAPON_BOUNDS`\n    * or `consts.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.\n    * If you are tracking a Sprite or Point then the bounds are centered on that object every frame.\n    *\n    * @type {Phaser.Geom.Rectangle}\n    */\n\n  }, {\n    key: \"bounds\",\n    get: function get() {\n      return this._bounds;\n    },\n    set: function set(value) {\n      this._bounds = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bounds');\n    }\n    /**\n    * The Rectangle used to calculate the bullet bounds from.\n    *\n    * @type {Phaser.Geom.Rectangle}\n    * @private\n    */\n\n  }, {\n    key: \"bulletBounds\",\n    get: function get() {\n      return this._bulletBounds;\n    },\n    set: function set(value) {\n      this._bulletBounds = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletBounds');\n    }\n    /**\n    * This array stores the frames added via @link #setBulletFrames.\n    *\n    * @type {Array}\n    * @protected\n    */\n\n  }, {\n    key: \"bulletFrames\",\n    get: function get() {\n      return this._bulletFrames;\n    },\n    set: function set(value) {\n      this._bulletFrames = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletFrames');\n    }\n    /**\n    * The index of the frame within {@link #bulletFrames} that is currently being used.\n    * This value is only used if {@link #bulletFrameCycle} is set to `true`.\n    * @type {number}\n    * @private\n    */\n\n  }, {\n    key: \"bulletFrameIndex\",\n    get: function get() {\n      return this._bulletFrameIndex;\n    },\n    set: function set(value) {\n      this._bulletFrameIndex = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'bulletFrameIndex');\n    }\n    /**\n    * The Sprite currently being tracked by the Weapon, if any.\n    * This is set via the {@link #trackSprite} method.\n    *\n    * @type {Phaser.GameObjects.Sprite|Object}\n    */\n\n  }, {\n    key: \"trackedSprite\",\n    get: function get() {\n      return this._trackedSprite;\n    },\n    set: function set(value) {\n      this._trackedSprite = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'trackedSprite');\n    }\n    /**\n    * The Pointer currently being tracked by the Weapon, if any.\n    * This is set via the {@link #trackPointer} method.\n    *\n    * @type {Phaser.Input.Pointer}\n    */\n\n  }, {\n    key: \"trackedPointer\",\n    get: function get() {\n      return this._trackedPointer;\n    },\n    set: function set(value) {\n      this._trackedPointer = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'trackedPointer');\n    }\n    /**\n    * If you want this Weapon to be able to fire more than 1 bullet in a single\n    * update, then set this property to `true`. When `true` the Weapon plugin won't\n    * set the shot / firing timers until the `postRender` phase of the game loop.\n    * This means you can call `fire` (and similar methods) as often as you like in one\n    * single game update.\n    *\n    * @type {boolean}\n    * @default\n    */\n\n  }, {\n    key: \"multiFire\",\n    get: function get() {\n      return this._multiFire;\n    },\n    set: function set(value) {\n      this._multiFire = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'multiFire');\n    }\n    /**\n    * If the Weapon is tracking a Sprite, should it also track the Sprites rotation?\n    * This is useful for a game such as Asteroids, where you want the weapon to fire based\n    * on the sprites rotation.\n    *\n    * @type {boolean}\n    * @default\n    */\n\n  }, {\n    key: \"trackRotation\",\n    get: function get() {\n      return this._trackRotation;\n    },\n    set: function set(value) {\n      this._trackRotation = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'trackRotation');\n    }\n    /**\n    * The Track Offset is a Vector2 object that allows you to specify a pixel offset that bullets use\n    * when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels\n    * in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have\n    * the bullet launched from the center of the Sprite.\n    *\n    * @type {Phaser.Math.Vector2}\n    */\n\n  }, {\n    key: \"trackOffset\",\n    get: function get() {\n      return this._trackOffset;\n    },\n    set: function set(value) {\n      this._trackOffset = value;\n      Object(__WEBPACK_IMPORTED_MODULE_2__validateConfig__[\"a\" /* default */])(this, 'trackOffset');\n    }\n    /**\n     * The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and\n     * can be overridden by the {@link #fire} arguments.\n     *\n     * @property {number} x\n    */\n\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this.fireFrom.x;\n    },\n    set: function set(value) {\n      this.fireFrom.x = value;\n    }\n    /**\n     * The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and\n     * can be overridden by the {@link #fire} arguments.\n     *\n     * @property {number} y\n    */\n\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this.fireFrom.y;\n    },\n    set: function set(value) {\n      this.fireFrom.y = value;\n    }\n  }]);\n\n  return Weapon;\n}();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Weapon);\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return log; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__consts__ = __webpack_require__(0);\n\n/**\n * Log text to the console or throw an error\n * @param {string} text - Text to be logged\n * @param {string} logLevel - The log level, either `warn`, `error' or `off`\n */\n\nfunction log(text, logLevel) {\n  if (logLevel === 'warn') {\n    console.warn(text);\n  } else if (logLevel === 'error') {\n    throw new Error(text);\n  }\n}\n/**\n * Check the config of the weapon for common errors and weird configurations.\n * @param {Weapon} weapon - The weapon being validated\n * @param {string} property - The property of the weapon being validated\n */\n\n\nfunction validateConfig(weapon, property) {\n  if (['bulletWorldWrap', 'bulletKillType'].includes(property) && weapon.bulletWorldWrap && (weapon.bulletKillType === __WEBPACK_IMPORTED_MODULE_0__consts__[\"a\" /* default */].KILL_WORLD_BOUNDS || weapon.bulletKillType === __WEBPACK_IMPORTED_MODULE_0__consts__[\"a\" /* default */].KILL_WEAPON_BOUNDS)) {\n    log('Warning: KILL_WORLD_BOUNDS and KILL_WEAPON_BOUNDS does not work well with bulletWorldWrap set to true.', weapon.logLevel);\n  }\n\n  if (['bulletKillType', 'bulletLifespan'].includes(property) && weapon.bulletKillType === __WEBPACK_IMPORTED_MODULE_0__consts__[\"a\" /* default */].KILL_LIFESPAN && weapon.bulletLifespan < 0) {\n    log('Invalid bulletLifespan; must be > 0; currently ' + weapon.bulletLifespan, weapon.logLevel);\n  }\n\n  if (['fireLimit', 'fireRate', 'fireRateVariance', 'bulletAngleVariance', 'bulletSpeedVariance', 'bulletKillDistance'].includes(property) && weapon[property] < 0) {\n    log('Invalid ' + property + '; must be >= 0; currently ' + weapon[property], weapon.logLevel);\n  }\n}\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (validateConfig);\n\n/***/ })\n/******/ ])[\"default\"];\n});\n\n\n// WEBPACK FOOTER //\n// WeaponPlugin.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a98f8ebfdf2be11a4972","export default {\n  /**\n   * A {@link #bulletKillType} constant that stops the bullets from ever being destroyed automatically.\n   * @constant\n   * @type {integer}\n   */\n  KILL_NEVER: 0,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when their {@link #bulletLifespan} expires.\n   * @constant\n   * @type {integer}\n   */\n  KILL_LIFESPAN: 1,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets after they\n   * exceed the {@link #bulletDistance} from their original firing position.\n   * @constant\n   * @type {integer}\n   */\n  KILL_DISTANCE: 2,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WEAPON_BOUNDS: 3,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link Phaser.Camera#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_CAMERA_BOUNDS: 4,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link Phaser.World#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WORLD_BOUNDS: 5,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_STATIC_BOUNDS: 6,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face up.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_UP: 270,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face down.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_DOWN: 90,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face left.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_LEFT: 180,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face right.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_RIGHT: 0,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\n   * @constant Phaser.ANGLE_NORTH_EAST\n   * @type {integer}\n   */\n  ANGLE_NORTH_EAST: 315,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_NORTH_WEST: 225,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_EAST: 45,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_WEST: 135,\n\n  /**\n   * When selecting a bullet frame the same frame should always be used. This\n   * is the default value.\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_STABLE: 0,\n\n  /**\n   * When selecting a bullet frame the next frame should be used\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_CYCLE: 1,\n\n  /**\n   * When selecting a bullet frame a random frame should be used.\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_RANDOM: 2,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./consts.js","import consts from './consts';\n\nlet bulletID = 0;\n\nclass Bullet extends Phaser.GameObjects.Sprite {\n  /**\n   * Create a new `Bullet` object. Bullets are used by the `Weapon` class, and are normal Sprites,\n   * with a few extra properties in the data manager to handle Weapon specific features.\n   *\n   * @param {Phaser.Scene} scene - A reference to the currently running scene.\n   * @param {number} x - The x coordinate (in world space) to position the Particle at.\n   * @param {number} y - The y coordinate (in world space) to position the Particle at.\n   * @param {string} key - This is the image or texture used by the Particle during rendering.\n   * It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas\n   * you can specify the exact frame to use by giving a string or numeric index.\n   */\n  constructor(scene, x, y, key, frame) {\n    super(scene, x, y, key, frame);\n    this.bulletID = bulletID;\n    bulletID++;\n    this.scene.physics.add.existing(this);\n\n    this.setDataEnabled();\n\n    this.setData({\n      timeEvent: null,\n      bulletManager: null,\n      fromX: 0,\n      fromY: 0,\n      bodyDirty: true,\n      rotateToVelocity: false,\n      killType: 0,\n      killDistance: 0,\n      bodyBounds: new Phaser.Geom.Rectangle(),\n    });\n  }\n\n  /**\n   * Prepares this bullet to be fired and interact with the rest of the scene\n   * again.\n   * @returns {void}\n   */\n  prepare(x, y) {\n    this.setActive(true);\n    this.setVisible(true);\n    this.body.enable = true;\n    this.body.reset(x, y);\n    this.body.debugShowBody = this.getData('bulletManager').debugPhysics;\n    this.body.debugShowVelocity = this.getData('bulletManager').debugPhysics;\n  }\n\n  /**\n   * Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.\n   * Also dispatches the `Weapon`s kill signal.\n   * @returns {Bullet} This instance of the bullet class\n   */\n  kill() {\n    // Reproduce Phaser.Physics.Arcade.Components.Enable.disableBody because\n    // we can't assume that the bullet class has it built in.\n    this.body.stop();\n    this.body.enable = false;\n    this.setActive(false);\n    this.setVisible(false);\n    this.body.debugShowBody = false;\n    this.body.debugShowVelocity = false;\n\n    // TODO: potentially we don't need to destroy the time event and we can\n    // just pause when the bullet is killed and restart it when it's refired.\n    // For now though do the simple thing and discard it.\n    // Another option would be to use Date.now() and manually process pause\n    // events with a flag and some math.\n    // Both of those are probably premature optimizations.\n    if (this.getData('timeEvent') !== null) {\n      this.getData('timeEvent').destroy();\n      this.setData('timeEvent', null);\n    }\n\n    this.getData('bulletManager').eventEmitter.emit('kill', this);\n\n    return this;\n  }\n\n  /**\n   * Updates the Bullet, killing as required.\n   * @returns {Bullet} This instance of the bullet class\n   */\n  update() {\n    if (!this.active) {\n      // this was previously a check to this.exists\n      return;\n    }\n\n    if (this.getData('killType') > consts.KILL_LIFESPAN) {\n      if (this.getData('killType') === consts.KILL_DISTANCE) {\n        if (\n          new Phaser.Math.Vector2(this.getData('fromX'), this.getData('fromY')).distance(this) >\n          this.getData('killDistance')\n        ) {\n          this.kill();\n        }\n      } else if (\n        !Phaser.Geom.Intersects.RectangleToRectangle(\n          this.getData('bulletManager').bulletBounds,\n          this.body.getBounds(this.getData('bodyBounds'))\n        )\n      ) {\n        this.kill();\n      }\n    }\n\n    if (this.getData('rotateToVelocity')) {\n      this.rotation = this.body.velocity.atan();\n    }\n\n    if (this.getData('bulletManager').bulletWorldWrap) {\n      this.scene.physics.world.wrap(this, this.getData('bulletManager').bulletWorldWrapPadding);\n    }\n  }\n}\n\nexport default Bullet;\n\n\n\n// WEBPACK FOOTER //\n// ./Bullet.js","/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/16patsle/phaser3-weapon-plugin/blob/master/LICENSE|MIT License}\n */\nimport Weapon from './Weapon';\nimport Bullet from './Bullet';\nimport consts from './consts';\n\n/**\n * The Weapon Plugin provides the ability to easily create a bullet pool\n * and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, like iterate it, etc can be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.setPosition(300, 300);\n * this.input.on('pointerdown', weapon.fire, this);\n * ```\n */\nclass WeaponPlugin extends Phaser.Plugins.ScenePlugin {\n  /**\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the\n   *  Phaser.Plugins.PluginManager instance.\n   */\n  constructor(scene, pluginManager) {\n    super(scene, pluginManager);\n\n    this.weapons = [];\n\n    // Register our new Game Object type\n    pluginManager.registerGameObject('weapon', this.add.bind(this), config => {\n      return this.add(config.bulletLimit, config.key, config.frame, config.group, config.weaponClass);\n    });\n  }\n\n  add(bulletLimit, key, frame, group, weaponClass) {\n    if (!weaponClass) {\n      weaponClass = Weapon;\n    }\n    const weapon = new weaponClass(this.scene, bulletLimit, key, frame, group);\n\n    this.weapons.push(weapon);\n\n    return weapon;\n  }\n\n  /**\n   * Called by the PluginManager when this plugin is started.\n   * If a plugin is stopped, and then started again, this will get called again.\n   * Typically called immediately after `BasePlugin.init`.\n   *\n   * @returns {void}\n   */\n  start() {\n    this.systems.events.on('postrender', this.postRender, this);\n  }\n\n  /**\n   * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\n   * By this point the plugin properties `scene` and `systems` will have already been set.\n   * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n   * @returns {void}\n   */\n  boot() {\n    const eventEmitter = this.systems.events;\n\n    eventEmitter.on('update', this.update, this);\n    eventEmitter.on('destroy', this.destroy, this);\n  }\n\n  /**\n   * Internal update method, called by the PluginManager.\n   *\n   * @protected\n   * @returns {void}\n   */\n  update() {\n    this.weapons.forEach(weapon => {\n      weapon.update();\n    });\n  }\n\n  /**\n   * Internal update method, called by the PluginManager.\n   *\n   * @protected\n   * @returns {void}\n   */\n  postRender() {\n    this.weapons.forEach(weapon => {\n      weapon.postRender();\n    });\n  }\n\n  /**\n   * Destroys this Weapon.\n   * You must release everything in here, all references, all objects, free it all up.\n   * @returns {void}\n   */\n  destroy() {\n    this.pluginManager = null;\n    this.game = null;\n    this.scene = null;\n    this.systems = null;\n  }\n}\n\n// Set up shortcuts to the classes and constants\nWeaponPlugin.Weapon = Weapon;\nWeaponPlugin.Bullet = Bullet;\nWeaponPlugin.consts = consts;\n\n\nexport default WeaponPlugin;\n\n\n\n// WEBPACK FOOTER //\n// ./main.js","import Bullet from './Bullet';\nimport consts from './consts';\nimport validateConfig, { log } from './validateConfig';\n\n/**\n * The Weapon provides the ability to easily create a bullet pool and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, like iterate it, etc can be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.setPosition(300, 300);\n * this.input.on('pointerdown', weapon.fire, this);\n * ```\n */\nclass Weapon {\n  /**\n   * TODO: a builder style interface would be neat. Can be kicked way forward\n   * into polishing.\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {number} bulletLimit - The number of bullets to create.\n   * @param {String} key - The texture key for the bullet.\n   * @param {String} frame - The frame name for the bullet.\n   * @param {Phaser.GameObjects.Group} group - A group to add the bullets to.\n   */\n  constructor(scene, bulletLimit, key, frame, group) {\n    this.scene = scene;\n\n    this.debugPhysics = null;\n\n    /**\n     * Private var that holds the public `bullets` property.\n     * @type {Phaser.GameObjects.Group}\n     * @private\n     */\n    this._bullets = null;\n\n    /**\n     * Private var that holds the public `autoExpandBulletsGroup` property.\n     * @type {boolean}\n     * @private\n     */\n    this._autoExpandBulletsGroup = false;\n\n    /**\n     * Private var that holds the public `autofire` property.\n     * @type {boolean}\n     * @private\n     */\n    this._autofire = false;\n\n    /**\n     * Private var that holds the public `shots` property.\n     * @type {number}\n     * @private\n     */\n    this._shots = 0;\n\n    /**\n     * Private var that holds the public `fireLimit` property.\n     * @type {number}\n     * @private\n     */\n    this._fireLimit = 0;\n\n    /**\n     * Private var that holds the public `fireRate` property.\n     * @type {number}\n     * @private\n     */\n    this._fireRate = 100;\n\n    /**\n     * Private var that holds the public `fireRateVariance` property.\n     * @type {number}\n     * @private\n     */\n    this._fireRateVariance = 0;\n\n    /**\n     * Private var that holds the public `fireFrom` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this._fireFrom = new Phaser.Geom.Rectangle(0, 0, 1, 1);\n\n    /**\n     * Private var that holds the public `fireAngle` property.\n     * @type {integer}\n     * @private\n     */\n    this._fireAngle = consts.ANGLE_UP;\n\n    /**\n     * Private var that holds the public `bulletInheritSpriteSpeed` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletInheritSpriteSpeed = false;\n\n    /**\n     * Private var that holds the public `bulletAnimation` property.\n     * @type {string}\n     * @private\n     */\n    this._bulletAnimation = '';\n\n    /**\n     * Private var that holds the public `bulletFrameRandom` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletFrameRandom = false;\n\n    /**\n     * Private var that holds the public `bulletFrameCycle` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletFrameCycle = false;\n\n    /**\n     * Private var that holds the public `bulletWorldWrap` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletWorldWrap = false;\n\n    /**\n     * Private var that holds the public `bulletWorldWrapPadding` property.\n     * @type {integer}\n     * @private\n     */\n    this._bulletWorldWrapPadding = 0;\n\n    /**\n     * Private var that holds the public `bulletAngleOffset` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletAngleOffset = 0;\n\n    /**\n     * Private var that holds the public `bulletAngleVariance` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletAngleVariance = 0;\n\n    /**\n     * Private var that holds the public `bulletSpeed` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletSpeed = 200;\n\n    /**\n     * Private var that holds the public `bulletSpeedVariance` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletSpeedVariance = 0;\n\n    /**\n     * Private var that holds the public `bulletLifespan` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletLifespan = 0;\n\n    /**\n     * Private var that holds the public `bulletKillDistance` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletKillDistance = 0;\n\n    /**\n     * Private var that holds the public `bulletGravity` property.\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._bulletGravity = new Phaser.Math.Vector2(0, 0);\n\n    /**\n     * Private var that holds the public `bulletRotateToVelocity` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletRotateToVelocity = false;\n\n    /**\n     * Private var that holds the public `bulletKey` property.\n     * @type {string}\n     * @private\n     */\n    this._bulletKey = key || '';\n\n    /**\n     * Private var that holds the public `bulletFrame` property.\n     * @type {string|integer}\n     * @private\n     */\n    this._bulletFrame = frame || '';\n\n    /**\n     * Private var that holds the public `bulletClass` property.\n     * @type {function}\n     * @private\n     */\n    this._bulletClass = Bullet;\n\n    /**\n     * Private var that holds the public `bulletCollideWorldBounds` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletCollideWorldBounds = false;\n\n    /**\n     * Private var that holds the public `bulletKillType` property.\n     * @type {integer}\n     * @private\n     */\n    this._bulletKillType = consts.KILL_WORLD_BOUNDS;\n\n    /**\n     * Holds internal data about custom bullet body sizes.\n     *\n     * @type {Object}\n     * @private\n     */\n    this._data = {\n      customBody: false,\n      width: 0,\n      height: 0,\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    /**\n     * Private var that holds the public `bounds` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this._bounds = new Phaser.Geom.Rectangle();\n\n    /**\n     * Private var that holds the public `bulletBounds` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this._bulletBounds = this.scene.physics.world.bounds;\n\n    /**\n     * This array stores the frames added via @link #setBulletFrames.\n     *\n     * @type {Array}\n     * @protected\n     */\n    this._bulletFrames = [];\n\n    /**\n     * Private var that holds the public `bulletFrameIndex` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletFrameIndex = 0;\n\n    /**\n     * An internal object that stores the animation data added via {@link #addBulletAnimation}.\n     * @type {Object}\n     * @private\n     */\n    this.anims = {};\n\n    /**\n     * Private var that holds the public `trackedSprite` property.\n     * @type {Phaser.GameObjects.Sprite|Object}\n     * @private\n     */\n    this._trackedSprite = null;\n\n    /**\n     * Private var that holds the public `trackedPointer` property.\n     * @type {Phaser.Input.Pointer}\n     * @private\n     */\n    this._trackedPointer = null;\n\n    /**\n     * Private var that holds the public `multiFire` property.\n     * @type {boolean}\n     * @private\n     */\n    this._multiFire = false;\n\n    /**\n     * Internal multiFire test flag.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._hasFired = false;\n\n    /**\n     * Private var that holds the public `trackRotation` property.\n     * @type {boolean}\n     * @private\n     */\n    this._trackRotation = false;\n\n    /**\n     * Private var that holds the public `trackOffset` property.\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._trackOffset = new Phaser.Math.Vector2();\n\n    /**\n     * Internal firing rate time tracking variable.\n     *\n     * @type {number}\n     * @private\n     */\n    this._nextFire = 0;\n\n    /**\n     * Internal firing rate time tracking variable used by multiFire.\n     *\n     * @type {number}\n     * @private\n     */\n    this._tempNextFire = 0;\n\n    /**\n     * Internal firing rotation tracking point.\n     *\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._rotatedPoint = new Phaser.Math.Vector2();\n\n    /**\n     * Log level for this weapon. Either `warn`, `error' or `off`. `warn` is the default.\n     * If you change this, please do so before setting any other properties.\n     * \n     * @type {string}\n     */\n    this.logLevel = 'warn';\n\n    this.eventEmitter = new Phaser.Events.EventEmitter();\n\n    validateConfig(this);\n\n    this.createBullets(bulletLimit, key, frame, group);\n  }\n\n  /**\n   * This is the Phaser.Group that contains all of the bullets managed by this plugin.\n   * @type {Phaser.GameObjects.Group}\n   */\n  get bullets(){\n    return this._bullets;\n  }\n  set bullets(value){\n    this._bullets = value;\n\n    validateConfig(this, 'bullets');\n  }\n\n  /**\n   * Should the bullet pool run out of bullets (i.e. they are all in flight) then this\n   * boolean controls if the Group will create a brand new bullet object or not.\n   * @type {boolean}\n   * @default\n   */\n  get autoExpandBulletsGroup(){\n    return this._autoExpandBulletsGroup;\n  }\n  set autoExpandBulletsGroup(value) {\n    this._autoExpandBulletsGroup = value;\n\n    validateConfig(this, 'autoExpandBulletsGroup');\n  }\n\n  /**\n   * Will this weapon auto fire? If set to true then a new bullet will be fired\n   * based on the {@link #fireRate} value.\n   * @type {boolean}\n   * @default\n   */\n  get autofire() {\n    return this._autofire;\n  }\n  set autofire(value) {\n    this._autofire = value;\n\n    validateConfig(this, 'autofire');\n  }\n\n  /**\n * The total number of bullets this Weapon has fired so far.\n * You can limit the number of shots allowed (via {@link #fireLimit}), and reset\n * this total via {@link #resetShots}.\n * @type {number}\n * @default\n */\n  get shots() {\n    return this._shots;\n  }\n  set shots(value) {\n    this._shots = value;\n\n    validateConfig(this, 'shots');\n  }\n\n  /**\n * The maximum number of shots that this Weapon is allowed to fire before it stops.\n * When the limit is hit the {@link #onFireLimit} event is dispatched.\n * You can reset the shot counter via {@link #resetShots}.\n * @type {number}\n * @default\n */\n  get fireLimit(){\n    return this._fireLimit;\n  }\n  set fireLimit(value){\n    this._fireLimit = value;\n\n    validateConfig(this, 'fireLimit');\n  }\n\n  /**\n * The minimum interval between shots, in milliseconds.\n * @type {number}\n * @default\n */\n  get fireRate(){\n    return this._fireRate;\n  }\n  set fireRate(value){\n    this._fireRate = value;\n\n    validateConfig(this, 'fireRate');\n  }\n\n  /**\n * This is a modifier that is added to the {@link #fireRate} each update to add variety\n * to the firing rate of the Weapon. The value is given in milliseconds.\n * If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual\n * firing rate of the Weapon will be between 150 and 250.\n * @type {number}\n * @default\n */\n  get fireRateVariance(){\n    return this._fireRateVariance;\n  }\n  set fireRateVariance(value){\n    this._fireRateVariance = value;\n\n    validateConfig(this, 'fireRateVariance');\n  }\n\n  /**\n * This is a Rectangle from within which the bullets are fired. By default it's a 1x1\n * rectangle, the equivalent of a Point. But you can change the width and height, and if\n * larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.\n * @type {Phaser.Geom.Rectangle}\n */\n  get fireFrom(){\n    return this._fireFrom;\n  }\n  set fireFrom(value){\n    this._fireFrom = value;\n\n    validateConfig(this, 'fireFrom');\n  }\n\n  /**\n * The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP\n * or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.\n * @type {integer}\n * @default\n */\n  get fireAngle(){\n    return this._fireAngle;\n  }\n  set fireAngle(value){\n    this._fireAngle = value;\n\n    validateConfig(this, 'fireAngle');\n  }\n\n  /**\n * When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.\n * @type {boolean}\n * @default\n */\n  get bulletInheritSpriteSpeed(){\n    return this._bulletInheritSpriteSpeed;\n  }\n  set bulletInheritSpriteSpeed(value){\n    this._bulletInheritSpriteSpeed = value;\n\n    validateConfig(this, 'bulletInheritSpriteSpeed');\n  }\n\n  /**\n * The string based name of the animation that the Bullet will be given on launch.\n * This is set via {@link #addBulletAnimation}.\n * @type {string}\n * @default\n */\n  get bulletAnimation(){\n    return this._bulletAnimation;\n  }\n  set bulletAnimation(value){\n    this._bulletAnimation = value;\n\n    validateConfig(this, 'bulletAnimation');\n  }\n\n  /**\n * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n * chose for each Bullet fired to pick a random frame from the set.\n * @type {boolean}\n * @default\n */\n  get bulletFrameRandom(){\n    return this._bulletFrameRandom;\n  }\n  set bulletFrameRandom(value){\n    this._bulletFrameRandom = value;\n\n    validateConfig(this, 'bulletFrameRandom');\n  }\n\n  /**\n * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n * chose for each Bullet fired to use the next frame in the set. The frame index is then\n * advanced one frame until it reaches the end of the set, then it starts from the start\n * again. Cycling frames like this allows you to create varied bullet effects via\n * sprite sheets.\n * @type {boolean}\n * @default\n */\n  get bulletFrameCycle(){\n    return this._bulletFrameCycle;\n  }\n  set bulletFrameCycle(value){\n    this._bulletFrameCycle = value;\n\n    validateConfig(this, 'bulletFrameCycle');\n  }\n\n  /**\n   * Should the Bullets wrap around the world bounds? This automatically calls\n   * `World.wrap` on the Bullet each frame. See the docs for that method for details.\n   * @type {boolean}\n   * @default\n   */\n  get bulletWorldWrap(){\n    return this._bulletWorldWrap;\n  }\n  set bulletWorldWrap(value){\n    this._bulletWorldWrap = value;\n\n    validateConfig(this, 'bulletWorldWrap');\n  }\n\n  /**\n * If `bulletWorldWrap` is true then you can provide an optional padding value with this\n * property. It's added to the calculations determining when the Bullet should wrap around\n * the world or not. The value is given in pixels.\n * @type {integer}\n * @default\n */\n  get bulletWorldWrapPadding(){\n    return this._bulletWorldWrapPadding;\n  }\n  set bulletWorldWrapPadding(value){\n    this._bulletWorldWrapPadding = value;\n\n    validateConfig(this, 'bulletWorldWrapPadding');\n  }\n\n  /**\n * An optional angle offset applied to the Bullets when they are launched.\n * This is useful if for example your bullet sprites have been drawn facing up, instead of\n * to the right, and you want to fire them at an angle. In which case you can set the\n * angle offset to be 90 and they'll be properly rotated when fired.\n * @type {number}\n * @default\n */\n  get bulletAngleOffset(){\n    return this._bulletAngleOffset;\n  }\n  set bulletAngleOffset(value){\n    this._bulletAngleOffset = value;\n\n    validateConfig(this, 'bulletAngleOffset');\n  }\n\n  /**\n * This is a variance added to the angle of Bullets when they are fired.\n * If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual\n * angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a\n * great 'spread' effect to a Weapon.\n * @type {number}\n * @default\n */\n  get bulletAngleVariance(){\n    return this._bulletAngleVariance;\n  }\n  set bulletAngleVariance(value){\n    this._bulletAngleVariance = value;\n\n    validateConfig(this, 'bulletAngleVariance');\n  }\n\n  /**\n * The initial velocity of fired bullets, in pixels per second.\n * @type {number}\n * @default\n */\n  get bulletSpeed(){\n    return this._bulletSpeed;\n  }\n  set bulletSpeed(value){\n    this._bulletSpeed = value;\n\n    validateConfig(this, 'bulletSpeed');\n  }\n\n  /**\n * This is a variance added to the speed of Bullets when they are fired.\n * If bullets have a {@link #bulletSpeed} value of 200, and a `bulletSpeedVariance` of 50\n * then the actual speed of the Bullets will be between 150 and 250 pixels per second.\n * @type {number}\n * @default\n */\n  get bulletSpeedVariance(){\n    return this._bulletSpeedVariance;\n  }\n  set bulletSpeedVariance(value){\n    this._bulletSpeedVariance = value;\n\n    validateConfig(this, 'bulletSpeedVariance');\n  }\n\n  /**\n * If you've set {@link #bulletKillType} to `consts.KILL_LIFESPAN` this controls the amount\n * of lifespan the Bullets have set on launch. The value is given in milliseconds.\n * When a Bullet hits its lifespan limit it will be automatically killed.\n * @type {number}\n * @default\n */\n  get bulletLifespan(){\n    return this._bulletLifespan;\n  }\n  set bulletLifespan(value){\n    this._bulletLifespan = value;\n\n    validateConfig(this, 'bulletLifespan');\n  }\n\n  /**\n * If you've set {@link #bulletKillType} to `consts.KILL_DISTANCE` this controls the distance\n * the Bullet can travel before it is automatically killed. The distance is given in pixels.\n * @type {number}\n * @default\n */\n  get bulletKillDistance() {\n    return this._bulletKillDistance;\n  }\n  set bulletKillDistance(value) {\n    this._bulletKillDistance = value;\n\n    validateConfig(this, 'bulletKillDistance');\n  }\n\n  /**\n * This is the amount of {@link Phaser.Physics.Arcade.Body#gravity} added to the Bullets physics body when fired.\n * Gravity is expressed in pixels / second / second.\n * @type {Phaser.Math.Vector2}\n */\n  get bulletGravity() {\n    return this._bulletGravity;\n  }\n  set bulletGravity(value) {\n    this._bulletGravity = value;\n\n    validateConfig(this, 'bulletGravity');\n  }\n\n  /**\n * Bullets can optionally adjust their rotation in-flight to match their velocity.\n * This can create the effect of a bullet 'pointing' to the path it is following, for example\n * an arrow being fired from a bow, and works especially well when added to {@link #bulletGravity}.\n * @type {boolean}\n * @default\n */\n  get bulletRotateToVelocity() {\n    return this._bulletRotateToVelocity;\n  }\n  set bulletRotateToVelocity(value) {\n    this._bulletRotateToVelocity = value;\n\n    validateConfig(this, 'bulletRotateToVelocity');\n  }\n\n  /**\n * The Texture Key that the Bullets use when rendering.\n * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n * @type {string}\n * @default\n */\n  get bulletKey() {\n    return this._bulletKey;\n  }\n  set bulletKey(value) {\n    this._bulletKey = value;\n\n    validateConfig(this, 'bulletKey');\n  }\n\n  /**\n * The Texture Frame that the Bullets use when rendering.\n * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n * @type {string|integer}\n * @default\n */\n  get bulletFrame() {\n    return this._bulletFrame;\n  }\n  set bulletFrame(value) {\n    this._bulletFrame = value;\n\n    validateConfig(this, 'bulletFrame');\n  }\n\n  /**\n   * The Class of the bullets that are launched by this Weapon. Defaults to {@link Phaser.Bullet}, but can be\n   * overridden before calling `createBullets` and set to your own class type.\n   *\n   * It should be a constructor function accepting `(game, x, y, key, frame)`.\n   *\n   * @property {function} bulletClass\n  */\n  get bulletClass() {\n    return this._bulletClass;\n  }\n  set bulletClass(classType){\n    this._bulletClass = classType;\n\n    // `this.bullets` exists only after createBullets()\n    if (this.bullets) {\n      this.bullets.classType = this._bulletClass;\n    }\n\n    validateConfig(this, 'bulletClass');\n  }\n\n  /**\n * Should bullets collide with the World bounds or not?\n *\n * @property {boolean} bulletCollideWorldBounds\n*/\n  get bulletCollideWorldBounds(){\n    return this._bulletCollideWorldBounds;\n  }\n  set bulletCollideWorldBounds(value){\n    this._bulletCollideWorldBounds = value;\n\n    this.bullets.children.each(child => {\n      child.body.collideWorldBounds = value;\n      child.setData('bodyDirty', false);\n    });\n\n    validateConfig(this, 'bulletCollideWorldBounds');\n  }\n\n  /**\n * This controls how the bullets will be killed. The default is `consts.KILL_WORLD_BOUNDS`.\n *\n * There are 7 different \"kill types\" available:\n *\n * * `consts.KILL_NEVER`\n * The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.\n *\n * * `consts.KILL_LIFESPAN`\n * The bullets are automatically killed when their `bulletLifespan` amount expires.\n *\n * * `consts.KILL_DISTANCE`\n * The bullets are automatically killed when they\n * exceed `bulletDistance` pixels away from their original launch position.\n *\n * * `consts.KILL_WEAPON_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n *\n * * `consts.KILL_CAMERA_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.Camera#bounds} rectangle.\n *\n * * `consts.KILL_WORLD_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.World#bounds} rectangle.\n *\n * * `consts.KILL_STATIC_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n * The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to\n * match the position of a tracked sprite or pointer.\n *\n * @property {integer} bulletKillType\n*/\n  get bulletKillType(){\n    return this._bulletKillType;\n  }\n  set bulletKillType(type){\n    switch (type) {\n      case consts.KILL_STATIC_BOUNDS:\n      case consts.KILL_WEAPON_BOUNDS:\n        this.bulletBounds = this.bounds;\n        break;\n\n      case consts.KILL_CAMERA_BOUNDS:\n        this.bulletBounds = this.scene.sys.cameras.main._bounds;\n        break;\n\n      case consts.KILL_WORLD_BOUNDS:\n        this.bulletBounds = this.scene.physics.world.bounds;\n        break;\n    }\n\n    this._bulletKillType = type;\n\n    validateConfig(this, 'bulletKillType');\n  }\n\n  /**\n * This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.\n * It's used in combination with {@link #bulletKillType} when that is set to either `consts.KILL_WEAPON_BOUNDS`\n * or `consts.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.\n * If you are tracking a Sprite or Point then the bounds are centered on that object every frame.\n *\n * @type {Phaser.Geom.Rectangle}\n */\n  get bounds() {\n    return this._bounds;\n  }\n  set bounds(value) {\n    this._bounds = value;\n\n    validateConfig(this, 'bounds');\n  }\n\n  /**\n * The Rectangle used to calculate the bullet bounds from.\n *\n * @type {Phaser.Geom.Rectangle}\n * @private\n */\n  get bulletBounds() {\n    return this._bulletBounds;\n  }\n  set bulletBounds(value) {\n    this._bulletBounds = value;\n\n    validateConfig(this, 'bulletBounds');\n  }\n\n  /**\n * This array stores the frames added via @link #setBulletFrames.\n *\n * @type {Array}\n * @protected\n */\n  get bulletFrames() {\n    return this._bulletFrames;\n  }\n  set bulletFrames(value) {\n    this._bulletFrames = value;\n\n    validateConfig(this, 'bulletFrames');\n  }\n\n  /**\n * The index of the frame within {@link #bulletFrames} that is currently being used.\n * This value is only used if {@link #bulletFrameCycle} is set to `true`.\n * @type {number}\n * @private\n */\n  get bulletFrameIndex() {\n    return this._bulletFrameIndex;\n  }\n  set bulletFrameIndex(value) {\n    this._bulletFrameIndex = value;\n\n    validateConfig(this, 'bulletFrameIndex');\n  }\n\n  /**\n * The Sprite currently being tracked by the Weapon, if any.\n * This is set via the {@link #trackSprite} method.\n *\n * @type {Phaser.GameObjects.Sprite|Object}\n */\n  get trackedSprite() {\n    return this._trackedSprite;\n  }\n  set trackedSprite(value) {\n    this._trackedSprite = value;\n\n    validateConfig(this, 'trackedSprite');\n  }\n\n  /**\n * The Pointer currently being tracked by the Weapon, if any.\n * This is set via the {@link #trackPointer} method.\n *\n * @type {Phaser.Input.Pointer}\n */\n  get trackedPointer() {\n    return this._trackedPointer;\n  }\n  set trackedPointer(value) {\n    this._trackedPointer = value;\n\n    validateConfig(this, 'trackedPointer');\n  }\n\n  /**\n * If you want this Weapon to be able to fire more than 1 bullet in a single\n * update, then set this property to `true`. When `true` the Weapon plugin won't\n * set the shot / firing timers until the `postRender` phase of the game loop.\n * This means you can call `fire` (and similar methods) as often as you like in one\n * single game update.\n *\n * @type {boolean}\n * @default\n */\n  get multiFire() {\n    return this._multiFire;\n  }\n  set multiFire(value) {\n    this._multiFire = value;\n\n    validateConfig(this, 'multiFire');\n  }\n\n  /**\n * If the Weapon is tracking a Sprite, should it also track the Sprites rotation?\n * This is useful for a game such as Asteroids, where you want the weapon to fire based\n * on the sprites rotation.\n *\n * @type {boolean}\n * @default\n */\n  get trackRotation() {\n    return this._trackRotation;\n  }\n  set trackRotation(value) {\n    this._trackRotation = value;\n\n    validateConfig(this, 'trackRotation');\n  }\n\n  /**\n * The Track Offset is a Vector2 object that allows you to specify a pixel offset that bullets use\n * when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels\n * in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have\n * the bullet launched from the center of the Sprite.\n *\n * @type {Phaser.Math.Vector2}\n */\n  get trackOffset() {\n    return this._trackOffset;\n  }\n  set trackOffset(value) {\n    this._trackOffset = value;\n\n    validateConfig(this, 'trackOffset');\n  }\n\n  /**\n   * The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and\n   * can be overridden by the {@link #fire} arguments.\n   *\n   * @property {number} x\n  */\n  get x(){\n    return this.fireFrom.x;\n  }\n  set x(value){\n    this.fireFrom.x = value;\n  }\n\n  /**\n   * The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and\n   * can be overridden by the {@link #fire} arguments.\n   *\n   * @property {number} y\n  */\n  get y(){\n    return this.fireFrom.y;\n  }\n  set y(value){\n    this.fireFrom.y = value;\n  }\n\n  /**\n   * This method performs two actions: First it will check to see if the\n   * {@link #bullets} Group exists or not, and if not it creates it, adding its\n   * children to the `group` given as the 4th argument.\n   *\n   * Then it will seed the bullet pool with the `quantity` number of Bullets,\n   * using the texture key and frame provided (if any).\n   *\n   * If for example you set the quantity to be 10, then this Weapon will only\n   * ever be able to have 10 bullets in-flight simultaneously. If you try to\n   * fire an 11th bullet then nothing will happen until one, or more, of the\n   * in-flight bullets have been killed, freeing them up for use by the Weapon\n   * again.\n   *\n   * If you do not wish to have a limit set, then pass in -1 as the quantity.\n   * In this instance the Weapon will keep increasing the size of the bullet\n   * pool as needed. It will never reduce the size of the pool however, so be\n   * careful it doesn't grow too large.\n   *\n   * You can either set the texture key and frame here, or via the\n   * {@link #bulletKey} and {@link #bulletFrame} properties. You can also\n   * animate bullets, or set them to use random frames. All Bullets belonging\n   * to a single Weapon instance must share the same texture key however.\n   *\n   * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon\n   *  with. If -1 it will set the pool to automatically expand.\n   * @param {string} [key] - The Game.cache key of the image that this Sprite\n   *  will use.\n   * @param {integer|string} [frame] - If the Sprite image contains multiple\n   *  frames you can specify which one to use here.\n   * @param {Phaser.GameObjects.Group} [group] - Optional Group to add the\n   *  object to. If not specified it will be added to the World group.\n   * @return {Weapon} This Weapon instance.\n   */\n  createBullets(quantity = 1, key, frame, group, bulletClass) {\n    if (bulletClass) {\n      this._bulletClass = bulletClass;\n    }\n\n    if (this.bullets && !this.bullets.scene) {\n      this.bullets = null;\n    }\n\n    if (!this.bullets) {\n      this.bullets = this.scene.add.group({\n        classType: this._bulletClass,\n        maxSize: quantity,\n        runChildUpdate: true,\n      });\n    }\n\n    if (quantity !== 0) {\n      if (quantity === -1) {\n        this.autoExpandBulletsGroup = true;\n        quantity = 1;\n      }\n\n      this.bullets.createMultiple({\n        key,\n        frame,\n        repeat: quantity,\n        active: false,\n        visible: false,\n      });\n\n      this.bullets.children.each(function(child) {\n        child.setData('bulletManager', this);\n      }, this);\n\n      this.bulletKey = key;\n      this.bulletFrame = frame;\n\n      if (group) {\n        group.addMultiple(this.bullets.children.entries);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Call a function on each in-flight bullet in this Weapon.\n   *\n   * See {@link Phaser.GameObjects.Group#forEachExists forEachExists} for more details.\n   *\n   * @param {function} callback - The function that will be called for each applicable child.\n   * The child will be passed as the first argument.\n   * @param {object} callbackContext - The context in which the function should be called (usually 'this').\n   * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n   * @return {Weapon} This Weapon instance.\n   */\n  forEach(callback, callbackContext) {\n    const extraArgs = arguments;\n\n    this.bullets.children.each(child => {\n      if (child.active) {\n        callback.call(callbackContext, child, extraArgs);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `false` on each bullet in this Weapon.\n   * This has the effect of stopping them in-flight should they be moving.\n   * It also stops them being able to be checked for collision.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  pauseAll() {\n    this.bullets.children.each(child => {\n      child.body.enable = false;\n      if (child.getData('timeEvent') !== null) {\n        child.getData('timeEvent').paused = true;\n      }\n    }, this);\n\n    return this;\n  }\n\n  /**\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `true` on each bullet in this Weapon.\n   * This has the effect of resuming their motion should they be in-flight.\n   * It also enables them for collision checks again.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  resumeAll() {\n    this.bullets.children.each(child => {\n      child.body.enable = true;\n      if (child.getData('timeEvent') !== null) {\n        child.getData('timeEvent').paused = false;\n      }\n    }, this);\n\n    return this;\n  }\n\n  /**\n   * Calls {@link Phaser.Bullet#kill} on every in-flight bullet in this Weapon.\n   * Also re-enables their physics bodies, should they have been disabled via {@link #pauseAll}.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  killAll() {\n    this.bullets.children.each(child => {\n      if (child.active) {\n        child.kill();\n      }\n      child.body.enable = true;\n    });\n\n    return this;\n  }\n\n  /**\n   * Resets the {@link #shots} counter back to zero. This is used when you've set\n   * {@link #fireLimit} and have hit (or just wish to reset) your limit.\n   *\n   * @param {integer} [newLimit] - Optionally set a new {@link #fireLimit}.\n   * @return {Weapon} This Weapon instance.\n   */\n  resetShots(newLimit) {\n    this.shots = 0;\n\n    if (newLimit !== undefined) {\n      this.fireLimit = newLimit;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets this Weapon to track the given Sprite, or any Object with a public {@link Phaser.Component.Core#world world}\n   * Point object. When a Weapon tracks a Sprite it will automatically update its {@link #fireFrom} value to match the\n   * Sprite's position within the Game World, adjusting the coordinates based on the offset arguments.\n   *\n   * This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.\n   *\n   * Calling `trackSprite` will reset {@link #trackedPointer} to null, should it have been set, as you can\n   * only track _either_ a Sprite, or a Pointer, at once, but not both.\n   *\n   * @param {Phaser.GameObjects.Sprite|Object} sprite - The Sprite to track the position of.\n   * @param {integer} [offsetX=0] - The horizontal offset from the Sprites position to be applied to the Weapon.\n   * @param {integer} [offsetY=0] - The vertical offset from the Sprites position to be applied to the Weapon.\n   * @param {boolean} [trackRotation=false] - Should the Weapon also track the Sprites rotation?\n   * @return {Weapon} This Weapon instance.\n   */\n  trackSprite(sprite, offsetX = 0, offsetY = 0, trackRotation = false) {\n    this.trackedPointer = null;\n    this.trackedSprite = sprite;\n    this.trackRotation = trackRotation;\n\n    this.trackOffset.set(offsetX, offsetY);\n\n    return this;\n  }\n\n  /**\n   * Sets this Weapon to track the given Pointer.\n   * When a Weapon tracks a Pointer it will automatically update its {@link #fireFrom} value to match the Pointer's\n   * position within the Game World, adjusting the coordinates based on the offset arguments.\n   *\n   * This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.\n   *\n   * Calling `trackPointer` will reset {@link #trackedSprite} to null, should it have been set, as you can\n   * only track _either_ a Pointer, or a Sprite, at once, but not both.\n   *\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to track the position of.\n   * Defaults to `Input.activePointer` if not specified.\n   * @param {integer} [offsetX=0] - The horizontal offset from the Pointers position to be applied to the Weapon.\n   * @param {integer} [offsetY=0] - The vertical offset from the Pointers position to be applied to the Weapon.\n   * @return {Weapon} This Weapon instance.\n   */\n  trackPointer(pointer, offsetX = 0, offsetY = 0) {\n    if (pointer === undefined && this.scene.input) {\n      pointer = this.scene.input.activePointer;\n    }\n\n    this.trackedPointer = pointer;\n    this.trackedSprite = null;\n    this.trackRotation = false;\n\n    this.trackOffset.set(offsetX, offsetY);\n\n    return this;\n  }\n\n  /**\n   * Attempts to fire multiple bullets from the positions defined in the given array.\n   *\n   * If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then\n   * the positions are treated as __offsets__ from the given objects position.\n   *\n   * If `from` is undefined, and there is no tracked object, then the bullets are fired\n   * from the given positions, as they exist in the world.\n   *\n   * Calling this method sets {@link #multiFire} to `true`.\n   *\n   * If there are not enough bullets available in the pool, and the pool cannot be extended,\n   * then this method may not fire from all of the given positions.\n   *\n   * When the bullets are launched they have their texture and frame updated, as required.\n   * The velocity of the bullets are calculated based on Weapon properties like {@link #bulletSpeed}.\n   *\n   * @param {array} positions - An array of positions. Each position can be any Object,\n   * as long as it has public `x` and `y` properties, such as Phaser.Point, { x: 0, y: 0 }, Phaser.Sprite, etc.\n   * @param {Phaser.GameObject.Sprite|Phaser.Math.Vector2|Object|string} [from]\n   * Optionally fires the bullets **from** the `x` and `y` properties of this object,\n   * _instead_ of any {@link #trackedSprite} or `trackedPointer` that is set.\n   * @return {array} An array containing all of the fired Phaser.Bullet objects,\n   * if a launch was successful, otherwise an empty array.\n   */\n  fireMany(positions, from) {\n    this.multiFire = true;\n\n    const bullets = [];\n\n    if (from || this.trackedSprite || this.trackedPointer) {\n      positions.forEach(offset => {\n        bullets.push(this.fire(from, null, null, offset.x, offset.y));\n      });\n    } else {\n      positions.forEach(position => {\n        bullets.push(this.fire(position));\n      });\n    }\n\n    return bullets;\n  }\n\n  /**\n   * Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset\n   * to the position first. This is the same as calling {@link #fire} and passing in the offset arguments.\n   *\n   * If there are no more bullets available in the pool, and the pool cannot be extended,\n   * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n   * the Weapon was fired, as defined in the {@link #fireRate} property.\n   *\n   * Otherwise the first available bullet is selected, launched, and returned.\n   *\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n   * calculated based on Weapon properties like {@link #bulletSpeed}.\n   *\n   * If you wish to fire multiple bullets in a single game update, then set {@link #multiFire} to `true`\n   * and you can call this method as many times as you like, per loop. See also {@link #fireMany}.\n   *\n   * @param {number} [offsetX=0] - The horizontal offset from the position of the tracked Sprite or Pointer,\n   * as set with {@link #trackSprite}.\n   * @param {number} [offsetY=0] - The vertical offset from the position of the tracked Sprite or Pointer,\n   * as set with {@link #trackSprite}.\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n   */\n  fireOffset(offsetX = 0, offsetY = 0) {\n    return this.fire(null, null, null, offsetX, offsetY);\n  }\n\n  /**\n   * Fires a bullet **at** the given Pointer. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtPointer(pointer) {\n    if (pointer === undefined && this.scene.input) {\n      pointer = this.scene.input.activePointer;\n    }\n\n    return this.fire(null, pointer.x, pointer.y);\n  }\n\n  /**\n   * Fires a bullet **at** the given Sprite. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {Phaser.GameObjects.Sprite} [sprite] - The Sprite to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtSprite(sprite) {\n    return this.fire(null, sprite.x, sprite.y);\n  }\n\n  /**\n   * Fires a bullet **at** the given coordinates. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet towards.\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtXY(x, y) {\n    return this.fire(null, x, y);\n  }\n\n  /**\n   * Attempts to fire a single Bullet. If there are no more bullets available in the pool,\n   * and the pool cannot be extended, then this method returns `null`. It will also return `null`\n   * if not enough time has expired since the last time the Weapon was fired,\n   * as defined in the {@link #fireRate} property.\n   *\n   * Otherwise the first available bullet is selected, launched, and returned.\n   *\n   * The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.\n   *\n   * If you don't provide any of the arguments then it uses those set via properties such as {@link #trackedSprite},\n   * {@link #bulletAngle} and so on.\n   *\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n   * calculated based on Weapon properties like `bulletSpeed`.\n   *\n   * If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`\n   * and you can call `fire` as many times as you like, per loop. Multiple fires in a single update\n   * only counts once towards the `shots` total, but you will still receive a Signal for each bullet.\n   *\n   * @param {Phaser.GameObjects.Sprite|Phaser.Math.Vector2|Object|string} [from]\n   * Optionally fires the bullet **from** the `x` and `y` properties of this object.\n   * If set this overrides {@link #trackedSprite} or `trackedPointer`. Pass `null` to ignore it.\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet **towards**.\n   * If left as `undefined`, or `null`, the bullet direction is based on its angle.\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet **towards**.\n   * If left as `undefined`, or `null`, the bullet direction is based on its angle.\n   * @param {number} [offsetX=0] - If the bullet is fired from a tracked Sprite or Pointer,\n   * or the `from` argument is set, this applies a horizontal offset from the launch position.\n   * @param {number} [offsetY=0] - If the bullet is fired from a tracked Sprite or Pointer,\n   * or the `from` argument is set, this applies a vertical offset from the launch position.\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n   */\n  fire(from, x = null, y = null, offsetX = 0, offsetY = 0) {\n    if (\n      this.scene.time.now < this._nextFire ||\n      (this.fireLimit > 0 && this.shots === this.fireLimit)\n    ) {\n      return null;\n    }\n\n    let speed = this.bulletSpeed;\n\n    //  Apply +- speed variance\n    if (this.bulletSpeedVariance !== 0) {\n      speed += Phaser.Math.Between(-this.bulletSpeedVariance, this.bulletSpeedVariance);\n    }\n\n    // Position the fireFrom rectangle\n    if (from) {\n      // Fire based on passed coordinates\n      this.updateFireFrom(from.x, from.y);\n    } else if (this.trackedSprite) {\n      // Fire based on tracked sprite\n      if (this.trackRotation) {\n        this._rotatedPoint.set(\n          this.trackedSprite.x + this.trackOffset.x,\n          this.trackedSprite.y + this.trackOffset.y\n        );\n        Phaser.Math.RotateAround(\n          this._rotatedPoint,\n          this.trackedSprite.x,\n          this.trackedSprite.y,\n          this.trackedSprite.rotation\n        );\n\n        this.updateFireFrom(this._rotatedPoint.x, this._rotatedPoint.y);\n      } else {\n        this.updateFireFrom(this.trackedSprite.x, this.trackedSprite.y);\n      }\n\n      if (this.bulletInheritSpriteSpeed) {\n        speed += this.trackedSprite.body.speed;\n      }\n    } else if (this.trackedPointer) {\n      // Fire based on tracked pointer\n      this.updateFireFrom(this.trackedPointer.x, this.trackedPointer.y);\n    }\n\n    // Take offset into account\n    this.fireFrom.x += offsetX;\n    this.fireFrom.y += offsetY;\n\n    // Pick a random coordinate inside the fireFrom rectangle\n    const randomX = this.fireFrom.x + Math.random() * this.fireFrom.width;\n    const randomY = this.fireFrom.y + Math.random() * this.fireFrom.height;\n\n    const fromX = this.fireFrom.width > 1 ? randomX : this.fireFrom.x;\n    const fromY = this.fireFrom.height > 1 ? randomY : this.fireFrom.y;\n\n    let angle = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;\n\n    //  The position (in world space) to fire the bullet towards, if set\n    if (x !== null && y !== null) {\n      angle = Phaser.Math.RadToDeg(Math.atan2(y - fromY, x - fromX));\n    }\n\n    //  Apply +- angle variance\n    if (this.bulletAngleVariance !== 0) {\n      angle += Phaser.Math.Between(-this.bulletAngleVariance, this.bulletAngleVariance);\n    }\n\n    let moveX = 0;\n    let moveY = 0;\n\n    //  Avoid unnecessary sin/cos for right-angled shots\n    if (angle === 0 || angle === 180) {\n      // Only cos needed\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n    } else if (angle === 90 || angle === 270) {\n      // Only sin needed\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    } else {\n      // Need to calculate both\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    }\n\n    let bullet = null;\n\n    // Attempt to get a bullet instance to use\n    if (this.autoExpandBulletsGroup) {\n      bullet = this.bullets.getFirstDead(true, fromX, fromY, this.bulletKey, this.bulletFrame);\n      bullet.setData('bulletManager', this);\n    } else {\n      bullet = this.bullets.getFirstDead(false);\n    }\n\n    // Prepare and fire the bullet\n    if (bullet) {\n      bullet.prepare(fromX, fromY);\n      bullet.setData({\n        fromX,\n        fromY,\n        killType: this.bulletKillType,\n        killDistance: this.bulletKillDistance,\n        rotateToVelocity: this.bulletRotateToVelocity,\n      });\n\n      // Prepare timer for bullet lifespan\n      if (this.bulletKillType === consts.KILL_LIFESPAN) {\n        bullet.setData('timeEvent', this.scene.time.addEvent({\n          delay: this.bulletLifespan,\n          callback: bullet.kill,\n          callbackScope: bullet,\n        }));\n        bullet.lifespan = this.bulletLifespan;\n      }\n\n      bullet.angle = angle + this.bulletAngleOffset;\n\n      //  Frames and Animations\n      if (this.bulletAnimation) {\n        bullet.anims.play(this.bulletAnimation);\n      } else if (this.bulletFrameCycle) {\n        // Calculate bullet frame to use\n        if (this.bulletFrameIndex >= this.bulletFrames.length) {\n          this.bulletFrameIndex = 0;\n        }\n        bullet.setTexture(this.bulletKey, this.bulletFrameIndex);\n        this.bulletFrameIndex++;\n      } else if (this.bulletFrameRandom) {\n        // Pick a bullet frame at random\n        const nextFrame = Math.floor(Math.random() * this.bulletFrames.length);\n        bullet.setTexture(this.bulletKey, nextFrame);\n      }\n\n      // Set correct size and position for bullet body\n      if (bullet.getData('bodyDirty')) {\n        if (this._data.customBody) {\n          bullet.body.setSize(this._data.width, this._data.height);\n          bullet.body.setOffset(this._data.offsetX, this._data.offsetY);\n        }\n\n        bullet.body.collideWorldBounds = this.bulletCollideWorldBounds;\n\n        bullet.setData('bodyDirty', false);\n      }\n\n      bullet.body.setVelocity(moveX, moveY);\n      bullet.body.setGravity(this.bulletGravity.x, this.bulletGravity.y);\n\n      let next = 0;\n\n      // Calculate when to fire next bullet, taking into account speed variance\n      if (this.bulletSpeedVariance !== 0) {\n        let rate = this.fireRate;\n\n        rate += Phaser.Math.Between(-this.fireRateVariance, this.fireRateVariance);\n\n        if (rate < 0) {\n          rate = 0;\n        }\n\n        next = this.scene.time.now + rate;\n      } else {\n        next = this.scene.time.now + this.fireRate;\n      }\n\n      // Prepare for next shot\n      if (this.multiFire) {\n        if (!this._hasFired) {\n          //  We only add 1 to the 'shots' count for multiFire shots\n          this._hasFired = true;\n          this._tempNextFire = next;\n          this.shots++;\n        }\n      } else {\n        this._nextFire = next;\n\n        this.shots++;\n      }\n\n      // Emit events\n      this.eventEmitter.emit('fire', bullet, this, speed);\n\n      if (this.fireLimit > 0 && this.shots === this.fireLimit) {\n        this.eventEmitter('firelimit', this, this.fireLimit);\n      }\n    }\n\n    return bullet;\n  }\n\n  /**\n   * Set the fireFrom rectangle based on passed coords\n   * @private\n   * @param {number} x - X coordinate for where to fire from\n   * @param {number} y - Y coordinate for where to fire from\n   * @return {void}\n   */\n  updateFireFrom(x, y){\n    if (this.fireFrom.width > 1) {\n      // If size is larger than 1, center on coordinates\n      Phaser.Geom.Rectangle.CenterOn(\n        this.fireFrom,\n        x + this.trackOffset.x,\n        y + this.trackOffset.y\n      );\n    } else {\n      this.fireFrom.x = x + this.trackOffset.x;\n      this.fireFrom.y = y + this.trackOffset.y;\n    }\n  }\n\n  /**\n   * You can modify the size of the physics Body the Bullets use to be any dimension you need.\n   * This allows you to make it smaller, or larger, than the parent Sprite.\n   * You can also control the x and y offset of the Body. This is the position of the\n   * Body relative to the top-left of the Sprite _texture_.\n   *\n   * For example: If you have a Sprite with a texture that is 80x100 in size,\n   * and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:\n   *\n   * `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`\n   *\n   * Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.\n   * 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34\n   * is the vertical offset.\n   *\n   * @param {number} width - The width of the Body.\n   * @param {number} height - The height of the Body.\n   * @param {number} [offsetX=0] - The X offset of the Body from the top-left of the Sprites texture.\n   * @param {number} [offsetY=0] - The Y offset of the Body from the top-left of the Sprites texture.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  setBulletBodyOffset(width, height, offsetX=0, offsetY=0) {\n    this._data.customBody = true;\n    this._data.width = width;\n    this._data.height = height;\n    this._data.offsetX = offsetX;\n    this._data.offsetY = offsetY;\n\n    //  Update all bullets in the pool\n    this.bullets.children.each(child => {\n      child.body.setSize(width, height);\n      child.body.setOffset(offsetX, offsetY);\n      child.setData('bodyDirty', false);\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets the texture frames that the bullets can use when being launched.\n   *\n   * This is intended for use when you've got numeric based frames, such as\n   * those loaded via a Sprite Sheet.\n   *\n   * It works by calling `Phaser.Utils.Array.NumberArray` internally, using\n   * the min and max values provided. Then it sets the frame index to be zero.\n   *\n   * You can optionally set the cycle and random booleans, to allow bullets to\n   * cycle through the frames when they're fired, or pick one at random.\n   *\n   * @param {integer} min - The minimum value the frame can be. Usually zero.\n   * @param {integer} max - The maximum value the frame can be.\n   * @param {integer} [selcetionMethod=BULLET_FRAME_STABLE] - Specifies how the\n   *  frame for the fired bullet will be selected. See consts.BULLET_FRAME_XYZ\n   *  for options.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  setBulletFrames(min, max, selectionMethod = consts.BULLET_FRAME_STABLE) {\n    if (\n      typeof selectionMethod !== 'number' ||\n      selectionMethod < consts.BULLET_FRAME_STABLE ||\n      selectionMethod > consts.BULLET_FRAME_RANDOM\n    ) {\n      log(`Invalid bullet frame selection method specified: ${selectionMethod}`, this.logLevel);\n    }\n\n    if (min > max) {\n      log(`min frame (${min}) must be <= max frame (${max})`, this.logLevel);\n    }\n\n    this.bulletFrames = Phaser.Utils.Array.NumberArray(min, max);\n    this.bulletFrameIndex = 0;\n    this.bulletFrameCycle = selectionMethod === consts.BULLET_FRAME_CYCLE;\n    this.bulletFrameRandom = selectionMethod === consts.BULLET_FRAME_RANDOM;\n\n    return this;\n  }\n\n  /**\n   * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n   * The arguments are all the same as for `Animation.add`, and work in the same way.\n   *\n   * {@link #bulletAnimation} will be set to this animation after it's created. From that point on, all\n   * bullets fired will play using this animation. You can swap between animations by calling this method\n   * several times, and then just changing the {@link #bulletAnimation} property to the name of the animation\n   * you wish to play for the next launched bullet.\n   *\n   * If you wish to stop using animations at all, set {@link #bulletAnimation} to '' (an empty string).\n   *\n   * @param {string} name - The unique (within the Weapon instance) name for the animation, i.e. \"fire\", \"blast\".\n   * @param {Array} [frames=null] - An array of numbers/strings that correspond to the framesto add to this animation\n   * and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n   * @param {number} [frameRate=60] - The speed at which the animation should play.\n   * The speed is given in frames per second.\n   * @param {number} [loop=1] - Number of times to repeat the animation. Set to -1 to repeat forever.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  addBulletAnimation(name, frames, frameRate, loop) {\n    if (!this.scene.sys.anims.anims.contains(name)) {\n      this.scene.sys.anims.create({\n        key: name,\n        frames,\n        frameRate,\n        loop,\n      });\n\n      this.anims[name] = this.scene.sys.anims.anims.entries[name];\n    }\n\n    this.bulletAnimation = name;\n\n    return this;\n  }\n\n  /**\n   * Internal update method, called by the Weapon Plugin.\n   * @returns {void}\n   */\n  update() {\n    if (this._bulletKillType === consts.KILL_WEAPON_BOUNDS) {\n      if (this.trackedSprite) {\n        this.trackedSprite.updateTransform();\n        Phaser.Geom.Rectangle.CenterOn(this.bounds,this.trackedSprite.x, this.trackedSprite.y);\n      } else if (this.trackedPointer) {\n        Phaser.Geom.Rectangle.CenterOn(this.bounds,this.trackedPointer.x, this.trackedPointer.y);\n      }\n    }\n\n    if (this.autofire) {\n      this.fire();\n    }\n  }\n\n  /**\n   * Internal update method, called by the Weapon Plugin.\n   *\n   * @protected\n   * @returns {void}\n   */\n  postRender() {\n    if (!this.multiFire || !this._hasFired) {\n      return;\n    }\n\n    this._hasFired = false;\n\n    this._nextFire = this._tempNextFire;\n  }\n\n  /**\n   * Destroys this Weapon.\n   * You must release everything in here, all references, all objects, free it all up.\n   * @returns {void}\n   */\n  destroy() {\n    this.scene = null;\n\n    this.bullets.destroy(true);\n  }\n}\n\nexport default Weapon;\n\n\n\n// WEBPACK FOOTER //\n// ./Weapon.js","import consts from './consts';\n\n/**\n * Log text to the console or throw an error\n * @param {string} text - Text to be logged\n * @param {string} logLevel - The log level, either `warn`, `error' or `off`\n */\nfunction log(text, logLevel){\n  if(logLevel === 'warn'){\n    console.warn(text);\n  } else if (logLevel === 'error'){\n    throw new Error(text);\n  }\n}\n\n/**\n * Check the config of the weapon for common errors and weird configurations.\n * @param {Weapon} weapon - The weapon being validated\n * @param {string} property - The property of the weapon being validated\n */\nfunction validateConfig(weapon, property){\n  if (\n    ['bulletWorldWrap', 'bulletKillType'].includes(property) && \n    weapon.bulletWorldWrap && \n    (weapon.bulletKillType === consts.KILL_WORLD_BOUNDS || \n      weapon.bulletKillType === consts.KILL_WEAPON_BOUNDS)\n  ){\n    log(\n      'Warning: KILL_WORLD_BOUNDS and KILL_WEAPON_BOUNDS does not work well with bulletWorldWrap set to true.', \n      weapon.logLevel\n    );\n  }\n  if (['bulletKillType', 'bulletLifespan'].includes(property) && \n  weapon.bulletKillType === consts.KILL_LIFESPAN && \n  weapon.bulletLifespan < 0\n  ) {\n    log('Invalid bulletLifespan; must be > 0; currently ' + weapon.bulletLifespan, weapon.logLevel);\n  }\n  if (\n    ['fireLimit', \n      'fireRate', \n      'fireRateVariance', \n      'bulletAngleVariance', \n      'bulletSpeedVariance',\n      'bulletKillDistance'].includes(property) && \n    weapon[property] < 0\n  ){\n    log('Invalid ' + property + '; must be >= 0; currently ' + weapon[property], weapon.logLevel);\n  }\n}\n\nexport { log };\nexport default validateConfig;\n\n\n// WEBPACK FOOTER //\n// ./validateConfig.js"],"sourceRoot":""}