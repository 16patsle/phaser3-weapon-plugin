{"version":3,"sources":["webpack://WeaponPlugin/webpack/universalModuleDefinition","webpack://WeaponPlugin/webpack/bootstrap","webpack://WeaponPlugin/./main.js","webpack://WeaponPlugin/./Weapon.js","webpack://WeaponPlugin/./Bullet.js","webpack://WeaponPlugin/./consts.js","webpack://WeaponPlugin/./validateConfig.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","WeaponPlugin","scene","pluginManager","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","weapons","registerGameObject","add","_assertThisInitialized","config","bulletLimit","frame","group","weaponClass","Phaser","Plugins","ScenePlugin","Weapon","weapon","push","systems","events","on","postRender","eventEmitter","update","destroy","forEach","game","Bullet","consts","debugPhysics","_bullets","_autoExpandBulletsGroup","_autofire","_shots","_fireLimit","_fireRate","_fireRateVariance","_fireFrom","Geom","Rectangle","_fireAngle","ANGLE_UP","_bulletInheritSpriteSpeed","_bulletAnimation","_bulletFrameRandom","_bulletFrameCycle","_bulletWorldWrap","_bulletWorldWrapPadding","_bulletAngleOffset","_bulletAngleVariance","_bulletSpeed","_bulletSpeedVariance","_bulletLifespan","_bulletKillDistance","_bulletGravity","Math","Vector2","_bulletRotateToVelocity","_bulletKey","_bulletFrame","_bulletClass","_bulletCollideWorldBounds","_bulletKillType","KILL_WORLD_BOUNDS","_data","customBody","width","height","offsetX","offsetY","_bounds","_bulletBounds","physics","world","bounds","_bulletFrames","_bulletFrameIndex","anims","_trackedSprite","_trackedPointer","_multiFire","_hasFired","_trackRotation","_trackOffset","_nextFire","_tempNextFire","_rotatedPoint","logLevel","Events","EventEmitter","validateConfig","createBullets","quantity","arguments","length","undefined","bulletClass","bullets","classType","maxSize","runChildUpdate","autoExpandBulletsGroup","createMultiple","repeat","active","visible","children","each","child","setData","bulletKey","bulletFrame","addMultiple","entries","callback","callbackContext","extraArgs","body","enable","getData","paused","kill","newLimit","shots","fireLimit","sprite","trackRotation","trackedPointer","trackedSprite","trackOffset","set","pointer","input","activePointer","positions","from","multiFire","offset","fire","x","y","position","time","now","speed","bulletSpeed","bulletSpeedVariance","Between","updateFireFrom","RotateAround","rotation","bulletInheritSpriteSpeed","fireFrom","randomX","random","randomY","fromX","fromY","angle","fireAngle","RadToDeg","atan2","bulletAngleVariance","moveX","moveY","cos","DegToRad","sin","bullet","getFirstDead","prepare","killType","bulletKillType","killDistance","bulletKillDistance","rotateToVelocity","bulletRotateToVelocity","KILL_LIFESPAN","addEvent","delay","bulletLifespan","callbackScope","lifespan","bulletAngleOffset","bulletAnimation","play","bulletFrameCycle","bulletFrameIndex","bulletFrames","setTexture","bulletFrameRandom","nextFrame","floor","setSize","setOffset","collideWorldBounds","bulletCollideWorldBounds","setVelocity","setGravity","bulletGravity","next","rate","fireRate","fireRateVariance","emit","CenterOn","min","max","selectionMethod","BULLET_FRAME_STABLE","BULLET_FRAME_RANDOM","log","concat","Utils","Array","NumberArray","BULLET_FRAME_CYCLE","frames","frameRate","loop","sys","contains","KILL_WEAPON_BOUNDS","updateTransform","autofire","type","KILL_STATIC_BOUNDS","bulletBounds","KILL_CAMERA_BOUNDS","cameras","main","bulletID","existing","setDataEnabled","timeEvent","bulletManager","bodyDirty","bodyBounds","GameObjects","Sprite","setActive","setVisible","reset","debugShowBody","debugShowVelocity","stop","KILL_DISTANCE","distance","Intersects","RectangleToRectangle","getBounds","velocity","atan","bulletWorldWrap","wrap","bulletWorldWrapPadding","__webpack_exports__","KILL_NEVER","ANGLE_DOWN","ANGLE_LEFT","ANGLE_RIGHT","ANGLE_NORTH_EAST","ANGLE_NORTH_WEST","ANGLE_SOUTH_EAST","ANGLE_SOUTH_WEST","_consts__WEBPACK_IMPORTED_MODULE_0__","text","console","warn","Error","includes"],"mappings":"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","file":"WeaponPlugin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WeaponPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WeaponPlugin\"] = factory();\n\telse\n\t\troot[\"WeaponPlugin\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/16patsle/phaser3-weapon-plugin/blob/master/LICENSE|MIT License}\n */\nimport Weapon from './Weapon';\nimport Bullet from './Bullet';\nimport consts from './consts';\n\n/**\n * The Weapon Plugin provides the ability to easily create a bullet pool\n * and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, like iterate it, etc can be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.setPosition(300, 300);\n * this.input.on('pointerdown', weapon.fire, this);\n * ```\n */\nclass WeaponPlugin extends Phaser.Plugins.ScenePlugin {\n  /**\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the\n   *  Phaser.Plugins.PluginManager instance.\n   */\n  constructor(scene, pluginManager) {\n    super(scene, pluginManager);\n\n    this.weapons = [];\n\n    // Register our new Game Object type\n    pluginManager.registerGameObject('weapon', this.add.bind(this), config => {\n      return this.add(\n        config.bulletLimit,\n        config.key,\n        config.frame,\n        config.group,\n        config.weaponClass\n      );\n    });\n  }\n\n  add(bulletLimit, key, frame, group, weaponClass) {\n    if (!weaponClass) {\n      weaponClass = Weapon;\n    }\n    const weapon = new weaponClass(this.scene, bulletLimit, key, frame, group);\n\n    this.weapons.push(weapon);\n\n    return weapon;\n  }\n\n  /**\n   * Called by the PluginManager when this plugin is started.\n   * If a plugin is stopped, and then started again, this will get called again.\n   * Typically called immediately after `BasePlugin.init`.\n   *\n   * @returns {void}\n   */\n  start() {\n    this.systems.events.on('postrender', this.postRender, this);\n  }\n\n  /**\n   * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\n   * By this point the plugin properties `scene` and `systems` will have already been set.\n   * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n   * @returns {void}\n   */\n  boot() {\n    const eventEmitter = this.systems.events;\n\n    eventEmitter.on('update', this.update, this);\n    eventEmitter.on('destroy', this.destroy, this);\n  }\n\n  /**\n   * Internal update method, called by the PluginManager.\n   *\n   * @protected\n   * @returns {void}\n   */\n  update() {\n    this.weapons.forEach(weapon => {\n      weapon.update();\n    });\n  }\n\n  /**\n   * Internal update method, called by the PluginManager.\n   *\n   * @protected\n   * @returns {void}\n   */\n  postRender() {\n    this.weapons.forEach(weapon => {\n      weapon.postRender();\n    });\n  }\n\n  /**\n   * Destroys this Weapon.\n   * You must release everything in here, all references, all objects, free it all up.\n   * @returns {void}\n   */\n  destroy() {\n    this.pluginManager = null;\n    this.game = null;\n    this.scene = null;\n    this.systems = null;\n  }\n}\n\n// Set up shortcuts to the classes and constants\nWeaponPlugin.Weapon = Weapon;\nWeaponPlugin.Bullet = Bullet;\nWeaponPlugin.consts = consts;\n\nexport default WeaponPlugin;\n","import Bullet from './Bullet';\nimport consts from './consts';\nimport validateConfig, { log } from './validateConfig';\n\n/**\n * The Weapon provides the ability to easily create a bullet pool and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, like iterate it, etc can be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.setPosition(300, 300);\n * this.input.on('pointerdown', weapon.fire, this);\n * ```\n */\nclass Weapon {\n  /**\n   * TODO: a builder style interface would be neat. Can be kicked way forward\n   * into polishing.\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {number} bulletLimit - The number of bullets to create.\n   * @param {String} key - The texture key for the bullet.\n   * @param {String} frame - The frame name for the bullet.\n   * @param {Phaser.GameObjects.Group} group - A group to add the bullets to.\n   */\n  constructor(scene, bulletLimit, key, frame, group) {\n    this.scene = scene;\n\n    this.debugPhysics = null;\n\n    /**\n     * Private var that holds the public `bullets` property.\n     * @type {Phaser.GameObjects.Group}\n     * @private\n     */\n    this._bullets = null;\n\n    /**\n     * Private var that holds the public `autoExpandBulletsGroup` property.\n     * @type {boolean}\n     * @private\n     */\n    this._autoExpandBulletsGroup = false;\n\n    /**\n     * Private var that holds the public `autofire` property.\n     * @type {boolean}\n     * @private\n     */\n    this._autofire = false;\n\n    /**\n     * Private var that holds the public `shots` property.\n     * @type {number}\n     * @private\n     */\n    this._shots = 0;\n\n    /**\n     * Private var that holds the public `fireLimit` property.\n     * @type {number}\n     * @private\n     */\n    this._fireLimit = 0;\n\n    /**\n     * Private var that holds the public `fireRate` property.\n     * @type {number}\n     * @private\n     */\n    this._fireRate = 100;\n\n    /**\n     * Private var that holds the public `fireRateVariance` property.\n     * @type {number}\n     * @private\n     */\n    this._fireRateVariance = 0;\n\n    /**\n     * Private var that holds the public `fireFrom` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this._fireFrom = new Phaser.Geom.Rectangle(0, 0, 1, 1);\n\n    /**\n     * Private var that holds the public `fireAngle` property.\n     * @type {integer}\n     * @private\n     */\n    this._fireAngle = consts.ANGLE_UP;\n\n    /**\n     * Private var that holds the public `bulletInheritSpriteSpeed` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletInheritSpriteSpeed = false;\n\n    /**\n     * Private var that holds the public `bulletAnimation` property.\n     * @type {string}\n     * @private\n     */\n    this._bulletAnimation = '';\n\n    /**\n     * Private var that holds the public `bulletFrameRandom` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletFrameRandom = false;\n\n    /**\n     * Private var that holds the public `bulletFrameCycle` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletFrameCycle = false;\n\n    /**\n     * Private var that holds the public `bulletWorldWrap` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletWorldWrap = false;\n\n    /**\n     * Private var that holds the public `bulletWorldWrapPadding` property.\n     * @type {integer}\n     * @private\n     */\n    this._bulletWorldWrapPadding = 0;\n\n    /**\n     * Private var that holds the public `bulletAngleOffset` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletAngleOffset = 0;\n\n    /**\n     * Private var that holds the public `bulletAngleVariance` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletAngleVariance = 0;\n\n    /**\n     * Private var that holds the public `bulletSpeed` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletSpeed = 200;\n\n    /**\n     * Private var that holds the public `bulletSpeedVariance` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletSpeedVariance = 0;\n\n    /**\n     * Private var that holds the public `bulletLifespan` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletLifespan = 0;\n\n    /**\n     * Private var that holds the public `bulletKillDistance` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletKillDistance = 0;\n\n    /**\n     * Private var that holds the public `bulletGravity` property.\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._bulletGravity = new Phaser.Math.Vector2(0, 0);\n\n    /**\n     * Private var that holds the public `bulletRotateToVelocity` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletRotateToVelocity = false;\n\n    /**\n     * Private var that holds the public `bulletKey` property.\n     * @type {string}\n     * @private\n     */\n    this._bulletKey = key || '';\n\n    /**\n     * Private var that holds the public `bulletFrame` property.\n     * @type {string|integer}\n     * @private\n     */\n    this._bulletFrame = frame || '';\n\n    /**\n     * Private var that holds the public `bulletClass` property.\n     * @type {function}\n     * @private\n     */\n    this._bulletClass = Bullet;\n\n    /**\n     * Private var that holds the public `bulletCollideWorldBounds` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletCollideWorldBounds = false;\n\n    /**\n     * Private var that holds the public `bulletKillType` property.\n     * @type {integer}\n     * @private\n     */\n    this._bulletKillType = consts.KILL_WORLD_BOUNDS;\n\n    /**\n     * Holds internal data about custom bullet body sizes.\n     *\n     * @type {Object}\n     * @private\n     */\n    this._data = {\n      customBody: false,\n      width: 0,\n      height: 0,\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    /**\n     * Private var that holds the public `bounds` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this._bounds = new Phaser.Geom.Rectangle();\n\n    /**\n     * Private var that holds the public `bulletBounds` property.\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this._bulletBounds = this.scene.physics.world.bounds;\n\n    /**\n     * This array stores the frames added via @link #setBulletFrames.\n     *\n     * @type {Array}\n     * @protected\n     */\n    this._bulletFrames = [];\n\n    /**\n     * Private var that holds the public `bulletFrameIndex` property.\n     * @type {number}\n     * @private\n     */\n    this._bulletFrameIndex = 0;\n\n    /**\n     * An internal object that stores the animation data added via {@link #addBulletAnimation}.\n     * @type {Object}\n     * @private\n     */\n    this.anims = {};\n\n    /**\n     * Private var that holds the public `trackedSprite` property.\n     * @type {Phaser.GameObjects.Sprite|Object}\n     * @private\n     */\n    this._trackedSprite = null;\n\n    /**\n     * Private var that holds the public `trackedPointer` property.\n     * @type {Phaser.Input.Pointer}\n     * @private\n     */\n    this._trackedPointer = null;\n\n    /**\n     * Private var that holds the public `multiFire` property.\n     * @type {boolean}\n     * @private\n     */\n    this._multiFire = false;\n\n    /**\n     * Internal multiFire test flag.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._hasFired = false;\n\n    /**\n     * Private var that holds the public `trackRotation` property.\n     * @type {boolean}\n     * @private\n     */\n    this._trackRotation = false;\n\n    /**\n     * Private var that holds the public `trackOffset` property.\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._trackOffset = new Phaser.Math.Vector2();\n\n    /**\n     * Internal firing rate time tracking variable.\n     *\n     * @type {number}\n     * @private\n     */\n    this._nextFire = 0;\n\n    /**\n     * Internal firing rate time tracking variable used by multiFire.\n     *\n     * @type {number}\n     * @private\n     */\n    this._tempNextFire = 0;\n\n    /**\n     * Internal firing rotation tracking point.\n     *\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._rotatedPoint = new Phaser.Math.Vector2();\n\n    /**\n     * Log level for this weapon. Either `warn`, `error' or `off`. `warn` is the default.\n     * If you change this, please do so before setting any other properties.\n     *\n     * @type {string}\n     */\n    this.logLevel = 'warn';\n\n    this.eventEmitter = new Phaser.Events.EventEmitter();\n\n    validateConfig(this);\n\n    this.createBullets(bulletLimit, key, frame, group);\n  }\n\n  /**\n   * This is the Phaser.Group that contains all of the bullets managed by this plugin.\n   * @type {Phaser.GameObjects.Group}\n   */\n  get bullets() {\n    return this._bullets;\n  }\n  set bullets(value) {\n    this._bullets = value;\n\n    validateConfig(this, 'bullets');\n  }\n\n  /**\n   * Should the bullet pool run out of bullets (i.e. they are all in flight) then this\n   * boolean controls if the Group will create a brand new bullet object or not.\n   * @type {boolean}\n   * @default\n   */\n  get autoExpandBulletsGroup() {\n    return this._autoExpandBulletsGroup;\n  }\n  set autoExpandBulletsGroup(value) {\n    this._autoExpandBulletsGroup = value;\n\n    validateConfig(this, 'autoExpandBulletsGroup');\n  }\n\n  /**\n   * Will this weapon auto fire? If set to true then a new bullet will be fired\n   * based on the {@link #fireRate} value.\n   * @type {boolean}\n   * @default\n   */\n  get autofire() {\n    return this._autofire;\n  }\n  set autofire(value) {\n    this._autofire = value;\n\n    validateConfig(this, 'autofire');\n  }\n\n  /**\n   * The total number of bullets this Weapon has fired so far.\n   * You can limit the number of shots allowed (via {@link #fireLimit}), and reset\n   * this total via {@link #resetShots}.\n   * @type {number}\n   * @default\n   */\n  get shots() {\n    return this._shots;\n  }\n  set shots(value) {\n    this._shots = value;\n\n    validateConfig(this, 'shots');\n  }\n\n  /**\n   * The maximum number of shots that this Weapon is allowed to fire before it stops.\n   * When the limit is hit the {@link #onFireLimit} event is dispatched.\n   * You can reset the shot counter via {@link #resetShots}.\n   * @type {number}\n   * @default\n   */\n  get fireLimit() {\n    return this._fireLimit;\n  }\n  set fireLimit(value) {\n    this._fireLimit = value;\n\n    validateConfig(this, 'fireLimit');\n  }\n\n  /**\n   * The minimum interval between shots, in milliseconds.\n   * @type {number}\n   * @default\n   */\n  get fireRate() {\n    return this._fireRate;\n  }\n  set fireRate(value) {\n    this._fireRate = value;\n\n    validateConfig(this, 'fireRate');\n  }\n\n  /**\n   * This is a modifier that is added to the {@link #fireRate} each update to add variety\n   * to the firing rate of the Weapon. The value is given in milliseconds.\n   * If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual\n   * firing rate of the Weapon will be between 150 and 250.\n   * @type {number}\n   * @default\n   */\n  get fireRateVariance() {\n    return this._fireRateVariance;\n  }\n  set fireRateVariance(value) {\n    this._fireRateVariance = value;\n\n    validateConfig(this, 'fireRateVariance');\n  }\n\n  /**\n   * This is a Rectangle from within which the bullets are fired. By default it's a 1x1\n   * rectangle, the equivalent of a Point. But you can change the width and height, and if\n   * larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.\n   * @type {Phaser.Geom.Rectangle}\n   */\n  get fireFrom() {\n    return this._fireFrom;\n  }\n  set fireFrom(value) {\n    this._fireFrom = value;\n\n    validateConfig(this, 'fireFrom');\n  }\n\n  /**\n   * The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP\n   * or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.\n   * @type {integer}\n   * @default\n   */\n  get fireAngle() {\n    return this._fireAngle;\n  }\n  set fireAngle(value) {\n    this._fireAngle = value;\n\n    validateConfig(this, 'fireAngle');\n  }\n\n  /**\n   * When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.\n   * @type {boolean}\n   * @default\n   */\n  get bulletInheritSpriteSpeed() {\n    return this._bulletInheritSpriteSpeed;\n  }\n  set bulletInheritSpriteSpeed(value) {\n    this._bulletInheritSpriteSpeed = value;\n\n    validateConfig(this, 'bulletInheritSpriteSpeed');\n  }\n\n  /**\n   * The string based name of the animation that the Bullet will be given on launch.\n   * This is set via {@link #addBulletAnimation}.\n   * @type {string}\n   * @default\n   */\n  get bulletAnimation() {\n    return this._bulletAnimation;\n  }\n  set bulletAnimation(value) {\n    this._bulletAnimation = value;\n\n    validateConfig(this, 'bulletAnimation');\n  }\n\n  /**\n   * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n   * chose for each Bullet fired to pick a random frame from the set.\n   * @type {boolean}\n   * @default\n   */\n  get bulletFrameRandom() {\n    return this._bulletFrameRandom;\n  }\n  set bulletFrameRandom(value) {\n    this._bulletFrameRandom = value;\n\n    validateConfig(this, 'bulletFrameRandom');\n  }\n\n  /**\n   * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n   * chose for each Bullet fired to use the next frame in the set. The frame index is then\n   * advanced one frame until it reaches the end of the set, then it starts from the start\n   * again. Cycling frames like this allows you to create varied bullet effects via\n   * sprite sheets.\n   * @type {boolean}\n   * @default\n   */\n  get bulletFrameCycle() {\n    return this._bulletFrameCycle;\n  }\n  set bulletFrameCycle(value) {\n    this._bulletFrameCycle = value;\n\n    validateConfig(this, 'bulletFrameCycle');\n  }\n\n  /**\n   * Should the Bullets wrap around the world bounds? This automatically calls\n   * `World.wrap` on the Bullet each frame. See the docs for that method for details.\n   * @type {boolean}\n   * @default\n   */\n  get bulletWorldWrap() {\n    return this._bulletWorldWrap;\n  }\n  set bulletWorldWrap(value) {\n    this._bulletWorldWrap = value;\n\n    validateConfig(this, 'bulletWorldWrap');\n  }\n\n  /**\n   * If `bulletWorldWrap` is true then you can provide an optional padding value with this\n   * property. It's added to the calculations determining when the Bullet should wrap around\n   * the world or not. The value is given in pixels.\n   * @type {integer}\n   * @default\n   */\n  get bulletWorldWrapPadding() {\n    return this._bulletWorldWrapPadding;\n  }\n  set bulletWorldWrapPadding(value) {\n    this._bulletWorldWrapPadding = value;\n\n    validateConfig(this, 'bulletWorldWrapPadding');\n  }\n\n  /**\n   * An optional angle offset applied to the Bullets when they are launched.\n   * This is useful if for example your bullet sprites have been drawn facing up, instead of\n   * to the right, and you want to fire them at an angle. In which case you can set the\n   * angle offset to be 90 and they'll be properly rotated when fired.\n   * @type {number}\n   * @default\n   */\n  get bulletAngleOffset() {\n    return this._bulletAngleOffset;\n  }\n  set bulletAngleOffset(value) {\n    this._bulletAngleOffset = value;\n\n    validateConfig(this, 'bulletAngleOffset');\n  }\n\n  /**\n   * This is a variance added to the angle of Bullets when they are fired.\n   * If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual\n   * angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a\n   * great 'spread' effect to a Weapon.\n   * @type {number}\n   * @default\n   */\n  get bulletAngleVariance() {\n    return this._bulletAngleVariance;\n  }\n  set bulletAngleVariance(value) {\n    this._bulletAngleVariance = value;\n\n    validateConfig(this, 'bulletAngleVariance');\n  }\n\n  /**\n   * The initial velocity of fired bullets, in pixels per second.\n   * @type {number}\n   * @default\n   */\n  get bulletSpeed() {\n    return this._bulletSpeed;\n  }\n  set bulletSpeed(value) {\n    this._bulletSpeed = value;\n\n    validateConfig(this, 'bulletSpeed');\n  }\n\n  /**\n   * This is a variance added to the speed of Bullets when they are fired.\n   * If bullets have a {@link #bulletSpeed} value of 200, and a `bulletSpeedVariance` of 50\n   * then the actual speed of the Bullets will be between 150 and 250 pixels per second.\n   * @type {number}\n   * @default\n   */\n  get bulletSpeedVariance() {\n    return this._bulletSpeedVariance;\n  }\n  set bulletSpeedVariance(value) {\n    this._bulletSpeedVariance = value;\n\n    validateConfig(this, 'bulletSpeedVariance');\n  }\n\n  /**\n   * If you've set {@link #bulletKillType} to `consts.KILL_LIFESPAN` this controls the amount\n   * of lifespan the Bullets have set on launch. The value is given in milliseconds.\n   * When a Bullet hits its lifespan limit it will be automatically killed.\n   * @type {number}\n   * @default\n   */\n  get bulletLifespan() {\n    return this._bulletLifespan;\n  }\n  set bulletLifespan(value) {\n    this._bulletLifespan = value;\n\n    validateConfig(this, 'bulletLifespan');\n  }\n\n  /**\n   * If you've set {@link #bulletKillType} to `consts.KILL_DISTANCE` this controls the distance\n   * the Bullet can travel before it is automatically killed. The distance is given in pixels.\n   * @type {number}\n   * @default\n   */\n  get bulletKillDistance() {\n    return this._bulletKillDistance;\n  }\n  set bulletKillDistance(value) {\n    this._bulletKillDistance = value;\n\n    validateConfig(this, 'bulletKillDistance');\n  }\n\n  /**\n   * This is the amount of {@link Phaser.Physics.Arcade.Body#gravity} added to the Bullets physics body when fired.\n   * Gravity is expressed in pixels / second / second.\n   * @type {Phaser.Math.Vector2}\n   */\n  get bulletGravity() {\n    return this._bulletGravity;\n  }\n  set bulletGravity(value) {\n    this._bulletGravity = value;\n\n    validateConfig(this, 'bulletGravity');\n  }\n\n  /**\n   * Bullets can optionally adjust their rotation in-flight to match their velocity.\n   * This can create the effect of a bullet 'pointing' to the path it is following, for example\n   * an arrow being fired from a bow, and works especially well when added to {@link #bulletGravity}.\n   * @type {boolean}\n   * @default\n   */\n  get bulletRotateToVelocity() {\n    return this._bulletRotateToVelocity;\n  }\n  set bulletRotateToVelocity(value) {\n    this._bulletRotateToVelocity = value;\n\n    validateConfig(this, 'bulletRotateToVelocity');\n  }\n\n  /**\n   * The Texture Key that the Bullets use when rendering.\n   * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n   * @type {string}\n   * @default\n   */\n  get bulletKey() {\n    return this._bulletKey;\n  }\n  set bulletKey(value) {\n    this._bulletKey = value;\n\n    validateConfig(this, 'bulletKey');\n  }\n\n  /**\n   * The Texture Frame that the Bullets use when rendering.\n   * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n   * @type {string|integer}\n   * @default\n   */\n  get bulletFrame() {\n    return this._bulletFrame;\n  }\n  set bulletFrame(value) {\n    this._bulletFrame = value;\n\n    validateConfig(this, 'bulletFrame');\n  }\n\n  /**\n   * The Class of the bullets that are launched by this Weapon. Defaults to {@link Phaser.Bullet}, but can be\n   * overridden before calling `createBullets` and set to your own class type.\n   *\n   * It should be a constructor function accepting `(game, x, y, key, frame)`.\n   *\n   * @property {function} bulletClass\n   */\n  get bulletClass() {\n    return this._bulletClass;\n  }\n  set bulletClass(classType) {\n    this._bulletClass = classType;\n\n    // `this.bullets` exists only after createBullets()\n    if (this.bullets) {\n      this.bullets.classType = this._bulletClass;\n    }\n\n    validateConfig(this, 'bulletClass');\n  }\n\n  /**\n   * Should bullets collide with the World bounds or not?\n   *\n   * @property {boolean} bulletCollideWorldBounds\n   */\n  get bulletCollideWorldBounds() {\n    return this._bulletCollideWorldBounds;\n  }\n  set bulletCollideWorldBounds(value) {\n    this._bulletCollideWorldBounds = value;\n\n    this.bullets.children.each(child => {\n      child.body.collideWorldBounds = value;\n      child.setData('bodyDirty', false);\n    });\n\n    validateConfig(this, 'bulletCollideWorldBounds');\n  }\n\n  /**\n   * This controls how the bullets will be killed. The default is `consts.KILL_WORLD_BOUNDS`.\n   *\n   * There are 7 different \"kill types\" available:\n   *\n   * * `consts.KILL_NEVER`\n   * The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.\n   *\n   * * `consts.KILL_LIFESPAN`\n   * The bullets are automatically killed when their `bulletLifespan` amount expires.\n   *\n   * * `consts.KILL_DISTANCE`\n   * The bullets are automatically killed when they\n   * exceed `bulletDistance` pixels away from their original launch position.\n   *\n   * * `consts.KILL_WEAPON_BOUNDS`\n   * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n   *\n   * * `consts.KILL_CAMERA_BOUNDS`\n   * The bullets are automatically killed when they no longer intersect with the {@link Phaser.Camera#bounds} rectangle.\n   *\n   * * `consts.KILL_WORLD_BOUNDS`\n   * The bullets are automatically killed when they no longer intersect with the {@link Phaser.World#bounds} rectangle.\n   *\n   * * `consts.KILL_STATIC_BOUNDS`\n   * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n   * The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to\n   * match the position of a tracked sprite or pointer.\n   *\n   * @property {integer} bulletKillType\n   */\n  get bulletKillType() {\n    return this._bulletKillType;\n  }\n  set bulletKillType(type) {\n    switch (type) {\n      case consts.KILL_STATIC_BOUNDS:\n      case consts.KILL_WEAPON_BOUNDS:\n        this.bulletBounds = this.bounds;\n        break;\n\n      case consts.KILL_CAMERA_BOUNDS:\n        this.bulletBounds = this.scene.sys.cameras.main._bounds;\n        break;\n\n      case consts.KILL_WORLD_BOUNDS:\n        this.bulletBounds = this.scene.physics.world.bounds;\n        break;\n    }\n\n    this._bulletKillType = type;\n\n    validateConfig(this, 'bulletKillType');\n  }\n\n  /**\n   * This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.\n   * It's used in combination with {@link #bulletKillType} when that is set to either `consts.KILL_WEAPON_BOUNDS`\n   * or `consts.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.\n   * If you are tracking a Sprite or Point then the bounds are centered on that object every frame.\n   *\n   * @type {Phaser.Geom.Rectangle}\n   */\n  get bounds() {\n    return this._bounds;\n  }\n  set bounds(value) {\n    this._bounds = value;\n\n    validateConfig(this, 'bounds');\n  }\n\n  /**\n   * The Rectangle used to calculate the bullet bounds from.\n   *\n   * @type {Phaser.Geom.Rectangle}\n   * @private\n   */\n  get bulletBounds() {\n    return this._bulletBounds;\n  }\n  set bulletBounds(value) {\n    this._bulletBounds = value;\n\n    validateConfig(this, 'bulletBounds');\n  }\n\n  /**\n   * This array stores the frames added via @link #setBulletFrames.\n   *\n   * @type {Array}\n   * @protected\n   */\n  get bulletFrames() {\n    return this._bulletFrames;\n  }\n  set bulletFrames(value) {\n    this._bulletFrames = value;\n\n    validateConfig(this, 'bulletFrames');\n  }\n\n  /**\n   * The index of the frame within {@link #bulletFrames} that is currently being used.\n   * This value is only used if {@link #bulletFrameCycle} is set to `true`.\n   * @type {number}\n   * @private\n   */\n  get bulletFrameIndex() {\n    return this._bulletFrameIndex;\n  }\n  set bulletFrameIndex(value) {\n    this._bulletFrameIndex = value;\n\n    validateConfig(this, 'bulletFrameIndex');\n  }\n\n  /**\n   * The Sprite currently being tracked by the Weapon, if any.\n   * This is set via the {@link #trackSprite} method.\n   *\n   * @type {Phaser.GameObjects.Sprite|Object}\n   */\n  get trackedSprite() {\n    return this._trackedSprite;\n  }\n  set trackedSprite(value) {\n    this._trackedSprite = value;\n\n    validateConfig(this, 'trackedSprite');\n  }\n\n  /**\n   * The Pointer currently being tracked by the Weapon, if any.\n   * This is set via the {@link #trackPointer} method.\n   *\n   * @type {Phaser.Input.Pointer}\n   */\n  get trackedPointer() {\n    return this._trackedPointer;\n  }\n  set trackedPointer(value) {\n    this._trackedPointer = value;\n\n    validateConfig(this, 'trackedPointer');\n  }\n\n  /**\n   * If you want this Weapon to be able to fire more than 1 bullet in a single\n   * update, then set this property to `true`. When `true` the Weapon plugin won't\n   * set the shot / firing timers until the `postRender` phase of the game loop.\n   * This means you can call `fire` (and similar methods) as often as you like in one\n   * single game update.\n   *\n   * @type {boolean}\n   * @default\n   */\n  get multiFire() {\n    return this._multiFire;\n  }\n  set multiFire(value) {\n    this._multiFire = value;\n\n    validateConfig(this, 'multiFire');\n  }\n\n  /**\n   * If the Weapon is tracking a Sprite, should it also track the Sprites rotation?\n   * This is useful for a game such as Asteroids, where you want the weapon to fire based\n   * on the sprites rotation.\n   *\n   * @type {boolean}\n   * @default\n   */\n  get trackRotation() {\n    return this._trackRotation;\n  }\n  set trackRotation(value) {\n    this._trackRotation = value;\n\n    validateConfig(this, 'trackRotation');\n  }\n\n  /**\n   * The Track Offset is a Vector2 object that allows you to specify a pixel offset that bullets use\n   * when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels\n   * in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have\n   * the bullet launched from the center of the Sprite.\n   *\n   * @type {Phaser.Math.Vector2}\n   */\n  get trackOffset() {\n    return this._trackOffset;\n  }\n  set trackOffset(value) {\n    this._trackOffset = value;\n\n    validateConfig(this, 'trackOffset');\n  }\n\n  /**\n   * The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and\n   * can be overridden by the {@link #fire} arguments.\n   *\n   * @property {number} x\n   */\n  get x() {\n    return this.fireFrom.x;\n  }\n  set x(value) {\n    this.fireFrom.x = value;\n  }\n\n  /**\n   * The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and\n   * can be overridden by the {@link #fire} arguments.\n   *\n   * @property {number} y\n   */\n  get y() {\n    return this.fireFrom.y;\n  }\n  set y(value) {\n    this.fireFrom.y = value;\n  }\n\n  /**\n   * This method performs two actions: First it will check to see if the\n   * {@link #bullets} Group exists or not, and if not it creates it, adding its\n   * children to the `group` given as the 4th argument.\n   *\n   * Then it will seed the bullet pool with the `quantity` number of Bullets,\n   * using the texture key and frame provided (if any).\n   *\n   * If for example you set the quantity to be 10, then this Weapon will only\n   * ever be able to have 10 bullets in-flight simultaneously. If you try to\n   * fire an 11th bullet then nothing will happen until one, or more, of the\n   * in-flight bullets have been killed, freeing them up for use by the Weapon\n   * again.\n   *\n   * If you do not wish to have a limit set, then pass in -1 as the quantity.\n   * In this instance the Weapon will keep increasing the size of the bullet\n   * pool as needed. It will never reduce the size of the pool however, so be\n   * careful it doesn't grow too large.\n   *\n   * You can either set the texture key and frame here, or via the\n   * {@link #bulletKey} and {@link #bulletFrame} properties. You can also\n   * animate bullets, or set them to use random frames. All Bullets belonging\n   * to a single Weapon instance must share the same texture key however.\n   *\n   * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon\n   *  with. If -1 it will set the pool to automatically expand.\n   * @param {string} [key] - The Game.cache key of the image that this Sprite\n   *  will use.\n   * @param {integer|string} [frame] - If the Sprite image contains multiple\n   *  frames you can specify which one to use here.\n   * @param {Phaser.GameObjects.Group} [group] - Optional Group to add the\n   *  object to. If not specified it will be added to the World group.\n   * @return {Weapon} This Weapon instance.\n   */\n  createBullets(quantity = 1, key, frame, group, bulletClass) {\n    if (bulletClass) {\n      this._bulletClass = bulletClass;\n    }\n\n    if (this.bullets && !this.bullets.scene) {\n      this.bullets = null;\n    }\n\n    if (!this.bullets) {\n      this.bullets = this.scene.add.group({\n        classType: this._bulletClass,\n        maxSize: quantity,\n        runChildUpdate: true,\n      });\n    }\n\n    if (quantity !== 0) {\n      if (quantity === -1) {\n        this.autoExpandBulletsGroup = true;\n        quantity = 1;\n      }\n\n      this.bullets.createMultiple({\n        key,\n        frame,\n        repeat: quantity,\n        active: false,\n        visible: false,\n      });\n\n      this.bullets.children.each(function(child) {\n        child.setData('bulletManager', this);\n      }, this);\n\n      this.bulletKey = key;\n      this.bulletFrame = frame;\n\n      if (group) {\n        group.addMultiple(this.bullets.children.entries);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Call a function on each in-flight bullet in this Weapon.\n   *\n   * See {@link Phaser.GameObjects.Group#forEachExists forEachExists} for more details.\n   *\n   * @param {function} callback - The function that will be called for each applicable child.\n   * The child will be passed as the first argument.\n   * @param {object} callbackContext - The context in which the function should be called (usually 'this').\n   * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n   * @return {Weapon} This Weapon instance.\n   */\n  forEach(callback, callbackContext) {\n    const extraArgs = arguments;\n\n    this.bullets.children.each(child => {\n      if (child.active) {\n        callback.call(callbackContext, child, extraArgs);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `false` on each bullet in this Weapon.\n   * This has the effect of stopping them in-flight should they be moving.\n   * It also stops them being able to be checked for collision.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  pauseAll() {\n    this.bullets.children.each(child => {\n      child.body.enable = false;\n      if (child.getData('timeEvent') !== null) {\n        child.getData('timeEvent').paused = true;\n      }\n    }, this);\n\n    return this;\n  }\n\n  /**\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `true` on each bullet in this Weapon.\n   * This has the effect of resuming their motion should they be in-flight.\n   * It also enables them for collision checks again.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  resumeAll() {\n    this.bullets.children.each(child => {\n      child.body.enable = true;\n      if (child.getData('timeEvent') !== null) {\n        child.getData('timeEvent').paused = false;\n      }\n    }, this);\n\n    return this;\n  }\n\n  /**\n   * Calls {@link Phaser.Bullet#kill} on every in-flight bullet in this Weapon.\n   * Also re-enables their physics bodies, should they have been disabled via {@link #pauseAll}.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  killAll() {\n    this.bullets.children.each(child => {\n      if (child.active) {\n        child.kill();\n      }\n      child.body.enable = true;\n    });\n\n    return this;\n  }\n\n  /**\n   * Resets the {@link #shots} counter back to zero. This is used when you've set\n   * {@link #fireLimit} and have hit (or just wish to reset) your limit.\n   *\n   * @param {integer} [newLimit] - Optionally set a new {@link #fireLimit}.\n   * @return {Weapon} This Weapon instance.\n   */\n  resetShots(newLimit) {\n    this.shots = 0;\n\n    if (newLimit !== undefined) {\n      this.fireLimit = newLimit;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets this Weapon to track the given Sprite, or any Object with a public {@link Phaser.Component.Core#world world}\n   * Point object. When a Weapon tracks a Sprite it will automatically update its {@link #fireFrom} value to match the\n   * Sprite's position within the Game World, adjusting the coordinates based on the offset arguments.\n   *\n   * This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.\n   *\n   * Calling `trackSprite` will reset {@link #trackedPointer} to null, should it have been set, as you can\n   * only track _either_ a Sprite, or a Pointer, at once, but not both.\n   *\n   * @param {Phaser.GameObjects.Sprite|Object} sprite - The Sprite to track the position of.\n   * @param {integer} [offsetX=0] - The horizontal offset from the Sprites position to be applied to the Weapon.\n   * @param {integer} [offsetY=0] - The vertical offset from the Sprites position to be applied to the Weapon.\n   * @param {boolean} [trackRotation=false] - Should the Weapon also track the Sprites rotation?\n   * @return {Weapon} This Weapon instance.\n   */\n  trackSprite(sprite, offsetX = 0, offsetY = 0, trackRotation = false) {\n    this.trackedPointer = null;\n    this.trackedSprite = sprite;\n    this.trackRotation = trackRotation;\n\n    this.trackOffset.set(offsetX, offsetY);\n\n    return this;\n  }\n\n  /**\n   * Sets this Weapon to track the given Pointer.\n   * When a Weapon tracks a Pointer it will automatically update its {@link #fireFrom} value to match the Pointer's\n   * position within the Game World, adjusting the coordinates based on the offset arguments.\n   *\n   * This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.\n   *\n   * Calling `trackPointer` will reset {@link #trackedSprite} to null, should it have been set, as you can\n   * only track _either_ a Pointer, or a Sprite, at once, but not both.\n   *\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to track the position of.\n   * Defaults to `Input.activePointer` if not specified.\n   * @param {integer} [offsetX=0] - The horizontal offset from the Pointers position to be applied to the Weapon.\n   * @param {integer} [offsetY=0] - The vertical offset from the Pointers position to be applied to the Weapon.\n   * @return {Weapon} This Weapon instance.\n   */\n  trackPointer(pointer, offsetX = 0, offsetY = 0) {\n    if (pointer === undefined && this.scene.input) {\n      pointer = this.scene.input.activePointer;\n    }\n\n    this.trackedPointer = pointer;\n    this.trackedSprite = null;\n    this.trackRotation = false;\n\n    this.trackOffset.set(offsetX, offsetY);\n\n    return this;\n  }\n\n  /**\n   * Attempts to fire multiple bullets from the positions defined in the given array.\n   *\n   * If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then\n   * the positions are treated as __offsets__ from the given objects position.\n   *\n   * If `from` is undefined, and there is no tracked object, then the bullets are fired\n   * from the given positions, as they exist in the world.\n   *\n   * Calling this method sets {@link #multiFire} to `true`.\n   *\n   * If there are not enough bullets available in the pool, and the pool cannot be extended,\n   * then this method may not fire from all of the given positions.\n   *\n   * When the bullets are launched they have their texture and frame updated, as required.\n   * The velocity of the bullets are calculated based on Weapon properties like {@link #bulletSpeed}.\n   *\n   * @param {array} positions - An array of positions. Each position can be any Object,\n   * as long as it has public `x` and `y` properties, such as Phaser.Point, { x: 0, y: 0 }, Phaser.Sprite, etc.\n   * @param {Phaser.GameObject.Sprite|Phaser.Math.Vector2|Object|string} [from]\n   * Optionally fires the bullets **from** the `x` and `y` properties of this object,\n   * _instead_ of any {@link #trackedSprite} or `trackedPointer` that is set.\n   * @return {array} An array containing all of the fired Phaser.Bullet objects,\n   * if a launch was successful, otherwise an empty array.\n   */\n  fireMany(positions, from) {\n    this.multiFire = true;\n\n    const bullets = [];\n\n    if (from || this.trackedSprite || this.trackedPointer) {\n      positions.forEach(offset => {\n        bullets.push(this.fire(from, null, null, offset.x, offset.y));\n      });\n    } else {\n      positions.forEach(position => {\n        bullets.push(this.fire(position));\n      });\n    }\n\n    return bullets;\n  }\n\n  /**\n   * Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset\n   * to the position first. This is the same as calling {@link #fire} and passing in the offset arguments.\n   *\n   * If there are no more bullets available in the pool, and the pool cannot be extended,\n   * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n   * the Weapon was fired, as defined in the {@link #fireRate} property.\n   *\n   * Otherwise the first available bullet is selected, launched, and returned.\n   *\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n   * calculated based on Weapon properties like {@link #bulletSpeed}.\n   *\n   * If you wish to fire multiple bullets in a single game update, then set {@link #multiFire} to `true`\n   * and you can call this method as many times as you like, per loop. See also {@link #fireMany}.\n   *\n   * @param {number} [offsetX=0] - The horizontal offset from the position of the tracked Sprite or Pointer,\n   * as set with {@link #trackSprite}.\n   * @param {number} [offsetY=0] - The vertical offset from the position of the tracked Sprite or Pointer,\n   * as set with {@link #trackSprite}.\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n   */\n  fireOffset(offsetX = 0, offsetY = 0) {\n    return this.fire(null, null, null, offsetX, offsetY);\n  }\n\n  /**\n   * Fires a bullet **at** the given Pointer. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtPointer(pointer) {\n    if (pointer === undefined && this.scene.input) {\n      pointer = this.scene.input.activePointer;\n    }\n\n    return this.fire(null, pointer.x, pointer.y);\n  }\n\n  /**\n   * Fires a bullet **at** the given Sprite. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {Phaser.GameObjects.Sprite} [sprite] - The Sprite to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtSprite(sprite) {\n    return this.fire(null, sprite.x, sprite.y);\n  }\n\n  /**\n   * Fires a bullet **at** the given coordinates. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet towards.\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtXY(x, y) {\n    return this.fire(null, x, y);\n  }\n\n  /**\n   * Attempts to fire a single Bullet. If there are no more bullets available in the pool,\n   * and the pool cannot be extended, then this method returns `null`. It will also return `null`\n   * if not enough time has expired since the last time the Weapon was fired,\n   * as defined in the {@link #fireRate} property.\n   *\n   * Otherwise the first available bullet is selected, launched, and returned.\n   *\n   * The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.\n   *\n   * If you don't provide any of the arguments then it uses those set via properties such as {@link #trackedSprite},\n   * {@link #bulletAngle} and so on.\n   *\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n   * calculated based on Weapon properties like `bulletSpeed`.\n   *\n   * If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`\n   * and you can call `fire` as many times as you like, per loop. Multiple fires in a single update\n   * only counts once towards the `shots` total, but you will still receive a Signal for each bullet.\n   *\n   * @param {Phaser.GameObjects.Sprite|Phaser.Math.Vector2|Object|string} [from]\n   * Optionally fires the bullet **from** the `x` and `y` properties of this object.\n   * If set this overrides {@link #trackedSprite} or `trackedPointer`. Pass `null` to ignore it.\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet **towards**.\n   * If left as `undefined`, or `null`, the bullet direction is based on its angle.\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet **towards**.\n   * If left as `undefined`, or `null`, the bullet direction is based on its angle.\n   * @param {number} [offsetX=0] - If the bullet is fired from a tracked Sprite or Pointer,\n   * or the `from` argument is set, this applies a horizontal offset from the launch position.\n   * @param {number} [offsetY=0] - If the bullet is fired from a tracked Sprite or Pointer,\n   * or the `from` argument is set, this applies a vertical offset from the launch position.\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n   */\n  fire(from, x = null, y = null, offsetX = 0, offsetY = 0) {\n    if (\n      this.scene.time.now < this._nextFire ||\n      (this.fireLimit > 0 && this.shots === this.fireLimit)\n    ) {\n      return null;\n    }\n\n    let speed = this.bulletSpeed;\n\n    //  Apply +- speed variance\n    if (this.bulletSpeedVariance !== 0) {\n      speed += Phaser.Math.Between(\n        -this.bulletSpeedVariance,\n        this.bulletSpeedVariance\n      );\n    }\n\n    // Position the fireFrom rectangle\n    if (from) {\n      // Fire based on passed coordinates\n      this.updateFireFrom(from.x, from.y);\n    } else if (this.trackedSprite) {\n      // Fire based on tracked sprite\n      if (this.trackRotation) {\n        this._rotatedPoint.set(\n          this.trackedSprite.x + this.trackOffset.x,\n          this.trackedSprite.y + this.trackOffset.y\n        );\n        Phaser.Math.RotateAround(\n          this._rotatedPoint,\n          this.trackedSprite.x,\n          this.trackedSprite.y,\n          this.trackedSprite.rotation\n        );\n\n        this.updateFireFrom(this._rotatedPoint.x, this._rotatedPoint.y);\n      } else {\n        this.updateFireFrom(this.trackedSprite.x, this.trackedSprite.y);\n      }\n\n      if (this.bulletInheritSpriteSpeed) {\n        speed += this.trackedSprite.body.speed;\n      }\n    } else if (this.trackedPointer) {\n      // Fire based on tracked pointer\n      this.updateFireFrom(this.trackedPointer.x, this.trackedPointer.y);\n    }\n\n    // Take offset into account\n    this.fireFrom.x += offsetX;\n    this.fireFrom.y += offsetY;\n\n    // Pick a random coordinate inside the fireFrom rectangle\n    const randomX = this.fireFrom.x + Math.random() * this.fireFrom.width;\n    const randomY = this.fireFrom.y + Math.random() * this.fireFrom.height;\n\n    const fromX = this.fireFrom.width > 1 ? randomX : this.fireFrom.x;\n    const fromY = this.fireFrom.height > 1 ? randomY : this.fireFrom.y;\n\n    let angle = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;\n\n    //  The position (in world space) to fire the bullet towards, if set\n    if (x !== null && y !== null) {\n      angle = Phaser.Math.RadToDeg(Math.atan2(y - fromY, x - fromX));\n    }\n\n    //  Apply +- angle variance\n    if (this.bulletAngleVariance !== 0) {\n      angle += Phaser.Math.Between(\n        -this.bulletAngleVariance,\n        this.bulletAngleVariance\n      );\n    }\n\n    let moveX = 0;\n    let moveY = 0;\n\n    //  Avoid unnecessary sin/cos for right-angled shots\n    if (angle === 0 || angle === 180) {\n      // Only cos needed\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n    } else if (angle === 90 || angle === 270) {\n      // Only sin needed\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    } else {\n      // Need to calculate both\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    }\n\n    let bullet = null;\n\n    // Attempt to get a bullet instance to use\n    if (this.autoExpandBulletsGroup) {\n      bullet = this.bullets.getFirstDead(\n        true,\n        fromX,\n        fromY,\n        this.bulletKey,\n        this.bulletFrame\n      );\n      bullet.setData('bulletManager', this);\n    } else {\n      bullet = this.bullets.getFirstDead(false);\n    }\n\n    // Prepare and fire the bullet\n    if (bullet) {\n      bullet.prepare(fromX, fromY);\n      bullet.setData({\n        fromX,\n        fromY,\n        killType: this.bulletKillType,\n        killDistance: this.bulletKillDistance,\n        rotateToVelocity: this.bulletRotateToVelocity,\n      });\n\n      // Prepare timer for bullet lifespan\n      if (this.bulletKillType === consts.KILL_LIFESPAN) {\n        bullet.setData(\n          'timeEvent',\n          this.scene.time.addEvent({\n            delay: this.bulletLifespan,\n            callback: bullet.kill,\n            callbackScope: bullet,\n          })\n        );\n        bullet.lifespan = this.bulletLifespan;\n      }\n\n      bullet.angle = angle + this.bulletAngleOffset;\n\n      //  Frames and Animations\n      if (this.bulletAnimation) {\n        bullet.anims.play(this.bulletAnimation);\n      } else if (this.bulletFrameCycle) {\n        // Calculate bullet frame to use\n        if (this.bulletFrameIndex >= this.bulletFrames.length) {\n          this.bulletFrameIndex = 0;\n        }\n        bullet.setTexture(this.bulletKey, this.bulletFrameIndex);\n        this.bulletFrameIndex++;\n      } else if (this.bulletFrameRandom) {\n        // Pick a bullet frame at random\n        const nextFrame = Math.floor(Math.random() * this.bulletFrames.length);\n        bullet.setTexture(this.bulletKey, nextFrame);\n      }\n\n      // Set correct size and position for bullet body\n      if (bullet.getData('bodyDirty')) {\n        if (this._data.customBody) {\n          bullet.body.setSize(this._data.width, this._data.height);\n          bullet.body.setOffset(this._data.offsetX, this._data.offsetY);\n        }\n\n        bullet.body.collideWorldBounds = this.bulletCollideWorldBounds;\n\n        bullet.setData('bodyDirty', false);\n      }\n\n      bullet.body.setVelocity(moveX, moveY);\n      bullet.body.setGravity(this.bulletGravity.x, this.bulletGravity.y);\n\n      let next = 0;\n\n      // Calculate when to fire next bullet, taking into account speed variance\n      if (this.bulletSpeedVariance !== 0) {\n        let rate = this.fireRate;\n\n        rate += Phaser.Math.Between(\n          -this.fireRateVariance,\n          this.fireRateVariance\n        );\n\n        if (rate < 0) {\n          rate = 0;\n        }\n\n        next = this.scene.time.now + rate;\n      } else {\n        next = this.scene.time.now + this.fireRate;\n      }\n\n      // Prepare for next shot\n      if (this.multiFire) {\n        if (!this._hasFired) {\n          //  We only add 1 to the 'shots' count for multiFire shots\n          this._hasFired = true;\n          this._tempNextFire = next;\n          this.shots++;\n        }\n      } else {\n        this._nextFire = next;\n\n        this.shots++;\n      }\n\n      // Emit events\n      this.eventEmitter.emit('fire', bullet, this, speed);\n\n      if (this.fireLimit > 0 && this.shots === this.fireLimit) {\n        this.eventEmitter.emit('firelimit', this, this.fireLimit);\n      }\n    }\n\n    return bullet;\n  }\n\n  /**\n   * Set the fireFrom rectangle based on passed coords\n   * @private\n   * @param {number} x - X coordinate for where to fire from\n   * @param {number} y - Y coordinate for where to fire from\n   * @return {void}\n   */\n  updateFireFrom(x, y) {\n    if (this.fireFrom.width > 1) {\n      // If size is larger than 1, center on coordinates\n      Phaser.Geom.Rectangle.CenterOn(\n        this.fireFrom,\n        x + this.trackOffset.x,\n        y + this.trackOffset.y\n      );\n    } else {\n      this.fireFrom.x = x + this.trackOffset.x;\n      this.fireFrom.y = y + this.trackOffset.y;\n    }\n  }\n\n  /**\n   * You can modify the size of the physics Body the Bullets use to be any dimension you need.\n   * This allows you to make it smaller, or larger, than the parent Sprite.\n   * You can also control the x and y offset of the Body. This is the position of the\n   * Body relative to the top-left of the Sprite _texture_.\n   *\n   * For example: If you have a Sprite with a texture that is 80x100 in size,\n   * and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:\n   *\n   * `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`\n   *\n   * Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.\n   * 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34\n   * is the vertical offset.\n   *\n   * @param {number} width - The width of the Body.\n   * @param {number} height - The height of the Body.\n   * @param {number} [offsetX=0] - The X offset of the Body from the top-left of the Sprites texture.\n   * @param {number} [offsetY=0] - The Y offset of the Body from the top-left of the Sprites texture.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  setBulletBodyOffset(width, height, offsetX = 0, offsetY = 0) {\n    this._data.customBody = true;\n    this._data.width = width;\n    this._data.height = height;\n    this._data.offsetX = offsetX;\n    this._data.offsetY = offsetY;\n\n    //  Update all bullets in the pool\n    this.bullets.children.each(child => {\n      child.body.setSize(width, height);\n      child.body.setOffset(offsetX, offsetY);\n      child.setData('bodyDirty', false);\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets the texture frames that the bullets can use when being launched.\n   *\n   * This is intended for use when you've got numeric based frames, such as\n   * those loaded via a Sprite Sheet.\n   *\n   * It works by calling `Phaser.Utils.Array.NumberArray` internally, using\n   * the min and max values provided. Then it sets the frame index to be zero.\n   *\n   * You can optionally set the cycle and random booleans, to allow bullets to\n   * cycle through the frames when they're fired, or pick one at random.\n   *\n   * @param {integer} min - The minimum value the frame can be. Usually zero.\n   * @param {integer} max - The maximum value the frame can be.\n   * @param {integer} [selcetionMethod=BULLET_FRAME_STABLE] - Specifies how the\n   *  frame for the fired bullet will be selected. See consts.BULLET_FRAME_XYZ\n   *  for options.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  setBulletFrames(min, max, selectionMethod = consts.BULLET_FRAME_STABLE) {\n    if (\n      typeof selectionMethod !== 'number' ||\n      selectionMethod < consts.BULLET_FRAME_STABLE ||\n      selectionMethod > consts.BULLET_FRAME_RANDOM\n    ) {\n      log(\n        `Invalid bullet frame selection method specified: ${selectionMethod}`,\n        this.logLevel\n      );\n    }\n\n    if (min > max) {\n      log(`min frame (${min}) must be <= max frame (${max})`, this.logLevel);\n    }\n\n    this.bulletFrames = Phaser.Utils.Array.NumberArray(min, max);\n    this.bulletFrameIndex = 0;\n    this.bulletFrameCycle = selectionMethod === consts.BULLET_FRAME_CYCLE;\n    this.bulletFrameRandom = selectionMethod === consts.BULLET_FRAME_RANDOM;\n\n    return this;\n  }\n\n  /**\n   * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n   * The arguments are all the same as for `Animation.add`, and work in the same way.\n   *\n   * {@link #bulletAnimation} will be set to this animation after it's created. From that point on, all\n   * bullets fired will play using this animation. You can swap between animations by calling this method\n   * several times, and then just changing the {@link #bulletAnimation} property to the name of the animation\n   * you wish to play for the next launched bullet.\n   *\n   * If you wish to stop using animations at all, set {@link #bulletAnimation} to '' (an empty string).\n   *\n   * @param {string} name - The unique (within the Weapon instance) name for the animation, i.e. \"fire\", \"blast\".\n   * @param {Array} [frames=null] - An array of numbers/strings that correspond to the framesto add to this animation\n   * and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n   * @param {number} [frameRate=60] - The speed at which the animation should play.\n   * The speed is given in frames per second.\n   * @param {number} [loop=1] - Number of times to repeat the animation. Set to -1 to repeat forever.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  addBulletAnimation(name, frames, frameRate, loop) {\n    if (!this.scene.sys.anims.anims.contains(name)) {\n      this.scene.sys.anims.create({\n        key: name,\n        frames,\n        frameRate,\n        loop,\n      });\n\n      this.anims[name] = this.scene.sys.anims.anims.entries[name];\n    }\n\n    this.bulletAnimation = name;\n\n    return this;\n  }\n\n  /**\n   * Internal update method, called by the Weapon Plugin.\n   * @returns {void}\n   */\n  update() {\n    if (this._bulletKillType === consts.KILL_WEAPON_BOUNDS) {\n      if (this.trackedSprite) {\n        this.trackedSprite.updateTransform();\n        Phaser.Geom.Rectangle.CenterOn(\n          this.bounds,\n          this.trackedSprite.x,\n          this.trackedSprite.y\n        );\n      } else if (this.trackedPointer) {\n        Phaser.Geom.Rectangle.CenterOn(\n          this.bounds,\n          this.trackedPointer.x,\n          this.trackedPointer.y\n        );\n      }\n    }\n\n    if (this.autofire) {\n      this.fire();\n    }\n  }\n\n  /**\n   * Internal update method, called by the Weapon Plugin.\n   *\n   * @protected\n   * @returns {void}\n   */\n  postRender() {\n    if (!this.multiFire || !this._hasFired) {\n      return;\n    }\n\n    this._hasFired = false;\n\n    this._nextFire = this._tempNextFire;\n  }\n\n  /**\n   * Destroys this Weapon.\n   * You must release everything in here, all references, all objects, free it all up.\n   * @returns {void}\n   */\n  destroy() {\n    this.scene = null;\n\n    this.bullets.destroy(true);\n  }\n}\n\nexport default Weapon;\n","import consts from './consts';\n\nlet bulletID = 0;\n\nclass Bullet extends Phaser.GameObjects.Sprite {\n  /**\n   * Create a new `Bullet` object. Bullets are used by the `Weapon` class, and are normal Sprites,\n   * with a few extra properties in the data manager to handle Weapon specific features.\n   *\n   * @param {Phaser.Scene} scene - A reference to the currently running scene.\n   * @param {number} x - The x coordinate (in world space) to position the Particle at.\n   * @param {number} y - The y coordinate (in world space) to position the Particle at.\n   * @param {string} key - This is the image or texture used by the Particle during rendering.\n   * It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas\n   * you can specify the exact frame to use by giving a string or numeric index.\n   */\n  constructor(scene, x, y, key, frame) {\n    super(scene, x, y, key, frame);\n    this.bulletID = bulletID;\n    bulletID++;\n    this.scene.physics.add.existing(this);\n\n    this.setDataEnabled();\n\n    this.setData({\n      timeEvent: null,\n      bulletManager: null,\n      fromX: 0,\n      fromY: 0,\n      bodyDirty: true,\n      rotateToVelocity: false,\n      killType: 0,\n      killDistance: 0,\n      bodyBounds: new Phaser.Geom.Rectangle(),\n    });\n  }\n\n  /**\n   * Prepares this bullet to be fired and interact with the rest of the scene\n   * again.\n   * @returns {void}\n   */\n  prepare(x, y) {\n    this.setActive(true);\n    this.setVisible(true);\n    this.body.enable = true;\n    this.body.reset(x, y);\n    this.body.debugShowBody = this.getData('bulletManager').debugPhysics;\n    this.body.debugShowVelocity = this.getData('bulletManager').debugPhysics;\n  }\n\n  /**\n   * Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.\n   * Also dispatches the `Weapon`s kill signal.\n   * @returns {Bullet} This instance of the bullet class\n   */\n  kill() {\n    // Reproduce Phaser.Physics.Arcade.Components.Enable.disableBody because\n    // we can't assume that the bullet class has it built in.\n    this.body.stop();\n    this.body.enable = false;\n    this.setActive(false);\n    this.setVisible(false);\n    this.body.debugShowBody = false;\n    this.body.debugShowVelocity = false;\n\n    // TODO: potentially we don't need to destroy the time event and we can\n    // just pause when the bullet is killed and restart it when it's refired.\n    // For now though do the simple thing and discard it.\n    // Another option would be to use Date.now() and manually process pause\n    // events with a flag and some math.\n    // Both of those are probably premature optimizations.\n    if (this.getData('timeEvent') !== null) {\n      this.getData('timeEvent').destroy();\n      this.setData('timeEvent', null);\n    }\n\n    this.getData('bulletManager').eventEmitter.emit('kill', this);\n\n    return this;\n  }\n\n  /**\n   * Updates the Bullet, killing as required.\n   * @returns {Bullet} This instance of the bullet class\n   */\n  update() {\n    if (!this.active) {\n      // this was previously a check to this.exists\n      return;\n    }\n\n    if (this.getData('killType') > consts.KILL_LIFESPAN) {\n      if (this.getData('killType') === consts.KILL_DISTANCE) {\n        if (\n          new Phaser.Math.Vector2(\n            this.getData('fromX'),\n            this.getData('fromY')\n          ).distance(this) > this.getData('killDistance')\n        ) {\n          this.kill();\n        }\n      } else if (\n        !Phaser.Geom.Intersects.RectangleToRectangle(\n          this.getData('bulletManager').bulletBounds,\n          this.body.getBounds(this.getData('bodyBounds'))\n        )\n      ) {\n        this.kill();\n      }\n    }\n\n    if (this.getData('rotateToVelocity')) {\n      this.rotation = this.body.velocity.atan();\n    }\n\n    if (this.getData('bulletManager').bulletWorldWrap) {\n      this.scene.physics.world.wrap(\n        this,\n        this.getData('bulletManager').bulletWorldWrapPadding\n      );\n    }\n  }\n}\n\nexport default Bullet;\n","export default {\n  /**\n   * A {@link #bulletKillType} constant that stops the bullets from ever being destroyed automatically.\n   * @constant\n   * @type {integer}\n   */\n  KILL_NEVER: 0,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when their {@link #bulletLifespan} expires.\n   * @constant\n   * @type {integer}\n   */\n  KILL_LIFESPAN: 1,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets after they\n   * exceed the {@link #bulletDistance} from their original firing position.\n   * @constant\n   * @type {integer}\n   */\n  KILL_DISTANCE: 2,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WEAPON_BOUNDS: 3,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link Phaser.Camera#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_CAMERA_BOUNDS: 4,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link Phaser.World#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WORLD_BOUNDS: 5,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets\n   * when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_STATIC_BOUNDS: 6,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face up.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_UP: 270,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face down.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_DOWN: 90,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face left.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_LEFT: 180,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face right.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_RIGHT: 0,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\n   * @constant Phaser.ANGLE_NORTH_EAST\n   * @type {integer}\n   */\n  ANGLE_NORTH_EAST: 315,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_NORTH_WEST: 225,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_EAST: 45,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_WEST: 135,\n\n  /**\n   * When selecting a bullet frame the same frame should always be used. This\n   * is the default value.\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_STABLE: 0,\n\n  /**\n   * When selecting a bullet frame the next frame should be used\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_CYCLE: 1,\n\n  /**\n   * When selecting a bullet frame a random frame should be used.\n   * @constant\n   * @type { integer }\n   */\n  BULLET_FRAME_RANDOM: 2,\n};\n","import consts from './consts';\n\n/**\n * Log text to the console or throw an error\n * @param {string} text - Text to be logged\n * @param {string} logLevel - The log level, either `warn`, `error' or `off`\n */\nfunction log(text, logLevel) {\n  if (logLevel === 'warn') {\n    console.warn(text);\n  } else if (logLevel === 'error') {\n    throw new Error(text);\n  }\n}\n\n/**\n * Check the config of the weapon for common errors and weird configurations.\n * @param {Weapon} weapon - The weapon being validated\n * @param {string} property - The property of the weapon being validated\n */\nfunction validateConfig(weapon, property) {\n  if (\n    ['bulletWorldWrap', 'bulletKillType'].includes(property) &&\n    weapon.bulletWorldWrap &&\n    (weapon.bulletKillType === consts.KILL_WORLD_BOUNDS ||\n      weapon.bulletKillType === consts.KILL_WEAPON_BOUNDS)\n  ) {\n    log(\n      'Warning: KILL_WORLD_BOUNDS and KILL_WEAPON_BOUNDS does not work well with bulletWorldWrap set to true.',\n      weapon.logLevel\n    );\n  }\n  if (\n    ['bulletKillType', 'bulletLifespan'].includes(property) &&\n    weapon.bulletKillType === consts.KILL_LIFESPAN &&\n    weapon.bulletLifespan < 0\n  ) {\n    log(\n      'Invalid bulletLifespan; must be > 0; currently ' + weapon.bulletLifespan,\n      weapon.logLevel\n    );\n  }\n  if (\n    [\n      'fireLimit',\n      'fireRate',\n      'fireRateVariance',\n      'bulletAngleVariance',\n      'bulletSpeedVariance',\n      'bulletKillDistance',\n    ].includes(property) &&\n    weapon[property] < 0\n  ) {\n    log(\n      'Invalid ' + property + '; must be >= 0; currently ' + weapon[property],\n      weapon.logLevel\n    );\n  }\n}\n\nexport { log };\nexport default validateConfig;\n"],"sourceRoot":""}