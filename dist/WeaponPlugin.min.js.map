{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///WeaponPlugin.min.js","webpack:///webpack/bootstrap 944b478c7a45f5608d57","webpack:///./consts.js","webpack:///./Bullet.js","webpack:///./main.js","webpack:///./Weapon.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","KILL_NEVER","KILL_LIFESPAN","KILL_DISTANCE","KILL_WEAPON_BOUNDS","KILL_CAMERA_BOUNDS","KILL_WORLD_BOUNDS","KILL_STATIC_BOUNDS","ANGLE_UP","ANGLE_DOWN","ANGLE_LEFT","ANGLE_RIGHT","ANGLE_NORTH_EAST","ANGLE_NORTH_WEST","ANGLE_SOUTH_EAST","ANGLE_SOUTH_WEST","_typeof","obj","Symbol","iterator","constructor","_classCallCheck","instance","Constructor","TypeError","_inherits","subClass","superClass","_setPrototypeOf","setPrototypeOf","__proto__","_defineProperties","target","props","length","descriptor","writable","key","_createClass","protoProps","staticProps","_possibleConstructorReturn","_assertThisInitialized","_getPrototypeOf","getPrototypeOf","ReferenceError","consts","bulletID","Bullet","_Phaser$GameObjects$S","scene","x","y","frame","_this","physics","add","existing","data","timeEvent","bulletManager","fromX","fromY","bodyDirty","rotateToVelocity","killType","killDistance","bodyBounds","Phaser","Geom","Rectangle","value","setActive","setVisible","body","enable","reset","debugShowBody","debugPhysics","debugShowVelocity","console","log","concat","stop","destroy","eventEmitter","emit","active","Math","Vector2","distance","kill","Intersects","RectangleToRectangle","bulletBounds","getBounds","rotation","velocity","atan","bulletWorldWrap","world","wrap","bulletWorldWrapPadding","GameObjects","Sprite","Weapon","WeaponPlugin","_Phaser$Plugins$Scene","pluginManager","weapons","bulletLimit","group","weaponClass","weapon","push","on","postRender","systems","events","preUpdate","update","postUpdate","pause","resume","sleep","wake","shutdown","time","delta","forEach","game","Plugins","ScenePlugin","bullets","autoExpandBulletsGroup","autofire","shots","fireLimit","fireRate","fireRateVariance","fireFrom","fireAngle","bulletInheritSpriteSpeed","bulletAnimation","bulletFrameRandom","bulletFrameCycle","bulletAngleOffset","bulletAngleVariance","bulletSpeed","bulletSpeedVariance","bulletLifespan","bulletKillDistance","bulletGravity","bulletRotateToVelocity","bulletKey","bulletFrame","_bulletClass","_bulletCollideWorldBounds","_bulletKillType","_data","customBody","width","height","offsetX","offsetY","bounds","bulletFrames","bulletFrameIndex","anims","trackedSprite","trackedPointer","multiFire","_hasFired","trackRotation","trackOffset","_nextFire","_tempNextFire","_rotatedPoint","Events","EventEmitter","createBullets","quantity","bulletClass","undefined","classType","maxSize","runChildUpdate","createMultiple","repeat","visible","children","each","child","addMultiple","entries","callback","callbackContext","extraArgs","arguments","paused","newLimit","sprite","set","pointer","input","activePointer","positions","from","offset","fire","position","now","speed","Between","CenterOn","RotateAround","randomX","random","randomY","angle","RadToDeg","atan2","moveX","moveY","cos","DegToRad","sin","bullet","getFirstDead","prepare","bulletKillType","Error","addEvent","delay","bind","lifespan","play","floor","setSize","setOffset","collideWorldBounds","bulletCollideWorldBounds","setVelocity","setGravity","next","rate","min","max","cycle","Utils","Array","NumberArray","frames","frameRate","loop","sys","contains","create","debugBodies","updateTransform","centerOn","type","cameras","main","_bounds"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,kBAAAH,GACA,gBAAAC,SACAA,QAAA,aAAAD,IAEAD,EAAA,aAAAC,KACC,mBAAAK,WAAAC,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAR,OAGA,IAAAC,GAAAQ,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAX,WAUA,OANAM,GAAAE,GAAAI,KAAAX,EAAAD,QAAAC,IAAAD,QAAAO,GAGAN,EAAAU,GAAA,EAGAV,EAAAD,QAvBA,GAAAS,KA4DA,OAhCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAAAf,EAAAgB,EAAAC,GACAV,EAAAW,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAM,GAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAjB,KAAAc,EAAAC,IAGtDpB,EAAAuB,EAAA,GAGAvB,IAAAwB,EAAA,KDgBM,SAAU9B,EAAQD,EAASO,GAEjC,YE/EAN,GAAOD,SAMLgC,WAAY,EAOZC,cAAe,EAQfC,cAAe,EAOfC,mBAAoB,EAOpBC,mBAAoB,EAOpBC,kBAAmB,EAOnBC,mBAAoB,EAOpBC,SAAU,IAOVC,WAAY,GAOZC,WAAY,IAOZC,YAAa,EAObC,iBAAkB,IAOlBC,iBAAkB,IAOlBC,iBAAkB,GAOlBC,iBAAkB,MFuFd,SAAU7C,EAAQD,EAASO,GAEjC,YAGA,SAASwC,GAAQC,GAAwT,OAAtOD,EAArD,kBAAXE,SAAoD,gBAApBA,QAAOC,SAAmC,SAAiBF,GAAO,aAAcA,IAA2B,SAAiBA,GAAO,MAAOA,IAAyB,kBAAXC,SAAyBD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOrB,UAAY,eAAkBoB,KAAyBA,GAExV,QAASI,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIH,WAAU,qDAAyDI,GAAgBF,EAAS7B,UAAW8B,GAAcA,EAAW9B,WAAgB8B,GAAYC,EAAgBF,EAAUC,GAE1S,QAASC,GAAgBzC,EAAGY,GAA+G,OAA1G6B,EAAkBxC,OAAOyC,gBAAkB,SAAyB1C,EAAGY,GAAsB,MAAjBZ,GAAE2C,UAAY/B,EAAUZ,IAA6BA,EAAGY,GAErK,QAASgC,GAAkBC,EAAQC,GAAS,IAAK,GAAItD,GAAI,EAAGA,EAAIsD,EAAMC,OAAQvD,IAAK,CAAE,GAAIwD,GAAaF,EAAMtD,EAAIwD,GAAW5C,WAAa4C,EAAW5C,aAAc,EAAO4C,EAAW7C,cAAe,EAAU,SAAW6C,KAAYA,EAAWC,UAAW,GAAMhD,OAAOC,eAAe2C,EAAQG,EAAWE,IAAKF,IAE7S,QAASG,GAAaf,EAAagB,EAAYC,GAAmJ,MAAhID,IAAYR,EAAkBR,EAAY1B,UAAW0C,GAAiBC,GAAaT,EAAkBR,EAAaiB,GAAqBjB,EAEzM,QAASkB,GAA2BpE,EAAMQ,GAAQ,OAAIA,GAA2B,WAAlBmC,EAAQnC,IAAsC,kBAATA,GAA8C6D,EAAuBrE,GAAtCQ,EAEnI,QAAS8D,GAAgBxD,GAAqG,OAAhGwD,EAAkBvD,OAAOwD,gBAAkB,SAAyBzD,GAAK,MAAOA,GAAE2C,YAAqC3C,GAErJ,QAASuD,GAAuBrE,GAAQ,OAAa,KAATA,EAAmB,KAAM,IAAIwE,gBAAe,4DAAgE,OAAOxE;;;;;;AG9M/J,GAAMyE,GAAStE,EAAQ,GAEnBuE,EAAW,EAETC,EHwNN,SAAUC,GG7MR,QAAAD,GAAYE,EAAOC,EAAGC,EAAGf,EAAKgB,GAAO,GAAAC,EAAA,OAAAjC,GAAA/C,KAAA0E,GACnCM,EAAAb,EAAAnE,KAAAqE,EAAAK,GAAAnE,KAAAP,KAAM4E,EAAOC,EAAGC,EAAGf,EAAKgB,IACxBC,EAAKP,SAAWA,EAChBA,IACAO,EAAKJ,MAAMK,QAAQC,IAAIC,SAAvBf,IAAAY,KAEAA,EAAKI,MACHC,UAAW,KACXC,cAAe,KACfC,MAAO,EACPC,MAAO,EACPC,WAAW,EACXC,kBAAkB,EAClBC,SAAU,EACVC,aAAc,EACdC,WAAY,GAAIC,QAAOC,KAAKC,WAfKhB,EHmUrC,MA7EAhB,GAAaU,IACXX,IAAK,UACLkC,MAAO,SGjODpB,EAAGC,GACT9E,KAAKkG,WAAU,GACflG,KAAKmG,YAAW,GAChBnG,KAAKoG,KAAKC,QAAS,EACnBrG,KAAKoG,KAAKE,MAAMzB,EAAGC,GACnB9E,KAAKoG,KAAKG,cAAgBvG,KAAKoF,KAAKE,cAAckB,aAClDxG,KAAKoG,KAAKK,kBAAoBzG,KAAKoF,KAAKE,cAAckB,gBH0OtDzC,IAAK,OACLkC,MAAO,WG1MP,MAxBAS,SAAQC,IAAR,kBAAAC,OAA8B5G,KAAKyE,WAInCzE,KAAKoG,KAAKS,OACV7G,KAAKoG,KAAKC,QAAS,EACnBrG,KAAKkG,WAAU,GACflG,KAAKmG,YAAW,GAChBnG,KAAKoG,KAAKG,eAAgB,EAC1BvG,KAAKoG,KAAKK,mBAAoB,EAQF,OAAxBzG,KAAKoF,KAAKC,YACZrF,KAAKoF,KAAKC,UAAUyB,UACpB9G,KAAKoF,KAAKC,UAAY,MAGxBrF,KAAKoF,KAAKE,cAAcyB,aAAaC,KAAK,OAAQhH,MAE3CA,QHwOP+D,IAAK,SACLkC,MAAO,WGjOFjG,KAAKiH,SAKNjH,KAAKoF,KAAKO,SAAWnB,EAAO5C,gBAC1B5B,KAAKoF,KAAKO,WAAanB,EAAO3C,cAE9B,GAAIiE,QAAOoB,KAAKC,QAAQnH,KAAKoF,KAAKG,MAAOvF,KAAKoF,KAAKI,OAAO4B,SAASpH,MACnEA,KAAKoF,KAAKQ,cAEV5F,KAAKqH,OAEGvB,OAAOC,KAAKuB,WAAWC,qBAC/BvH,KAAKoF,KAAKE,cAAckC,aACxBxH,KAAKoG,KAAKqB,UAAUzH,KAAKoF,KAAKS,cAEhC7F,KAAKqH,QAILrH,KAAKoF,KAAKM,mBACZ1F,KAAK0H,SAAW1H,KAAKoG,KAAKuB,SAASC,QAGjC5H,KAAKoF,KAAKE,cAAcuC,iBAC1B7H,KAAK4E,MAAMK,QAAQ6C,MAAMC,KACvB/H,KACAA,KAAKoF,KAAKE,cAAc0C,6BH+N9B7E,EAAUuB,EAAQC,GAEXD,GG9UYoB,OAAOmC,YAAYC,OAmHxCtI,GAAOD,QAAU+E,GHkOX,SAAU9E,EAAQD,EAASO,GAEjC,YAGA,SAASwC,GAAQC,GAAwT,OAAtOD,EAArD,kBAAXE,SAAoD,gBAApBA,QAAOC,SAAmC,SAAiBF,GAAO,aAAcA,IAA2B,SAAiBA,GAAO,MAAOA,IAAyB,kBAAXC,SAAyBD,EAAIG,cAAgBF,QAAUD,IAAQC,OAAOrB,UAAY,eAAkBoB,KAAyBA,GAExV,QAASI,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIH,WAAU,qDAAyDI,GAAgBF,EAAS7B,UAAW8B,GAAcA,EAAW9B,WAAgB8B,GAAYC,EAAgBF,EAAUC,GAE1S,QAASC,GAAgBzC,EAAGY,GAA+G,OAA1G6B,EAAkBxC,OAAOyC,gBAAkB,SAAyB1C,EAAGY,GAAsB,MAAjBZ,GAAE2C,UAAY/B,EAAUZ,IAA6BA,EAAGY,GAErK,QAASgC,GAAkBC,EAAQC,GAAS,IAAK,GAAItD,GAAI,EAAGA,EAAIsD,EAAMC,OAAQvD,IAAK,CAAE,GAAIwD,GAAaF,EAAMtD,EAAIwD,GAAW5C,WAAa4C,EAAW5C,aAAc,EAAO4C,EAAW7C,cAAe,EAAU,SAAW6C,KAAYA,EAAWC,UAAW,GAAMhD,OAAOC,eAAe2C,EAAQG,EAAWE,IAAKF,IAE7S,QAASG,GAAaf,EAAagB,EAAYC,GAAmJ,MAAhID,IAAYR,EAAkBR,EAAY1B,UAAW0C,GAAiBC,GAAaT,EAAkBR,EAAaiB,GAAqBjB,EAEzM,QAASkB,GAA2BpE,EAAMQ,GAAQ,OAAIA,GAA2B,WAAlBmC,EAAQnC,IAAsC,kBAATA,GAA8C6D,EAAuBrE,GAAtCQ,EAEnI,QAAS6D,GAAuBrE,GAAQ,OAAa,KAATA,EAAmB,KAAM,IAAIwE,gBAAe,4DAAgE,OAAOxE,GAE/J,QAASsE,GAAgBxD,GAAqG,OAAhGwD,EAAkBvD,OAAOwD,gBAAkB,SAAyBzD,GAAK,MAAOA,GAAE2C,YAAqC3C;;;;;;AI/WrJ,GAAMsH,GAASjI,EAAQ,GACjBwE,EAASxE,EAAQ,GACjBsE,EAAStE,EAAQ,GA4BjBkI,EJ4XN,SAAUC,GItXR,QAAAD,GAAYxD,EAAO0D,GAAe,GAAAtD,EAAA,OAAAjC,GAAA/C,KAAAoI,GAChCpD,EAAAb,EAAAnE,KAAAqE,EAAA+D,GAAA7H,KAAAP,KAAM4E,EAAO0D,IAEbtD,EAAKuD,WAH2BvD,EJ0gBlC,MAlIAhB,GAAaoE,IACXrE,IAAK,MACLkC,MAAO,SIjYLuC,EAAazE,EAAKgB,EAAO0D,EAAOC,GAC7BA,IACHA,EAAcP,EAEhB,IAAMQ,GAAS,GAAID,GAAY1I,KAAK4E,MAAO4D,EAAazE,EAAKgB,EAAO0D,EAIpE,OAFAzI,MAAKuI,QAAQK,KAAKD,GAEXA,KJ2YP5E,IAAK,QACLkC,MAAO,WIjYPc,aAAa8B,GAAG,aAAc7I,KAAK8I,WAAY9I,SJ4Y/C+D,IAAK,OACLkC,MAAO,WInYP,GAAMc,GAAe/G,KAAK+I,QAAQC,MAKlCjC,GAAa8B,GAAG,YAAa7I,KAAKiJ,UAAWjJ,MAC7C+G,EAAa8B,GAAG,SAAU7I,KAAKkJ,OAAQlJ,MACvC+G,EAAa8B,GAAG,aAAc7I,KAAKmJ,WAAYnJ,MAE/C+G,EAAa8B,GAAG,QAAS7I,KAAKoJ,MAAOpJ,MACrC+G,EAAa8B,GAAG,SAAU7I,KAAKqJ,OAAQrJ,MAEvC+G,EAAa8B,GAAG,QAAS7I,KAAKsJ,MAAOtJ,MACrC+G,EAAa8B,GAAG,OAAQ7I,KAAKuJ,KAAMvJ,MAEnC+G,EAAa8B,GAAG,WAAY7I,KAAKwJ,SAAUxJ,MAC3C+G,EAAa8B,GAAG,UAAW7I,KAAK8G,QAAS9G,SJmYzC+D,IAAK,YACLkC,MAAO,SIhYCwD,EAAMC,OJ4Yd3F,IAAK,SACLkC,MAAO,SIjYFwD,EAAMC,GACX1J,KAAKuI,QAAQoB,QAAQ,SAAAhB,GACnBA,EAAOO,cJsYTnF,IAAK,aACLkC,MAAO,SIlYEwD,EAAMC,OJ4Yf3F,IAAK,aACLkC,MAAO,WIlYPjG,KAAKuI,QAAQoB,QAAQ,SAAAhB,GACnBA,EAAOG,kBJwYT/E,IAAK,QACLkC,MAAO,eAIPlC,IAAK,SACLkC,MAAO,eAIPlC,IAAK,QACLkC,MAAO,eAIPlC,IAAK,OACLkC,MAAO,eAIPlC,IAAK,WACLkC,MAAO,eASPlC,IAAK,UACLkC,MAAO,WIpYPjG,KAAKsI,cAAgB,KACrBtI,KAAK4J,KAAO,KACZ5J,KAAK4E,MAAQ,KACb5E,KAAK+I,QAAU,SJyYjB5F,EAAUiF,EAAcC,GAEjBD,GIhhBkBtC,OAAO+D,QAAQC,YAyI1C1B,GAAaD,OAASA,EACtBC,EAAa1D,OAASA,EAEtB0D,EAAa5D,OAASA,EAItB5E,EAAOD,QAAUyI,GJ2YX,SAAUxI,EAAQD,EAASO,GAEjC,YAGA,SAAS6C,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASO,GAAkBC,EAAQC,GAAS,IAAK,GAAItD,GAAI,EAAGA,EAAIsD,EAAMC,OAAQvD,IAAK,CAAE,GAAIwD,GAAaF,EAAMtD,EAAIwD,GAAW5C,WAAa4C,EAAW5C,aAAc,EAAO4C,EAAW7C,cAAe,EAAU,SAAW6C,KAAYA,EAAWC,UAAW,GAAMhD,OAAOC,eAAe2C,EAAQG,EAAWE,IAAKF,IAE7S,QAASG,GAAaf,EAAagB,EAAYC,GAAmJ,MAAhID,IAAYR,EAAkBR,EAAY1B,UAAW0C,GAAiBC,GAAaT,EAAkBR,EAAaiB,GAAqBjB;;;;;;AKlkBzM,GAAMyB,GAASxE,EAAQ,GACjBsE,EAAStE,EAAQ,GA2BjBiI,EL8kBN,WKxkBE,QAAAA,GAAYvD,EAAO4D,EAAazE,EAAKgB,EAAO0D,GAAO1F,EAAA/C,KAAAmI,GACjDnI,KAAK4E,MAAQA,EAEb5E,KAAKwG,aAAe,KAMpBxG,KAAK+J,QAAU,KAQf/J,KAAKgK,wBAAyB,EAQ9BhK,KAAKiK,UAAW,EAShBjK,KAAKkK,MAAQ,EASblK,KAAKmK,UAAY,EAOjBnK,KAAKoK,SAAW,IAUhBpK,KAAKqK,iBAAmB,EAQxBrK,KAAKsK,SAAW,GAAIxE,QAAOC,KAAKC,UAAU,EAAG,EAAG,EAAG,GAQnDhG,KAAKuK,UAAY/F,EAAOtC,SAOxBlC,KAAKwK,0BAA2B,EAQhCxK,KAAKyK,gBAAkB,GAQvBzK,KAAK0K,mBAAoB,EAWzB1K,KAAK2K,kBAAmB,EAQxB3K,KAAK6H,iBAAkB,EASvB7H,KAAKgI,uBAAyB,EAU9BhI,KAAK4K,kBAAoB,EAUzB5K,KAAK6K,oBAAsB,EAO3B7K,KAAK8K,YAAc,IASnB9K,KAAK+K,oBAAsB,EAS3B/K,KAAKgL,eAAiB,EAQtBhL,KAAKiL,mBAAqB,EAO1BjL,KAAKkL,cAAgB,GAAIpF,QAAOoB,KAAKC,QAAQ,EAAG,GAShDnH,KAAKmL,wBAAyB,EAQ9BnL,KAAKoL,UAAYrH,GAAO,GAQxB/D,KAAKqL,YAActG,GAAS,GAO5B/E,KAAKsL,aAAe5G,EAOpB1E,KAAKuL,2BAA4B,EAOjCvL,KAAKwL,gBAAkBhH,EAAOxC,kBAQ9BhC,KAAKyL,OACHC,YAAY,EACZC,MAAO,EACPC,OAAQ,EACRC,QAAS,EACTC,QAAS,GAWX9L,KAAK+L,OAAS,GAAIjG,QAAOC,KAAKC,UAQ9BhG,KAAKwH,aAAexH,KAAK4E,MAAMK,QAAQ6C,MAAMiE,OAQ7C/L,KAAKgM,gBAQLhM,KAAKiM,iBAAmB,EAOxBjM,KAAKkM,SAQLlM,KAAKmM,cAAgB,KAQrBnM,KAAKoM,eAAiB,KAYtBpM,KAAKqM,WAAY,EAOjBrM,KAAKsM,WAAY,EAUjBtM,KAAKuM,eAAgB,EAUrBvM,KAAKwM,YAAc,GAAI1G,QAAOoB,KAAKC,QAQnCnH,KAAKyM,UAAY,EAQjBzM,KAAK0M,cAAgB,EAQrB1M,KAAK2M,cAAgB,GAAI7G,QAAOoB,KAAKC,QAErCnH,KAAK+G,aAAe,GAAIjB,QAAO8G,OAAOC,aAEtC7M,KAAK8M,cAActE,EAAazE,EAAKgB,EAAO0D,GLm2C9C,MAzvBAzE,GAAamE,IACXpE,IAAK,gBACLkC,MAAO,SKhlBK8G,EAAUhJ,EAAKgB,EAAO0D,EAAOuE,GAiDzC,WAhDiBC,KAAbF,IACFA,EAAW,GAETC,IACFhN,KAAKsL,aAAe0B,GAMlBhN,KAAK+J,UAAY/J,KAAK+J,QAAQnF,QAChC5E,KAAK+J,QAAU,MAGZ/J,KAAK+J,UACR/J,KAAK+J,QAAU/J,KAAK4E,MAAMM,IAAIuD,OAC5ByE,UAAWlN,KAAKsL,aAChB6B,QAASJ,EACTK,gBAAgB,KAIH,IAAbL,KACgB,IAAdA,IACF/M,KAAKgK,wBAAyB,EAC9B+C,EAAW,GAGb/M,KAAK+J,QAAQsD,gBACXtJ,MACAgB,QACAuI,OAAQP,EACR9F,QAAQ,EACRsG,SAAS,IAGXvN,KAAK+J,QAAQyD,SAASC,KAAK,SAAUC,GACnCA,EAAMtI,KAAKE,cAAgBtF,MAC1BA,MAEHA,KAAKoL,UAAYrH,EACjB/D,KAAKqL,YAActG,EAEf0D,GACFA,EAAMkF,YAAY3N,KAAK+J,QAAQyD,SAASI,UAIrC5N,QL8lBP+D,IAAK,UACLkC,MAAO,SKllBD4H,EAAUC,GAChB,GAAMC,GAAYC,SAQlB,OANAhO,MAAK+J,QAAQyD,SAASC,KAAK,SAAAC,GACrBA,EAAMzG,QACR4G,EAAStN,KAAKuN,EAAiBJ,EAAOK,KAInC/N,QL2lBP+D,IAAK,WACLkC,MAAO,WK1kBP,MAPAjG,MAAK+J,QAAQyD,SAASC,KAAK,SAAAC,GACzBA,EAAMtH,KAAKC,QAAS,EACS,OAAzBqH,EAAMtI,KAAKC,YACbqI,EAAMtI,KAAKC,UAAU4I,QAAS,IAE/BjO,MAEIA,QL6lBP+D,IAAK,YACLkC,MAAO,WK5kBP,MAPAjG,MAAK+J,QAAQyD,SAASC,KAAK,SAAAC,GACzBA,EAAMtH,KAAKC,QAAS,EACS,OAAzBqH,EAAMtI,KAAKC,YACbqI,EAAMtI,KAAKC,UAAU4I,QAAS,IAE/BjO,MAEIA,QL8lBP+D,IAAK,UACLkC,MAAO,WK9kBP,MAPAjG,MAAK+J,QAAQyD,SAASC,KAAK,SAAAC,GACrBA,EAAMzG,QACRyG,EAAMrG,OAERqG,EAAMtH,KAAKC,QAAS,IAGfrG,QLimBP+D,IAAK,aACLkC,MAAO,SKxlBEiI,GAOT,MANAlO,MAAKkK,MAAQ,MAEI+C,KAAbiB,IACFlO,KAAKmK,UAAY+D,GAGZlO,QL4mBP+D,IAAK,cACLkC,MAAO,SK1lBGkI,EAAQtC,EAASC,EAASS,GAiBpC,WAhBgBU,KAAZpB,IACFA,EAAU,OAEIoB,KAAZnB,IACFA,EAAU,OAEUmB,KAAlBV,IACFA,GAAgB,GAGlBvM,KAAKoM,eAAiB,KACtBpM,KAAKmM,cAAgBgC,EACrBnO,KAAKuM,cAAgBA,EAErBvM,KAAKwM,YAAY4B,IAAIvC,EAASC,GAEvB9L,QL6mBP+D,IAAK,eACLkC,MAAO,SK5lBIoI,EAASxC,EAASC,GAiB7B,WAhBgBmB,KAAZoB,GAAyBrO,KAAK4E,MAAM0J,QACtCD,EAAUrO,KAAK4E,MAAM0J,MAAMC,mBAEbtB,KAAZpB,IACFA,EAAU,OAEIoB,KAAZnB,IACFA,EAAU,GAGZ9L,KAAKoM,eAAiBiC,EACtBrO,KAAKmM,cAAgB,KACrBnM,KAAKuM,eAAgB,EAErBvM,KAAKwM,YAAY4B,IAAIvC,EAASC,GAEvB9L,QLqnBP+D,IAAK,WACLkC,MAAO,SK9lBAuI,EAAWC,GAAM,GAAAzJ,GAAAhF,IACxBA,MAAKqM,WAAY,CAEjB,IAAMtC,KAYN,OAVI0E,IAAQzO,KAAKmM,eAAiBnM,KAAKoM,eACrCoC,EAAU7E,QAAQ,SAAA+E,GAChB3E,EAAQnB,KAAK5D,EAAK2J,KAAKF,EAAM,KAAM,KAAMC,EAAO7J,EAAG6J,EAAO5J,MAG5D0J,EAAU7E,QAAQ,SAAAiF,GAChB7E,EAAQnB,KAAK5D,EAAK2J,KAAKC,MAIpB7E,KLunBPhG,IAAK,aACLkC,MAAO,SKjmBE4F,EAASC,GAQlB,WAPgBmB,KAAZpB,IACFA,EAAU,OAEIoB,KAAZnB,IACFA,EAAU,GAGL9L,KAAK2O,KAAK,KAAM,KAAM,KAAM9C,EAASC,ML6mB5C/H,IAAK,gBACLkC,MAAO,SKpmBKoI,GAKZ,WAJgBpB,KAAZoB,GAAyBrO,KAAK4E,MAAM0J,QACtCD,EAAUrO,KAAK4E,MAAM0J,MAAMC,eAGtBvO,KAAK2O,KAAK,KAAMN,EAAQxJ,EAAGwJ,EAAQvJ,ML+mB1Cf,IAAK,eACLkC,MAAO,SKtmBIkI,GACX,MAAOnO,MAAK2O,KAAK,KAAMR,EAAOtJ,EAAGsJ,EAAOrJ,MLknBxCf,IAAK,WACLkC,MAAO,SKxmBApB,EAAGC,GACV,MAAO9E,MAAK2O,KAAK,KAAM9J,EAAGC,MLsoB1Bf,IAAK,OACLkC,MAAO,SK1mBJwI,EAAM5J,EAAGC,EAAG+G,EAASC,GAQxB,OAPUmB,KAANpI,IACFA,EAAI,UAEIoI,KAANnI,IACFA,EAAI,MAIJ9E,KAAK4E,MAAM6E,KAAKoF,IAAM7O,KAAKyM,WAC1BzM,KAAKmK,UAAY,GAAKnK,KAAKkK,QAAUlK,KAAKmK,UAE3C,MAAO,KAGT,IAAI2E,GAAQ9O,KAAK8K,WAGgB,KAA7B9K,KAAK+K,sBACP+D,GAAShJ,OAAOoB,KAAK6H,SAAS/O,KAAK+K,oBAAqB/K,KAAK+K,sBAG3D0D,EACEzO,KAAKsK,SAASqB,MAAQ,EACxB3L,KAAKsK,SAAS0E,SAASP,EAAK5J,EAAG4J,EAAK3J,IAEpC9E,KAAKsK,SAASzF,EAAI4J,EAAK5J,EACvB7E,KAAKsK,SAASxF,EAAI2J,EAAK3J,GAEhB9E,KAAKmM,eACVnM,KAAKuM,eACPvM,KAAK2M,cAAcyB,IACjBpO,KAAKmM,cAActH,EAAI7E,KAAKwM,YAAY3H,EACxC7E,KAAKmM,cAAcrH,EAAI9E,KAAKwM,YAAY1H,GAE1CgB,OAAOoB,KAAK+H,aAAajP,KAAK2M,cAC5B3M,KAAKmM,cAActH,EACnB7E,KAAKmM,cAAcrH,EACnB9E,KAAKmM,cAAczE,UAGjB1H,KAAKsK,SAASqB,MAAQ,EACxB3L,KAAKsK,SAAS0E,SAAShP,KAAK2M,cAAc9H,EAAG7E,KAAK2M,cAAc7H,IAEhE9E,KAAKsK,SAASzF,EAAI7E,KAAK2M,cAAc9H,EACrC7E,KAAKsK,SAASxF,EAAI9E,KAAK2M,cAAc7H,IAE9B9E,KAAKsK,SAASqB,MAAQ,EAC/B3L,KAAKsK,SAAS0E,SACZhP,KAAKmM,cAActH,EAAI7E,KAAKwM,YAAY3H,EACxC7E,KAAKmM,cAAcrH,EAAI9E,KAAKwM,YAAY1H,IAG1C9E,KAAKsK,SAASzF,EAAI7E,KAAKmM,cAActH,EAAI7E,KAAKwM,YAAY3H,EAC1D7E,KAAKsK,SAASxF,EAAI9E,KAAKmM,cAAcrH,EAAI9E,KAAKwM,YAAY1H,GAGxD9E,KAAKwK,2BACPsE,GAAS9O,KAAKmM,cAAc/F,KAAK0I,QAE1B9O,KAAKoM,iBACVpM,KAAKsK,SAASqB,MAAQ,EACxB3L,KAAKsK,SAAS0E,SACZhP,KAAKoM,eAAevH,EAAI7E,KAAKwM,YAAY3H,EACzC7E,KAAKoM,eAAetH,EAAI9E,KAAKwM,YAAY1H,IAG3C9E,KAAKsK,SAASzF,EAAI7E,KAAKoM,eAAevH,EAAI7E,KAAKwM,YAAY3H,EAC3D7E,KAAKsK,SAASxF,EAAI9E,KAAKoM,eAAetH,EAAI9E,KAAKwM,YAAY1H,QAI/CmI,KAAZpB,IACF7L,KAAKsK,SAASzF,GAAKgH,OAGLoB,KAAZnB,IACF9L,KAAKsK,SAASxF,GAAKgH,EAGrB,IAAMoD,GAAUlP,KAAKsK,SAASzF,EAAIqC,KAAKiI,SAAWnP,KAAKsK,SAASqB,MAC1DyD,EAAUpP,KAAKsK,SAASxF,EAAIoC,KAAKiI,SAAWnP,KAAKsK,SAASsB,OAE1DrG,EAAQvF,KAAKsK,SAASqB,MAAQ,EAAIuD,EAAUlP,KAAKsK,SAASzF,EAC1DW,EAAQxF,KAAKsK,SAASsB,OAAS,EAAIwD,EAAUpP,KAAKsK,SAASxF,EAE7DuK,EAAQrP,KAAKuM,cAAgBvM,KAAKmM,cAAckD,MAAQrP,KAAKuK,SAGvD,QAAN1F,GAAoB,OAANC,IAChBuK,EAAQvJ,OAAOoB,KAAKoI,SAASpI,KAAKqI,MAAMzK,EAAIU,EAAOX,EAAIU,KAIxB,IAA7BvF,KAAK6K,sBACPwE,GAASvJ,OAAOoB,KAAK6H,SAAS/O,KAAK6K,oBAAqB7K,KAAK6K,qBAG/D,IAAI2E,GAAQ,EACRC,EAAQ,CAGE,KAAVJ,GAAyB,MAAVA,EACjBG,EAAQtI,KAAKwI,IAAI5J,OAAOoB,KAAKyI,SAASN,IAAUP,EAC7B,KAAVO,GAA0B,MAAVA,EACzBI,EAAQvI,KAAK0I,IAAI9J,OAAOoB,KAAKyI,SAASN,IAAUP,GAEhDU,EAAQtI,KAAKwI,IAAI5J,OAAOoB,KAAKyI,SAASN,IAAUP,EAChDW,EAAQvI,KAAK0I,IAAI9J,OAAOoB,KAAKyI,SAASN,IAAUP,EAGlD,IAAIe,GAAS,IAYb,IAVI7P,KAAKgK,wBACP6F,EAAS7P,KAAK+J,QAAQ+F,cAAa,EAAMvK,EAAOC,EAAOxF,KAAKoL,UAAWpL,KAAKqL,aAE5EwE,EAAOzK,KAAKE,cAAgBtF,MAE5B6P,EAAS7P,KAAK+J,QAAQ+F,cAAa,GAGrCpJ,QAAQC,IAAR,eAAAC,OAA2BiJ,EAASA,EAAOpL,SAAW,aAElDoL,EAAQ,CAQV,GAPAA,EAAOE,QAAQxK,EAAOC,GACtBqK,EAAOzK,KAAKG,MAAQA,EACpBsK,EAAOzK,KAAKI,MAAQA,EACpBqK,EAAOzK,KAAKO,SAAW3F,KAAKgQ,eAC5BH,EAAOzK,KAAKQ,aAAe5F,KAAKiL,mBAChC4E,EAAOzK,KAAKM,iBAAmB1F,KAAKmL,uBAEhCnL,KAAKgQ,iBAAmBxL,EAAO5C,cAAe,CAChD,GAAI5B,KAAKgL,gBAAkB,EACzB,KAAM,IAAIiF,OAAM,sCAElBJ,GAAOzK,KAAKC,UAAYrF,KAAK4E,MAAM6E,KAAKyG,UACtCC,MAAOnQ,KAAKgL,eACZ6C,SAAUgC,EAAOxI,KAAK+I,KAAKP,KAE7BA,EAAOQ,SAAWrQ,KAAKgL,eAGzB6E,EAAOR,MAAQA,EAAQrP,KAAK4K,kBAGxB5K,KAAKyK,gBACPoF,EAAO3D,MAAMoE,KAAKtQ,KAAKyK,iBACdzK,KAAK2K,kBACdkF,EAAO9K,MAAQ/E,KAAKgM,aAAahM,KAAKiM,oBAEtCjM,KAAKiM,kBAEwBjM,KAAKgM,aAAapI,SAC7C5D,KAAKiM,iBAAmB,IAEjBjM,KAAK0K,oBACdmF,EAAO9K,MAAQ/E,KAAKgM,aAAa9E,KAAKqJ,MAAMrJ,KAAKiI,SAAWnP,KAAKgM,aAAapI,UAG5EiM,EAAOzK,KAAKK,YACVzF,KAAKyL,MAAMC,aACbmE,EAAOzJ,KAAKoK,QAAQxQ,KAAKyL,MAAME,MAAO3L,KAAKyL,MAAMG,QACjDiE,EAAOzJ,KAAKqK,UAAUzQ,KAAKyL,MAAMI,QAAS7L,KAAKyL,MAAMK,UAGvD+D,EAAOzJ,KAAKsK,mBAAqB1Q,KAAK2Q,yBAEtCd,EAAOzK,KAAKK,WAAY,GAG1BoK,EAAOzJ,KAAKwK,YAAYpB,EAAOC,GAC/BI,EAAOzJ,KAAKyK,WAAW7Q,KAAKkL,cAAcrG,EAAG7E,KAAKkL,cAAcpG,EAEhE,IAAIgM,GAAO,CAEX,IAAiC,IAA7B9Q,KAAK+K,oBAA2B,CAClC,GAAIgG,GAAO/Q,KAAKoK,QAEhB2G,IAAQjL,OAAOoB,KAAK6H,SAAS/O,KAAKqK,iBAAkBrK,KAAKqK,kBAErD0G,EAAO,IACTA,EAAO,GAGTD,EAAO9Q,KAAK4E,MAAM6E,KAAKoF,IAAMkC,MAE7BD,GAAO9Q,KAAK4E,MAAM6E,KAAKoF,IAAM7O,KAAKoK,QAGhCpK,MAAKqM,UACFrM,KAAKsM,YAERtM,KAAKsM,WAAY,EACjBtM,KAAK0M,cAAgBoE,EACrB9Q,KAAKkK,UAGPlK,KAAKyM,UAAYqE,EAEjB9Q,KAAKkK,SAGPlK,KAAK+G,aAAaC,KAAK,OAAQ6I,EAAQ7P,KAAM8O,GAEzC9O,KAAKmK,UAAY,GAAKnK,KAAKkK,QAAUlK,KAAKmK,WAC5CnK,KAAK+G,aAAa,YAAa/G,KAAMA,KAAKmK,WAI9C,MAAO0F,ML0mBP9L,IAAK,sBACLkC,MAAO,SKnlBW0F,EAAOC,EAAQC,EAASC,GAqB1C,WApBgBmB,KAAZpB,IACFA,EAAU,OAEIoB,KAAZnB,IACFA,EAAU,GAGZ9L,KAAKyL,MAAMC,YAAa,EACxB1L,KAAKyL,MAAME,MAAQA,EACnB3L,KAAKyL,MAAMG,OAASA,EACpB5L,KAAKyL,MAAMI,QAAUA,EACrB7L,KAAKyL,MAAMK,QAAUA,EAGrB9L,KAAK+J,QAAQyD,SAASC,KAAK,SAAAC,GACzBA,EAAMtH,KAAKoK,QAAQ7E,EAAOC,GAC1B8B,EAAMtH,KAAKqK,UAAU5E,EAASC,KAIzB9L,QLumBP+D,IAAK,kBACLkC,MAAO,SKplBO+K,EAAKC,EAAKC,EAAO/B,GAe/B,WAdclC,KAAViE,IACFA,GAAQ,OAEKjE,KAAXkC,IACFA,GAAS,GAGXnP,KAAKgM,aAAelG,OAAOqL,MAAMC,MAAMC,YAAYL,EAAKC,GAExDjR,KAAKiM,iBAAmB,EAExBjM,KAAK2K,iBAAmBuG,EACxBlR,KAAK0K,kBAAoByE,EAElBnP,QLumBP+D,IAAK,qBACLkC,MAAO,SKplBUtF,EAAM2Q,EAAQC,EAAWC,GAc1C,MAbKxR,MAAK4E,MAAM6M,IAAIvF,MAAMA,MAAMwF,SAAS/Q,KACvCX,KAAK4E,MAAM6M,IAAIvF,MAAMyF,QACnB5N,IAAKpD,EACL2Q,SACAC,YACAC,SAGFxR,KAAKkM,MAAMvL,GAAQX,KAAK4E,MAAM6M,IAAIvF,MAAMA,MAAM0B,QAAQjN,IAGxDX,KAAKyK,gBAAkB9J,EAEhBX,QL8lBP+D,IAAK,QACLkC,MAAO,SKplBHpB,EAAGC,EAAG8M,OL8mBV7N,IAAK,SACLkC,MAAO,WKnlBHjG,KAAKwL,kBAAoBhH,EAAO1C,qBAC9B9B,KAAKmM,eACPnM,KAAKmM,cAAc0F,kBACnB7R,KAAK+L,OAAO+F,SAAS9R,KAAKmM,cAActH,EAAG7E,KAAKmM,cAAcrH,IACrD9E,KAAKoM,gBACdpM,KAAK+L,OAAO+F,SAAS9R,KAAKoM,eAAevH,EAAG7E,KAAKoM,eAAetH,IAIhE9E,KAAKiK,UACPjK,KAAK2O,UL+lBP5K,IAAK,aACLkC,MAAO,WKrlBFjG,KAAKqM,WAAcrM,KAAKsM,YAI7BtM,KAAKsM,WAAY,EAEjBtM,KAAKyM,UAAYzM,KAAK0M,kBL8lBtB3I,IAAK,UACLkC,MAAO,WKtlBPjG,KAAK4E,MAAQ,KAEb5E,KAAK+J,QAAQjD,SAAQ,OL0lBhBqB,IK7kBTrH,QAAOC,eAAeoH,EAAO5G,UAAW,eACtCL,IADqD,WAEnD,MAAOlB,MAAKsL,cAGd8C,IALqD,SAKjDlB,GACFlN,KAAKsL,aAAe4B,EAGhBlN,KAAK+J,UACP/J,KAAK+J,QAAQmD,UAAYlN,KAAKsL,iBAoCpCxK,OAAOC,eAAeoH,EAAO5G,UAAW,kBACtCL,IADwD,WAEtD,MAAOlB,MAAKwL,iBAGd4C,IALwD,SAKpD2D,GAEF,OADArL,QAAQC,IAAR,2BAAAC,OAAuCmL,IAC/BA,GACN,IAAKvN,GAAOvC,mBACZ,IAAKuC,GAAO1C,mBACV9B,KAAKwH,aAAexH,KAAK+L,MACzB,MAEF,KAAKvH,GAAOzC,mBACV/B,KAAKwH,aAAexH,KAAK4E,MAAM6M,IAAIO,QAAQC,KAAKC,OAChD,MAEF,KAAK1N,GAAOxC,kBACVhC,KAAKwH,aAAexH,KAAK4E,MAAMK,QAAQ6C,MAAMiE,OAIjD/L,KAAKwL,gBAAkBuG,KAU3BjR,OAAOC,eAAeoH,EAAO5G,UAAW,4BACtCL,IADkE,WAEhE,MAAOlB,MAAKuL,2BAGd6C,IALkE,SAK9DnI,GACFjG,KAAKuL,0BAA4BtF,EAEjCjG,KAAK+J,QAAQyD,SAASC,KAAK,SAAAC,GACzBA,EAAMtH,KAAKsK,mBAAqBzK,EAChCyH,EAAMtI,KAAKK,WAAY,OAY7B3E,OAAOC,eAAeoH,EAAO5G,UAAW,KACtCL,IAD2C,WAEzC,MAAOlB,MAAKsK,SAASzF,GAGvBuJ,IAL2C,SAKvCnI,GACFjG,KAAKsK,SAASzF,EAAIoB,KAWtBnF,OAAOC,eAAeoH,EAAO5G,UAAW,KACtCL,IAD2C,WAEzC,MAAOlB,MAAKsK,SAASxF,GAGvBsJ,IAL2C,SAKvCnI,GACFjG,KAAKsK,SAASxF,EAAImB,KAItBrG,EAAOD,QAAUwI","file":"WeaponPlugin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WeaponPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WeaponPlugin\"] = factory();\n\telse\n\t\troot[\"WeaponPlugin\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WeaponPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WeaponPlugin\"] = factory();\n\telse\n\t\troot[\"WeaponPlugin\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  /**\n   * A {@link #bulletKillType} constant that stops the bullets from ever being destroyed automatically.\n   * @constant\n   * @type {integer}\n   */\n  KILL_NEVER: 0,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when their {@link #bulletLifespan} expires.\n   * @constant\n   * @type {integer}\n   */\n  KILL_LIFESPAN: 1,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets after they\n   * exceed the {@link #bulletDistance} from their original firing position.\n   * @constant\n   * @type {integer}\n   */\n  KILL_DISTANCE: 2,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WEAPON_BOUNDS: 3,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link Phaser.Camera#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_CAMERA_BOUNDS: 4,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link Phaser.World#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WORLD_BOUNDS: 5,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_STATIC_BOUNDS: 6,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face up.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_UP: 270,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face down.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_DOWN: 90,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face left.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_LEFT: 180,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face right.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_RIGHT: 0,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\n   * @constant Phaser.ANGLE_NORTH_EAST\n   * @type {integer}\n   */\n  ANGLE_NORTH_EAST: 315,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_NORTH_WEST: 225,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_EAST: 45,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_WEST: 135\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) { return o.__proto__; }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n */\nvar consts = __webpack_require__(0);\n\nvar bulletID = 0;\n\nvar Bullet =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$S) {\n  /**\n   * Create a new `Bullet` object. Bullets are used by the `Weapon` class, and are normal Sprites,\n   * with a few extra properties in the data object to handle Weapon specific features.\n   *\n   * @param {Phaser.Scene} scene - A reference to the currently running scene.\n   * @param {number} x - The x coordinate (in world space) to position the Particle at.\n   * @param {number} y - The y coordinate (in world space) to position the Particle at.\n   * @param {string} key - This is the image or texture used by the Particle during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n   */\n  function Bullet(scene, x, y, key, frame) {\n    var _this;\n\n    _classCallCheck(this, Bullet);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Bullet).call(this, scene, x, y, key, frame));\n    _this.bulletID = bulletID;\n    bulletID++;\n\n    _this.scene.physics.add.existing(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this.data = {\n      timeEvent: null,\n      bulletManager: null,\n      fromX: 0,\n      fromY: 0,\n      bodyDirty: true,\n      rotateToVelocity: false,\n      killType: 0,\n      killDistance: 0,\n      bodyBounds: new Phaser.Geom.Rectangle()\n    };\n    return _this;\n  }\n  /**\n   * Prepares this bullet to be fired and interact with the rest of the scene\n   * again.\n   */\n\n\n  _createClass(Bullet, [{\n    key: \"prepare\",\n    value: function prepare(x, y) {\n      this.setActive(true);\n      this.setVisible(true);\n      this.body.enable = true;\n      this.body.reset(x, y);\n      this.body.debugShowBody = this.data.bulletManager.debugPhysics;\n      this.body.debugShowVelocity = this.data.bulletManager.debugPhysics;\n    }\n    /**\n     * Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.\n     * Also dispatches the `Weapon`s kill signal.\n     * @returns {Bullet} This instance of the bullet class\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      console.log(\"Killing bullet \".concat(this.bulletID)); // Reproduce Phaser.Physics.Arcade.Components.Enable.disableBody because\n      // we can't assume that the bullet class has it built in.\n\n      this.body.stop();\n      this.body.enable = false;\n      this.setActive(false);\n      this.setVisible(false);\n      this.body.debugShowBody = false;\n      this.body.debugShowVelocity = false; // TODO: potentially we don't need to destroy the time event and we can\n      // just pause when the bullet is killed and restart it when it's refired.\n      // For now though do the simple thing and discard it.\n      // Another option would be to use Date.now() and manually process pause\n      // events with a flag and some math.\n      // Both of those are probably premature optimizations.\n\n      if (this.data.timeEvent !== null) {\n        this.data.timeEvent.destroy();\n        this.data.timeEvent = null;\n      }\n\n      this.data.bulletManager.eventEmitter.emit('kill', this);\n      return this;\n    }\n    /**\n     * Updates the Bullet, killing as required.\n     * @returns {Bullet} This instance of the bullet class\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (!this.active) {\n        // this was previously a check to this.exists\n        return;\n      }\n\n      if (this.data.killType > consts.KILL_LIFESPAN) {\n        if (this.data.killType === consts.KILL_DISTANCE) {\n          if (new Phaser.Math.Vector2(this.data.fromX, this.data.fromY).distance(this) > this.data.killDistance) {\n            this.kill();\n          }\n        } else if (!Phaser.Geom.Intersects.RectangleToRectangle(this.data.bulletManager.bulletBounds, this.body.getBounds(this.data.bodyBounds))) {\n          this.kill();\n        }\n      }\n\n      if (this.data.rotateToVelocity) {\n        this.rotation = this.body.velocity.atan();\n      }\n\n      if (this.data.bulletManager.bulletWorldWrap) {\n        this.scene.physics.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding);\n      }\n    }\n  }]);\n\n  _inherits(Bullet, _Phaser$GameObjects$S);\n\n  return Bullet;\n}(Phaser.GameObjects.Sprite);\n\nmodule.exports = Bullet;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.getPrototypeOf || function _getPrototypeOf(o) { return o.__proto__; }; return _getPrototypeOf(o); }\n\n/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n */\nvar Weapon = __webpack_require__(3);\n\nvar Bullet = __webpack_require__(1);\n\nvar consts = __webpack_require__(0);\n/**\n * The Weapon Plugin provides the ability to easily create a bullet pool\n * and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, such as move it around the display list, iterate it, etc can\n * be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.set(300, 300);\n * this.input.onDown.add(weapon.fire, this); // Update this\n * ```\n */\n\n\nvar WeaponPlugin =\n/*#__PURE__*/\nfunction (_Phaser$Plugins$Scene) {\n  /**\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the\n   *  Phaser.Plugins.PluginManager instance.\n   */\n  function WeaponPlugin(scene, pluginManager) {\n    var _this;\n\n    _classCallCheck(this, WeaponPlugin);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WeaponPlugin).call(this, scene, pluginManager));\n    _this.weapons = []; // Register our new Game Object type\n    // pluginManager.registerGameObject('weapon', this.add);\n\n    return _this;\n  }\n\n  _createClass(WeaponPlugin, [{\n    key: \"add\",\n    value: function add(bulletLimit, key, frame, group, weaponClass) {\n      if (!weaponClass) {\n        weaponClass = Weapon;\n      }\n\n      var weapon = new weaponClass(this.scene, bulletLimit, key, frame, group);\n      this.weapons.push(weapon);\n      return weapon;\n    }\n    /**\n     * Called by the PluginManager when this plugin is started.\n     * If a plugin is stopped, and then started again, this will get called again.\n     * Typically called immediately after `BasePlugin.init`.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      eventEmitter.on('postrender', this.postRender, this);\n    }\n    /**\n     * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\n     * By this point the plugin properties `scene` and `systems` will have already been set.\n     * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"boot\",\n    value: function boot() {\n      var eventEmitter = this.systems.events; //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n      //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n      eventEmitter.on('preupdate', this.preUpdate, this);\n      eventEmitter.on('update', this.update, this);\n      eventEmitter.on('postupdate', this.postUpdate, this);\n      eventEmitter.on('pause', this.pause, this);\n      eventEmitter.on('resume', this.resume, this);\n      eventEmitter.on('sleep', this.sleep, this);\n      eventEmitter.on('wake', this.wake, this);\n      eventEmitter.on('shutdown', this.shutdown, this);\n      eventEmitter.on('destroy', this.destroy, this);\n    } //  Called every Scene step - phase 1\n\n  }, {\n    key: \"preUpdate\",\n    value: function preUpdate(time, delta) {} // Empty\n\n    /**\n     * Internal update method, called by the PluginManager.\n     *\n     * @protected\n     * @param {number} time - Current game time\n     * @param {number} delta - Time since last call\n     * @returns {void}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(time, delta) {\n      this.weapons.forEach(function (weapon) {\n        weapon.update();\n      });\n    } //  Called every Scene step - phase 3\n\n  }, {\n    key: \"postUpdate\",\n    value: function postUpdate(time, delta) {} // Empty\n\n    /**\n     * Internal update method, called by the PluginManager.\n     *\n     * @protected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"postRender\",\n    value: function postRender() {\n      this.weapons.forEach(function (weapon) {\n        weapon.postRender();\n      });\n    } //  Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n\n  }, {\n    key: \"pause\",\n    value: function pause() {} // Empty\n    //  Called when a Scene is resumed from a paused state.\n\n  }, {\n    key: \"resume\",\n    value: function resume() {} // Empty\n    //  Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n\n  }, {\n    key: \"sleep\",\n    value: function sleep() {} // Empty\n    //  Called when a Scene is woken from a sleeping state.\n\n  }, {\n    key: \"wake\",\n    value: function wake() {} // Empty\n    //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {} // Empty\n\n    /**\n     * Destroys this Weapon.\n     * You must release everything in here, all references, all objects, free it all up.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.pluginManager = null;\n      this.game = null;\n      this.scene = null;\n      this.systems = null;\n    }\n  }]);\n\n  _inherits(WeaponPlugin, _Phaser$Plugins$Scene);\n\n  return WeaponPlugin;\n}(Phaser.Plugins.ScenePlugin);\n\nWeaponPlugin.Weapon = Weapon;\nWeaponPlugin.Bullet = Bullet;\nWeaponPlugin.consts = consts; //  Make sure you export the plugin for webpack to expose\n\nmodule.exports = WeaponPlugin;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n */\nvar Bullet = __webpack_require__(1);\n\nvar consts = __webpack_require__(0);\n/**\n * The Weapon provides the ability to easily create a bullet pool and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with P2 Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, such as move it around the display list, iterate it, etc can\n * be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.set(300, 300);\n * this.input.onDown.add(weapon.fire, this); // Update this\n * ```\n */\n\n\nvar Weapon =\n/*#__PURE__*/\nfunction () {\n  /**\n   * TODO: a builder style interface would be neat. Can be kicked way forward\n   * into polishing.\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   */\n  function Weapon(scene, bulletLimit, key, frame, group) {\n    _classCallCheck(this, Weapon);\n\n    this.scene = scene;\n    this.debugPhysics = null;\n    /**\n     * This is the Phaser.Group that contains all of the bullets managed by this plugin.\n     * @type {Phaser.GameObjects.Group}\n     */\n\n    this.bullets = null;\n    /**\n     * Should the bullet pool run out of bullets (i.e. they are all in flight) then this\n     * boolean controls if the Group will create a brand new bullet object or not.\n     * @type {boolean}\n     * @default\n     */\n\n    this.autoExpandBulletsGroup = false;\n    /**\n     * Will this weapon auto fire? If set to true then a new bullet will be fired\n     * based on the {@link #fireRate} value.\n     * @type {boolean}\n     * @default\n     */\n\n    this.autofire = false;\n    /**\n     * The total number of bullets this Weapon has fired so far.\n     * You can limit the number of shots allowed (via {@link #fireLimit}), and reset\n     * this total via {@link #resetShots}.\n     * @type {number}\n     * @default\n     */\n\n    this.shots = 0;\n    /**\n     * The maximum number of shots that this Weapon is allowed to fire before it stops.\n     * When the limit is his the {@link #onFireLimit} Signal is dispatched.\n     * You can reset the shot counter via {@link #resetShots}.\n     * @type {number}\n     * @default\n     */\n\n    this.fireLimit = 0;\n    /**\n     * The minimum interval between shots, in milliseconds.\n     * @type {number}\n     * @default\n     */\n\n    this.fireRate = 100;\n    /**\n     * This is a modifier that is added to the {@link #fireRate} each update to add variety\n     * to the firing rate of the Weapon. The value is given in milliseconds.\n     * If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual\n     * firing rate of the Weapon will be between 150 and 250.\n     * @type {number}\n     * @default\n     */\n\n    this.fireRateVariance = 0;\n    /**\n     * This is a Rectangle from within which the bullets are fired. By default it's a 1x1\n     * rectangle, the equivalent of a Point. But you can change the width and height, and if\n     * larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.\n     * @type {Phaser.Geom.Rectangle}\n     */\n\n    this.fireFrom = new Phaser.Geom.Rectangle(0, 0, 1, 1);\n    /**\n     * The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP\n     * or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.\n     * @type {integer}\n     * @default\n     */\n\n    this.fireAngle = consts.ANGLE_UP;\n    /**\n     * When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.\n     * @type {boolean}\n     * @default\n     */\n\n    this.bulletInheritSpriteSpeed = false;\n    /**\n     * The string based name of the animation that the Bullet will be given on launch.\n     * This is set via {@link #addBulletAnimation}.\n     * @type {string}\n     * @default\n     */\n\n    this.bulletAnimation = '';\n    /**\n     * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n     * chose for each Bullet fired to pick a random frame from the set.\n     * @type {boolean}\n     * @default\n     */\n\n    this.bulletFrameRandom = false;\n    /**\n     * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n     * chose for each Bullet fired to use the next frame in the set. The frame index is then\n     * advanced one frame until it reaches the end of the set, then it starts from the start\n     * again. Cycling frames like this allows you to create varied bullet effects via\n     * sprite sheets.\n     * @type {boolean}\n     * @default\n     */\n\n    this.bulletFrameCycle = false;\n    /**\n     * Should the Bullets wrap around the world bounds? This automatically calls\n     * `World.wrap` on the Bullet each frame. See the docs for that method for details.\n     * @type {boolean}\n     * @default\n     */\n\n    this.bulletWorldWrap = false;\n    /**\n     * If `bulletWorldWrap` is true then you can provide an optional padding value with this\n     * property. It's added to the calculations determining when the Bullet should wrap around\n     * the world or not. The value is given in pixels.\n     * @type {integer}\n     * @default\n     */\n\n    this.bulletWorldWrapPadding = 0;\n    /**\n     * An optional angle offset applied to the Bullets when they are launched.\n     * This is useful if for example your bullet sprites have been drawn facing up, instead of\n     * to the right, and you want to fire them at an angle. In which case you can set the\n     * angle offset to be 90 and they'll be properly rotated when fired.\n     * @type {number}\n     * @default\n     */\n\n    this.bulletAngleOffset = 0;\n    /**\n     * This is a variance added to the angle of Bullets when they are fired.\n     * If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual\n     * angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a\n     * great 'spread' effect to a Weapon.\n     * @type {number}\n     * @default\n     */\n\n    this.bulletAngleVariance = 0;\n    /**\n     * The initial velocity of fired bullets, in pixels per second.\n     * @type {number}\n     * @default\n     */\n\n    this.bulletSpeed = 200;\n    /**\n     * This is a variance added to the speed of Bullets when they are fired.\n     * If bullets have a {@link #bulletSpeed} value of 200, and a `bulletSpeedVariance` of 50\n     * then the actual speed of the Bullets will be between 150 and 250 pixels per second.\n     * @type {number}\n     * @default\n     */\n\n    this.bulletSpeedVariance = 0;\n    /**\n     * If you've set {@link #bulletKillType} to `consts.KILL_LIFESPAN` this controls the amount\n     * of lifespan the Bullets have set on launch. The value is given in milliseconds.\n     * When a Bullet hits its lifespan limit it will be automatically killed.\n     * @type {number}\n     * @default\n     */\n\n    this.bulletLifespan = 0;\n    /**\n     * If you've set {@link #bulletKillType} to `consts.KILL_DISTANCE` this controls the distance\n     * the Bullet can travel before it is automatically killed. The distance is given in pixels.\n     * @type {number}\n     * @default\n     */\n\n    this.bulletKillDistance = 0;\n    /**\n     * This is the amount of {@link Phaser.Physics.Arcade.Body#gravity} added to the Bullets physics body when fired.\n     * Gravity is expressed in pixels / second / second.\n     * @type {Phaser.Math.Vector2}\n     */\n\n    this.bulletGravity = new Phaser.Math.Vector2(0, 0);\n    /**\n     * Bullets can optionally adjust their rotation in-flight to match their velocity.\n     * This can create the effect of a bullet 'pointing' to the path it is following, for example\n     * an arrow being fired from a bow, and works especially well when added to {@link #bulletGravity}.\n     * @type {boolean}\n     * @default\n     */\n\n    this.bulletRotateToVelocity = false;\n    /**\n     * The Texture Key that the Bullets use when rendering.\n     * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n     * @type {string}\n     * @default\n     */\n\n    this.bulletKey = key || '';\n    /**\n     * The Texture Frame that the Bullets use when rendering.\n     * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n     * @type {string|integer}\n     * @default\n     */\n\n    this.bulletFrame = frame || '';\n    /**\n     * Private var that holds the public `bulletClass` property.\n     * @type {function}\n     * @private\n     */\n\n    this._bulletClass = Bullet;\n    /**\n     * Private var that holds the public `bulletCollideWorldBounds` property.\n     * @type {boolean}\n     * @private\n     */\n\n    this._bulletCollideWorldBounds = false;\n    /**\n     * Private var that holds the public `bulletKillType` property.\n     * @type {integer}\n     * @private\n     */\n\n    this._bulletKillType = consts.KILL_WORLD_BOUNDS;\n    /**\n     * Holds internal data about custom bullet body sizes.\n     *\n     * @type {Object}\n     * @private\n     */\n\n    this._data = {\n      customBody: false,\n      width: 0,\n      height: 0,\n      offsetX: 0,\n      offsetY: 0\n    };\n    /**\n     * This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.\n     * It's used in combination with {@link #bulletKillType} when that is set to either `consts.KILL_WEAPON_BOUNDS`\n     * or `consts.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.\n     * If you are tracking a Sprite or Point then the bounds are centered on that object every frame.\n     *\n     * @type {Phaser.Geom.Rectangle}\n     */\n\n    this.bounds = new Phaser.Geom.Rectangle();\n    /**\n     * The Rectangle used to calculate the bullet bounds from.\n     *\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n\n    this.bulletBounds = this.scene.physics.world.bounds;\n    /**\n     * This array stores the frames added via @link #setBulletFrames.\n     *\n     * @type {Array}\n     * @protected\n     */\n\n    this.bulletFrames = [];\n    /**\n     * The index of the frame within {@link #bulletFrames} that is currently being used.\n     * This value is only used if {@link #bulletFrameCycle} is set to `true`.\n     * @type {number}\n     * @private\n     */\n\n    this.bulletFrameIndex = 0;\n    /**\n     * An internal object that stores the animation data added via {@link #addBulletAnimation}.\n     * @type {Object}\n     * @private\n     */\n\n    this.anims = {};\n    /**\n     * The Sprite currently being tracked by the Weapon, if any.\n     * This is set via the {@link #trackSprite} method.\n     *\n     * @type {Phaser.GameObjects.Sprite|Object}\n     */\n\n    this.trackedSprite = null;\n    /**\n     * The Pointer currently being tracked by the Weapon, if any.\n     * This is set via the {@link #trackPointer} method.\n     *\n     * @type {Phaser.Input.Pointer}\n     */\n\n    this.trackedPointer = null;\n    /**\n     * If you want this Weapon to be able to fire more than 1 bullet in a single\n     * update, then set this property to `true`. When `true` the Weapon plugin won't\n     * set the shot / firing timers until the `postRender` phase of the game loop.\n     * This means you can call `fire` (and similar methods) as often as you like in one\n     * single game update.\n     *\n     * @type {boolean}\n     * @default\n     */\n\n    this.multiFire = false;\n    /**\n     * Internal multiFire test flag.\n     *\n     * @type {boolean}\n     */\n\n    this._hasFired = false;\n    /**\n     * If the Weapon is tracking a Sprite, should it also track the Sprites rotation?\n     * This is useful for a game such as Asteroids, where you want the weapon to fire based\n     * on the sprites rotation.\n     *\n     * @type {boolean}\n     * @default\n     */\n\n    this.trackRotation = false;\n    /**\n     * The Track Offset is a Vector2 object that allows you to specify a pixel offset that bullets use\n     * when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels\n     * in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have\n     * the bullet launched from the center of the Sprite.\n     *\n     * @type {Phaser.Math.Vector2}\n     */\n\n    this.trackOffset = new Phaser.Math.Vector2();\n    /**\n     * Internal firing rate time tracking variable.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._nextFire = 0;\n    /**\n     * Internal firing rate time tracking variable used by multiFire.\n     *\n     * @type {number}\n     * @private\n     */\n\n    this._tempNextFire = 0;\n    /**\n     * Internal firing rotation tracking point.\n     *\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n\n    this._rotatedPoint = new Phaser.Math.Vector2();\n    this.eventEmitter = new Phaser.Events.EventEmitter();\n    this.createBullets(bulletLimit, key, frame, group);\n  }\n  /**\n   * This method performs two actions: First it will check to see if the {@link #bullets} Group exists or not,\n   * and if not it creates it, adding it the `group` given as the 4th argument.\n   *\n   * Then it will seed the bullet pool with the `quantity` number of Bullets, using the texture key and frame\n   * provided (if any).\n   *\n   * If for example you set the quantity to be 10, then this Weapon will only ever be able to have 10 bullets\n   * in-flight simultaneously. If you try to fire an 11th bullet then nothing will happen until one, or more, of\n   * the in-flight bullets have been killed, freeing them up for use by the Weapon again.\n   *\n   * If you do not wish to have a limit set, then pass in -1 as the quantity. In this instance the Weapon will\n   * keep increasing the size of the bullet pool as needed. It will never reduce the size of the pool however,\n   * so be careful it doesn't grow too large.\n   *\n   * You can either set the texture key and frame here, or via the {@link #bulletKey} and {@link #bulletFrame}\n   * properties. You can also animate bullets, or set them to use random frames. All Bullets belonging to a\n   * single Weapon instance must share the same texture key however.\n   *\n   * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon with. If -1 it will set the pool to automatically expand.\n   * @param {string} [key] - The Game.cache key of the image that this Sprite will use.\n   * @param {integer|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.\n   * @param {Phaser.GameObjects.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n   * @return {Weapon} This Weapon instance.\n   */\n\n\n  _createClass(Weapon, [{\n    key: \"createBullets\",\n    value: function createBullets(quantity, key, frame, group, bulletClass) {\n      if (quantity === undefined) {\n        quantity = 1;\n      }\n\n      if (bulletClass) {\n        this._bulletClass = bulletClass;\n      }\n      /*if (group === undefined) {\n        group = this.game.world;\n      }*/\n\n\n      if (this.bullets && !this.bullets.scene) {\n        this.bullets = null;\n      }\n\n      if (!this.bullets) {\n        this.bullets = this.scene.add.group({\n          classType: this._bulletClass,\n          maxSize: quantity,\n          runChildUpdate: true\n        });\n      }\n\n      if (quantity !== 0) {\n        if (quantity === -1) {\n          this.autoExpandBulletsGroup = true;\n          quantity = 1;\n        }\n\n        this.bullets.createMultiple({\n          key: key,\n          frame: frame,\n          repeat: quantity,\n          active: false,\n          visible: false\n        });\n        this.bullets.children.each(function (child) {\n          child.data.bulletManager = this;\n        }, this);\n        this.bulletKey = key;\n        this.bulletFrame = frame;\n\n        if (group) {\n          group.addMultiple(this.bullets.children.entries);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Call a function on each in-flight bullet in this Weapon.\n     *\n     * See {@link Phaser.GameObjects.Group#forEachExists forEachExists} for more details.\n     *\n     * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\n     * @param {object} callbackContext - The context in which the function should be called (usually 'this').\n     * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, callbackContext) {\n      var extraArgs = arguments;\n      this.bullets.children.each(function (child) {\n        if (child.active) {\n          callback.call(callbackContext, child, extraArgs);\n        }\n      });\n      return this;\n    }\n    /**\n     * Sets {@link Phaser.Physics.Arcade.Body#enable} to `false` on each bullet in this Weapon.\n     * This has the effect of stopping them in-flight should they be moving.\n     * It also stops them being able to be checked for collision.\n     *\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"pauseAll\",\n    value: function pauseAll() {\n      this.bullets.children.each(function (child) {\n        child.body.enable = false;\n\n        if (child.data.timeEvent !== null) {\n          child.data.timeEvent.paused = true;\n        }\n      }, this);\n      return this;\n    }\n    /**\n     * Sets {@link Phaser.Physics.Arcade.Body#enable} to `true` on each bullet in this Weapon.\n     * This has the effect of resuming their motion should they be in-flight.\n     * It also enables them for collision checks again.\n     *\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"resumeAll\",\n    value: function resumeAll() {\n      this.bullets.children.each(function (child) {\n        child.body.enable = true;\n\n        if (child.data.timeEvent !== null) {\n          child.data.timeEvent.paused = false;\n        }\n      }, this);\n      return this;\n    }\n    /**\n     * Calls {@link Phaser.Bullet#kill} on every in-flight bullet in this Weapon.\n     * Also re-enables their physics bodies, should they have been disabled via {@link #pauseAll}.\n     *\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"killAll\",\n    value: function killAll() {\n      this.bullets.children.each(function (child) {\n        if (child.active) {\n          child.kill();\n        }\n\n        child.body.enable = true;\n      });\n      return this;\n    }\n    /**\n     * Resets the {@link #shots} counter back to zero. This is used when you've set\n     * {@link #fireLimit} and have hit (or just wish to reset) your limit.\n     *\n     * @param {integer} [newLimit] - Optionally set a new {@link #fireLimit}.\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"resetShots\",\n    value: function resetShots(newLimit) {\n      this.shots = 0;\n\n      if (newLimit !== undefined) {\n        this.fireLimit = newLimit;\n      }\n\n      return this;\n    }\n    /**\n     * Sets this Weapon to track the given Sprite, or any Object with a public {@link Phaser.Component.Core#world world} Point object.\n     * When a Weapon tracks a Sprite it will automatically update its {@link #fireFrom} value to match the Sprite's\n     * position within the Game World, adjusting the coordinates based on the offset arguments.\n     *\n     * This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.\n     *\n     * Calling `trackSprite` will reset {@link #trackedPointer} to null, should it have been set, as you can\n     * only track _either_ a Sprite, or a Pointer, at once, but not both.\n     *\n     * @param {Phaser.GameObjects.Sprite|Object} sprite - The Sprite to track the position of.\n     * @param {integer} [offsetX=0] - The horizontal offset from the Sprites position to be applied to the Weapon.\n     * @param {integer} [offsetY=0] - The vertical offset from the Sprites position to be applied to the Weapon.\n     * @param {boolean} [trackRotation=false] - Should the Weapon also track the Sprites rotation?\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"trackSprite\",\n    value: function trackSprite(sprite, offsetX, offsetY, trackRotation) {\n      if (offsetX === undefined) {\n        offsetX = 0;\n      }\n\n      if (offsetY === undefined) {\n        offsetY = 0;\n      }\n\n      if (trackRotation === undefined) {\n        trackRotation = false;\n      }\n\n      this.trackedPointer = null;\n      this.trackedSprite = sprite;\n      this.trackRotation = trackRotation;\n      this.trackOffset.set(offsetX, offsetY);\n      return this;\n    }\n    /**\n     * Sets this Weapon to track the given Pointer.\n     * When a Weapon tracks a Pointer it will automatically update its {@link #fireFrom} value to match the Pointer's\n     * position within the Game World, adjusting the coordinates based on the offset arguments.\n     *\n     * This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.\n     *\n     * Calling `trackPointer` will reset {@link #trackedSprite} to null, should it have been set, as you can\n     * only track _either_ a Pointer, or a Sprite, at once, but not both.\n     *\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to track the position of. Defaults to `Input.activePointer` if not specified.\n     * @param {integer} [offsetX=0] - The horizontal offset from the Pointers position to be applied to the Weapon.\n     * @param {integer} [offsetY=0] - The vertical offset from the Pointers position to be applied to the Weapon.\n     * @return {Weapon} This Weapon instance.\n     */\n\n  }, {\n    key: \"trackPointer\",\n    value: function trackPointer(pointer, offsetX, offsetY) {\n      if (pointer === undefined && this.scene.input) {\n        pointer = this.scene.input.activePointer;\n      }\n\n      if (offsetX === undefined) {\n        offsetX = 0;\n      }\n\n      if (offsetY === undefined) {\n        offsetY = 0;\n      }\n\n      this.trackedPointer = pointer;\n      this.trackedSprite = null;\n      this.trackRotation = false;\n      this.trackOffset.set(offsetX, offsetY);\n      return this;\n    }\n    /**\n     * Attempts to fire multiple bullets from the positions defined in the given array.\n     *\n     * If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then\n     * the positions are treated as __offsets__ from the given objects position.\n     *\n     * If `from` is undefined, and there is no tracked object, then the bullets are fired\n     * from the given positions, as they exist in the world.\n     *\n     * Calling this method sets {@link #multiFire} to `true`.\n     *\n     * If there are not enough bullets available in the pool, and the pool cannot be extended,\n     * then this method may not fire from all of the given positions.\n     *\n     * When the bullets are launched they have their texture and frame updated, as required.\n     * The velocity of the bullets are calculated based on Weapon properties like {@link #bulletSpeed}.\n     *\n     * @param {array} positions - An array of positions. Each position can be any Object, as long as it has public `x` and `y` properties, such as Phaser.Point, { x: 0, y: 0 }, Phaser.Sprite, etc.\n     * @param {Phaser.GameObject.Sprite|Phaser.Math.Vector2|Object|string} [from] - Optionally fires the bullets **from** the `x` and `y` properties of this object, _instead_ of any {@link #trackedSprite} or `trackedPointer` that is set.\n     * @return {array} An array containing all of the fired Phaser.Bullet objects, if a launch was successful, otherwise an empty array.\n     */\n\n  }, {\n    key: \"fireMany\",\n    value: function fireMany(positions, from) {\n      var _this = this;\n\n      this.multiFire = true;\n      var bullets = [];\n\n      if (from || this.trackedSprite || this.trackedPointer) {\n        positions.forEach(function (offset) {\n          bullets.push(_this.fire(from, null, null, offset.x, offset.y));\n        });\n      } else {\n        positions.forEach(function (position) {\n          bullets.push(_this.fire(position));\n        });\n      }\n\n      return bullets;\n    }\n    /**\n     * Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset\n     * to the position first. This is the same as calling {@link #fire} and passing in the offset arguments.\n     *\n     * If there are no more bullets available in the pool, and the pool cannot be extended,\n     * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n     * the Weapon was fired, as defined in the {@link #fireRate} property.\n     *\n     * Otherwise the first available bullet is selected, launched, and returned.\n     *\n     * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n     * calculated based on Weapon properties like {@link #bulletSpeed}.\n     *\n     * If you wish to fire multiple bullets in a single game update, then set {@link #multiFire} to `true`\n     * and you can call this method as many times as you like, per loop. See also {@link #fireMany}.\n     *\n     * @param {number} [offsetX=0] - The horizontal offset from the position of the tracked Sprite or Pointer, as set with {@link #trackSprite}.\n     * @param {number} [offsetY=0] - The vertical offset from the position of the tracked Sprite or Pointer, as set with {@link #trackSprite}.\n     * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n     */\n\n  }, {\n    key: \"fireOffset\",\n    value: function fireOffset(offsetX, offsetY) {\n      if (offsetX === undefined) {\n        offsetX = 0;\n      }\n\n      if (offsetY === undefined) {\n        offsetY = 0;\n      }\n\n      return this.fire(null, null, null, offsetX, offsetY);\n    }\n    /**\n     * Fires a bullet **at** the given Pointer. The bullet will be launched from the {@link #fireFrom} position,\n     * or from a Tracked Sprite or Pointer, if you have one set.\n     *\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to fire the bullet towards.\n     * @return {Bullet} The fired bullet if successful, null otherwise.\n     */\n\n  }, {\n    key: \"fireAtPointer\",\n    value: function fireAtPointer(pointer) {\n      if (pointer === undefined && this.scene.input) {\n        pointer = this.scene.input.activePointer;\n      }\n\n      return this.fire(null, pointer.x, pointer.y);\n    }\n    /**\n     * Fires a bullet **at** the given Sprite. The bullet will be launched from the {@link #fireFrom} position,\n     * or from a Tracked Sprite or Pointer, if you have one set.\n     *\n     * @param {Phaser.GameObjects.Sprite} [sprite] - The Sprite to fire the bullet towards.\n     * @return {Bullet} The fired bullet if successful, null otherwise.\n     */\n\n  }, {\n    key: \"fireAtSprite\",\n    value: function fireAtSprite(sprite) {\n      return this.fire(null, sprite.x, sprite.y);\n    }\n    /**\n     * Fires a bullet **at** the given coordinates. The bullet will be launched from the {@link #fireFrom} position,\n     * or from a Tracked Sprite or Pointer, if you have one set.\n     *\n     * @param {number} [x] - The x coordinate, in world space, to fire the bullet towards.\n     * @param {number} [y] - The y coordinate, in world space, to fire the bullet towards.\n     * @return {Bullet} The fired bullet if successful, null otherwise.\n     */\n\n  }, {\n    key: \"fireAtXY\",\n    value: function fireAtXY(x, y) {\n      return this.fire(null, x, y);\n    }\n    /**\n     * Attempts to fire a single Bullet. If there are no more bullets available in the pool, and the pool cannot be extended,\n     * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n     * the Weapon was fired, as defined in the {@link #fireRate} property.\n     *\n     * Otherwise the first available bullet is selected, launched, and returned.\n     *\n     * The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.\n     *\n     * If you don't provide any of the arguments then it uses those set via properties such as {@link #trackedSprite},\n     * {@link #bulletAngle} and so on.\n     *\n     * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n     * calculated based on Weapon properties like `bulletSpeed`.\n     *\n     * If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`\n     * and you can call `fire` as many times as you like, per loop. Multiple fires in a single update\n     * only counts once towards the `shots` total, but you will still receive a Signal for each bullet.\n     *\n     * @param {Phaser.GameObjects.Sprite|Phaser.Math.Vector2|Object|string} [from] - Optionally fires the bullet **from** the `x` and `y` properties of this object. If set this overrides {@link #trackedSprite} or `trackedPointer`. Pass `null` to ignore it.\n     * @param {number} [x] - The x coordinate, in world space, to fire the bullet **towards**. If left as `undefined`, or `null`, the bullet direction is based on its angle.\n     * @param {number} [y] - The y coordinate, in world space, to fire the bullet **towards**. If left as `undefined`, or `null`, the bullet direction is based on its angle.\n     * @param {number} [offsetX=0] - If the bullet is fired from a tracked Sprite or Pointer, or the `from` argument is set, this applies a horizontal offset from the launch position.\n     * @param {number} [offsetY=0] - If the bullet is fired from a tracked Sprite or Pointer, or the `from` argument is set, this applies a vertical offset from the launch position.\n     * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(from, x, y, offsetX, offsetY) {\n      if (x === undefined) {\n        x = null;\n      }\n\n      if (y === undefined) {\n        y = null;\n      }\n\n      if (this.scene.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) {\n        return null;\n      }\n\n      var speed = this.bulletSpeed; //  Apply +- speed variance\n\n      if (this.bulletSpeedVariance !== 0) {\n        speed += Phaser.Math.Between(-this.bulletSpeedVariance, this.bulletSpeedVariance);\n      }\n\n      if (from) {\n        if (this.fireFrom.width > 1) {\n          this.fireFrom.CenterOn(from.x, from.y);\n        } else {\n          this.fireFrom.x = from.x;\n          this.fireFrom.y = from.y;\n        }\n      } else if (this.trackedSprite) {\n        if (this.trackRotation) {\n          this._rotatedPoint.set(this.trackedSprite.x + this.trackOffset.x, this.trackedSprite.y + this.trackOffset.y);\n\n          Phaser.Math.RotateAround(this._rotatedPoint, this.trackedSprite.x, this.trackedSprite.y, this.trackedSprite.rotation);\n\n          if (this.fireFrom.width > 1) {\n            this.fireFrom.CenterOn(this._rotatedPoint.x, this._rotatedPoint.y);\n          } else {\n            this.fireFrom.x = this._rotatedPoint.x;\n            this.fireFrom.y = this._rotatedPoint.y;\n          }\n        } else if (this.fireFrom.width > 1) {\n          this.fireFrom.CenterOn(this.trackedSprite.x + this.trackOffset.x, this.trackedSprite.y + this.trackOffset.y);\n        } else {\n          this.fireFrom.x = this.trackedSprite.x + this.trackOffset.x;\n          this.fireFrom.y = this.trackedSprite.y + this.trackOffset.y;\n        }\n\n        if (this.bulletInheritSpriteSpeed) {\n          speed += this.trackedSprite.body.speed;\n        }\n      } else if (this.trackedPointer) {\n        if (this.fireFrom.width > 1) {\n          this.fireFrom.CenterOn(this.trackedPointer.x + this.trackOffset.x, this.trackedPointer.y + this.trackOffset.y);\n        } else {\n          this.fireFrom.x = this.trackedPointer.x + this.trackOffset.x;\n          this.fireFrom.y = this.trackedPointer.y + this.trackOffset.y;\n        }\n      }\n\n      if (offsetX !== undefined) {\n        this.fireFrom.x += offsetX;\n      }\n\n      if (offsetY !== undefined) {\n        this.fireFrom.y += offsetY;\n      }\n\n      var randomX = this.fireFrom.x + Math.random() * this.fireFrom.width;\n      var randomY = this.fireFrom.y + Math.random() * this.fireFrom.height;\n      var fromX = this.fireFrom.width > 1 ? randomX : this.fireFrom.x;\n      var fromY = this.fireFrom.height > 1 ? randomY : this.fireFrom.y;\n      var angle = this.trackRotation ? this.trackedSprite.angle : this.fireAngle; //  The position (in world space) to fire the bullet towards, if set\n\n      if (x !== null && y !== null) {\n        angle = Phaser.Math.RadToDeg(Math.atan2(y - fromY, x - fromX));\n      } //  Apply +- angle variance\n\n\n      if (this.bulletAngleVariance !== 0) {\n        angle += Phaser.Math.Between(-this.bulletAngleVariance, this.bulletAngleVariance);\n      }\n\n      var moveX = 0;\n      var moveY = 0; //  Avoid sin/cos for right-angled shots\n\n      if (angle === 0 || angle === 180) {\n        moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n      } else if (angle === 90 || angle === 270) {\n        moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n      } else {\n        moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n        moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n      }\n\n      var bullet = null;\n\n      if (this.autoExpandBulletsGroup) {\n        bullet = this.bullets.getFirstDead(true, fromX, fromY, this.bulletKey, this.bulletFrame);\n        bullet.data.bulletManager = this;\n      } else {\n        bullet = this.bullets.getFirstDead(false);\n      }\n\n      console.log(\"Got bullet: \".concat(bullet ? bullet.bulletID : 'none, :('));\n\n      if (bullet) {\n        bullet.prepare(fromX, fromY);\n        bullet.data.fromX = fromX;\n        bullet.data.fromY = fromY;\n        bullet.data.killType = this.bulletKillType;\n        bullet.data.killDistance = this.bulletKillDistance;\n        bullet.data.rotateToVelocity = this.bulletRotateToVelocity;\n\n        if (this.bulletKillType === consts.KILL_LIFESPAN) {\n          if (this.bulletLifespan <= 0) {\n            throw new Error('Invalid bulletLifespan; must be > 0');\n          }\n\n          bullet.data.timeEvent = this.scene.time.addEvent({\n            delay: this.bulletLifespan,\n            callback: bullet.kill.bind(bullet)\n          });\n          bullet.lifespan = this.bulletLifespan;\n        }\n\n        bullet.angle = angle + this.bulletAngleOffset; //  Frames and Animations\n\n        if (this.bulletAnimation) {\n          bullet.anims.play(this.bulletAnimation);\n        } else if (this.bulletFrameCycle) {\n          bullet.frame = this.bulletFrames[this.bulletFrameIndex];\n          this.bulletFrameIndex++;\n\n          if (this.bulletFrameIndex >= this.bulletFrames.length) {\n            this.bulletFrameIndex = 0;\n          }\n        } else if (this.bulletFrameRandom) {\n          bullet.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)];\n        }\n\n        if (bullet.data.bodyDirty) {\n          if (this._data.customBody) {\n            bullet.body.setSize(this._data.width, this._data.height);\n            bullet.body.setOffset(this._data.offsetX, this._data.offsetY);\n          }\n\n          bullet.body.collideWorldBounds = this.bulletCollideWorldBounds;\n          bullet.data.bodyDirty = false;\n        }\n\n        bullet.body.setVelocity(moveX, moveY);\n        bullet.body.setGravity(this.bulletGravity.x, this.bulletGravity.y);\n        var next = 0;\n\n        if (this.bulletSpeedVariance !== 0) {\n          var rate = this.fireRate;\n          rate += Phaser.Math.Between(-this.fireRateVariance, this.fireRateVariance);\n\n          if (rate < 0) {\n            rate = 0;\n          }\n\n          next = this.scene.time.now + rate;\n        } else {\n          next = this.scene.time.now + this.fireRate;\n        }\n\n        if (this.multiFire) {\n          if (!this._hasFired) {\n            //  We only add 1 to the 'shots' count for multiFire shots\n            this._hasFired = true;\n            this._tempNextFire = next;\n            this.shots++;\n          }\n        } else {\n          this._nextFire = next;\n          this.shots++;\n        }\n\n        this.eventEmitter.emit('fire', bullet, this, speed);\n\n        if (this.fireLimit > 0 && this.shots === this.fireLimit) {\n          this.eventEmitter('firelimit', this, this.fireLimit);\n        }\n      }\n\n      return bullet;\n    }\n    /**\n     * You can modify the size of the physics Body the Bullets use to be any dimension you need.\n     * This allows you to make it smaller, or larger, than the parent Sprite.\n     * You can also control the x and y offset of the Body. This is the position of the\n     * Body relative to the top-left of the Sprite _texture_.\n     *\n     * For example: If you have a Sprite with a texture that is 80x100 in size,\n     * and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:\n     *\n     * `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`\n     *\n     * Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.\n     * 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34\n     * is the vertical offset.\n     *\n     * @param {number} width - The width of the Body.\n     * @param {number} height - The height of the Body.\n     * @param {number} [offsetX] - The X offset of the Body from the top-left of the Sprites texture.\n     * @param {number} [offsetY] - The Y offset of the Body from the top-left of the Sprites texture.\n     * @return {Weapon} The Weapon Plugin.\n     */\n\n  }, {\n    key: \"setBulletBodyOffset\",\n    value: function setBulletBodyOffset(width, height, offsetX, offsetY) {\n      if (offsetX === undefined) {\n        offsetX = 0;\n      }\n\n      if (offsetY === undefined) {\n        offsetY = 0;\n      }\n\n      this._data.customBody = true;\n      this._data.width = width;\n      this._data.height = height;\n      this._data.offsetX = offsetX;\n      this._data.offsetY = offsetY; //  Update all bullets in the pool\n\n      this.bullets.children.each(function (child) {\n        child.body.setSize(width, height);\n        child.body.setOffset(offsetX, offsetY);\n      }); //this.bullets.setAll('data.bodyDirty', false);\n\n      return this;\n    }\n    /**\n     * Sets the texture frames that the bullets can use when being launched.\n     *\n     * This is intended for use when you've got numeric based frames, such as those loaded via a Sprite Sheet.\n     *\n     * It works by calling `Phaser.Utils.Array.NumberArray` internally, using the min and max values\n     * provided. Then it sets the frame index to be zero.\n     *\n     * You can optionally set the cycle and random booleans, to allow bullets to cycle through the frames\n     * when they're fired, or pick one at random.\n     *\n     * @param {integer} min - The minimum value the frame can be. Usually zero.\n     * @param {integer} max - The maximum value the frame can be.\n     * @param {boolean} [cycle=true] - Should the bullet frames cycle as they are fired?\n     * @param {boolean} [random=false] - Should the bullet frames be picked at random as they are fired?\n     * @return {Weapon} The Weapon Plugin.\n     */\n\n  }, {\n    key: \"setBulletFrames\",\n    value: function setBulletFrames(min, max, cycle, random) {\n      if (cycle === undefined) {\n        cycle = true;\n      }\n\n      if (random === undefined) {\n        random = false;\n      }\n\n      this.bulletFrames = Phaser.Utils.Array.NumberArray(min, max);\n      this.bulletFrameIndex = 0;\n      this.bulletFrameCycle = cycle;\n      this.bulletFrameRandom = random;\n      return this;\n    }\n    /**\n     * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n     * The arguments are all the same as for `Animation.add`, and work in the same way.\n     *\n     * {@link #bulletAnimation} will be set to this animation after it's created. From that point on, all\n     * bullets fired will play using this animation. You can swap between animations by calling this method\n     * several times, and then just changing the {@link #bulletAnimation} property to the name of the animation\n     * you wish to play for the next launched bullet.\n     *\n     * If you wish to stop using animations at all, set {@link #bulletAnimation} to '' (an empty string).\n     *\n     * @param {string} name - The unique (within the Weapon instance) name for the animation, i.e. \"fire\", \"blast\".\n     * @param {Array} [frames=null] - An array of numbers/strings that correspond to the frames to add to this animation and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n     * @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.\n     * @param {number} [loop=1] - Number of times to repeat the animation. Set to -1 to repeat forever.\n     * @return {Weapon} The Weapon Plugin.\n     */\n\n  }, {\n    key: \"addBulletAnimation\",\n    value: function addBulletAnimation(name, frames, frameRate, loop) {\n      if (!this.scene.sys.anims.anims.contains(name)) {\n        this.scene.sys.anims.create({\n          key: name,\n          frames: frames,\n          frameRate: frameRate,\n          loop: loop\n        });\n        this.anims[name] = this.scene.sys.anims.anims.entries[name];\n      }\n\n      this.bulletAnimation = name;\n      return this;\n    }\n    /**\n     * Uses `Game.Debug` to draw some useful information about this Weapon, including the number of bullets\n     * both in-flight, and available. And optionally the physics debug bodies of the bullets.\n     *\n     * @param {integer} [x=16] - The coordinate, in screen space, at which to draw the Weapon debug data.\n     * @param {integer} [y=32] - The coordinate, in screen space, at which to draw the Weapon debug data.\n     * @param {boolean} [debugBodies=false] - Optionally draw the physics body of every bullet in-flight.\n     */\n\n  }, {\n    key: \"debug\",\n    value: function debug(x, y, debugBodies) {}\n    /*if (x === undefined) {\n      x = 16;\n    }\n    if (y === undefined) {\n      y = 32;\n    }\n    if (debugBodies === undefined) {\n      debugBodies = false;\n    }\n     this.game.debug.text('Weapon Plugin', x, y);\n    this.game.debug.text(\n      'Bullets Alive: ' + this.bullets.total + ' - Total: ' + this.bullets.length,\n      x,\n      y + 24\n    );\n     if (debugBodies) {\n      this.bullets.forEachExists(this.game.debug.body, this.game.debug, 'rgba(255, 0, 255, 0.8)');\n    }*/\n\n    /**\n     * Internal update method, called by the Weapon Plugin.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      if (this._bulletKillType === consts.KILL_WEAPON_BOUNDS) {\n        if (this.trackedSprite) {\n          this.trackedSprite.updateTransform();\n          this.bounds.centerOn(this.trackedSprite.x, this.trackedSprite.y);\n        } else if (this.trackedPointer) {\n          this.bounds.centerOn(this.trackedPointer.x, this.trackedPointer.y);\n        }\n      }\n\n      if (this.autofire) {\n        this.fire();\n      }\n    }\n    /**\n     * Internal update method, called by the Weapon Plugin.\n     *\n     * @protected\n     * @returns {void}\n     */\n\n  }, {\n    key: \"postRender\",\n    value: function postRender() {\n      if (!this.multiFire || !this._hasFired) {\n        return;\n      }\n\n      this._hasFired = false;\n      this._nextFire = this._tempNextFire;\n    }\n    /**\n     * Destroys this Weapon.\n     * You must release everything in here, all references, all objects, free it all up.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.scene = null;\n      this.bullets.destroy(true);\n    }\n  }]);\n\n  return Weapon;\n}();\n/**\n * The Class of the bullets that are launched by this Weapon. Defaults to {@link Phaser.Bullet}, but can be\n * overridden before calling `createBullets` and set to your own class type.\n *\n * It should be a constructor function accepting `(game, x, y, key, frame)`.\n *\n * @name Weapon#bulletClass\n * @property {function} bulletClass\n */\n\n\nObject.defineProperty(Weapon.prototype, 'bulletClass', {\n  get: function get() {\n    return this._bulletClass;\n  },\n  set: function set(classType) {\n    this._bulletClass = classType; // `this.bullets` exists only after createBullets()\n\n    if (this.bullets) {\n      this.bullets.classType = this._bulletClass;\n    }\n  }\n});\n/**\n * This controls how the bullets will be killed. The default is `consts.KILL_WORLD_BOUNDS`.\n *\n * There are 7 different \"kill types\" available:\n *\n * * `consts.KILL_NEVER`\n * The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.\n *\n * * `consts.KILL_LIFESPAN`\n * The bullets are automatically killed when their `bulletLifespan` amount expires.\n *\n * * `consts.KILL_DISTANCE`\n * The bullets are automatically killed when they exceed `bulletDistance` pixels away from their original launch position.\n *\n * * `consts.KILL_WEAPON_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n *\n * * `consts.KILL_CAMERA_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.Camera#bounds} rectangle.\n *\n * * `consts.KILL_WORLD_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.World#bounds} rectangle.\n *\n * * `consts.KILL_STATIC_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n * The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to\n * match the position of a tracked sprite or pointer.\n *\n * @name Weapon#bulletKillType\n * @property {integer} bulletKillType\n */\n\nObject.defineProperty(Weapon.prototype, 'bulletKillType', {\n  get: function get() {\n    return this._bulletKillType;\n  },\n  set: function set(type) {\n    console.log(\"setting bulletKillType: \".concat(type));\n\n    switch (type) {\n      case consts.KILL_STATIC_BOUNDS:\n      case consts.KILL_WEAPON_BOUNDS:\n        this.bulletBounds = this.bounds;\n        break;\n\n      case consts.KILL_CAMERA_BOUNDS:\n        this.bulletBounds = this.scene.sys.cameras.main._bounds;\n        break;\n\n      case consts.KILL_WORLD_BOUNDS:\n        this.bulletBounds = this.scene.physics.world.bounds;\n        break;\n    }\n\n    this._bulletKillType = type;\n  }\n});\n/**\n * Should bullets collide with the World bounds or not?\n *\n * @name Weapon#bulletCollideWorldBounds\n * @property {boolean} bulletCollideWorldBounds\n */\n\nObject.defineProperty(Weapon.prototype, 'bulletCollideWorldBounds', {\n  get: function get() {\n    return this._bulletCollideWorldBounds;\n  },\n  set: function set(value) {\n    this._bulletCollideWorldBounds = value;\n    this.bullets.children.each(function (child) {\n      child.body.collideWorldBounds = value;\n      child.data.bodyDirty = false;\n    });\n  }\n});\n/**\n * The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and\n * can be overridden by the {@link #fire} arguments.\n *\n * @name Weapon#x\n * @property {number} x\n */\n\nObject.defineProperty(Weapon.prototype, 'x', {\n  get: function get() {\n    return this.fireFrom.x;\n  },\n  set: function set(value) {\n    this.fireFrom.x = value;\n  }\n});\n/**\n * The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and\n * can be overridden by the {@link #fire} arguments.\n *\n * @name Weapon#y\n * @property {number} y\n */\n\nObject.defineProperty(Weapon.prototype, 'y', {\n  get: function get() {\n    return this.fireFrom.y;\n  },\n  set: function set(value) {\n    this.fireFrom.y = value;\n  }\n});\nmodule.exports = Weapon;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// WeaponPlugin.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 944b478c7a45f5608d57","module.exports = {\n  /**\n   * A {@link #bulletKillType} constant that stops the bullets from ever being destroyed automatically.\n   * @constant\n   * @type {integer}\n   */\n  KILL_NEVER: 0,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when their {@link #bulletLifespan} expires.\n   * @constant\n   * @type {integer}\n   */\n  KILL_LIFESPAN: 1,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets after they\n   * exceed the {@link #bulletDistance} from their original firing position.\n   * @constant\n   * @type {integer}\n   */\n  KILL_DISTANCE: 2,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WEAPON_BOUNDS: 3,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link Phaser.Camera#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_CAMERA_BOUNDS: 4,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link Phaser.World#bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_WORLD_BOUNDS: 5,\n\n  /**\n   * A {@link #bulletKillType} constant that automatically kills the bullets when they leave the {@link #bounds} rectangle.\n   * @constant\n   * @type {integer}\n   */\n  KILL_STATIC_BOUNDS: 6,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face up.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_UP: 270,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face down.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_DOWN: 90,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face left.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_LEFT: 180,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face right.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_RIGHT: 0,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north east.\n   * @constant Phaser.ANGLE_NORTH_EAST\n   * @type {integer}\n   */\n  ANGLE_NORTH_EAST: 315,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face north west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_NORTH_WEST: 225,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south east.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_EAST: 45,\n\n  /**\n   * The Angle (in degrees) a Game Object needs to be set to in order to face south west.\n   * @constant\n   * @type {integer}\n   */\n  ANGLE_SOUTH_WEST: 135,\n};\n\n\n\n// WEBPACK FOOTER //\n// ./consts.js","/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n */\n\nconst consts = require('./consts');\n\nlet bulletID = 0\n\nclass Bullet extends Phaser.GameObjects.Sprite {\n  /**\n   * Create a new `Bullet` object. Bullets are used by the `Weapon` class, and are normal Sprites,\n   * with a few extra properties in the data object to handle Weapon specific features.\n   *\n   * @param {Phaser.Scene} scene - A reference to the currently running scene.\n   * @param {number} x - The x coordinate (in world space) to position the Particle at.\n   * @param {number} y - The y coordinate (in world space) to position the Particle at.\n   * @param {string} key - This is the image or texture used by the Particle during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this Particle is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n   */\n  constructor(scene, x, y, key, frame) {\n    super(scene, x, y, key, frame);\n    this.bulletID = bulletID\n    bulletID++\n    this.scene.physics.add.existing(this);\n\n    this.data = {\n      timeEvent: null,\n      bulletManager: null,\n      fromX: 0,\n      fromY: 0,\n      bodyDirty: true,\n      rotateToVelocity: false,\n      killType: 0,\n      killDistance: 0,\n      bodyBounds: new Phaser.Geom.Rectangle()\n    };\n  }\n\n  /**\n   * Prepares this bullet to be fired and interact with the rest of the scene\n   * again.\n   */\n  prepare(x, y) {\n    this.setActive(true);\n    this.setVisible(true);\n    this.body.enable = true;\n    this.body.reset(x, y);\n    this.body.debugShowBody = this.data.bulletManager.debugPhysics;\n    this.body.debugShowVelocity = this.data.bulletManager.debugPhysics;\n  }\n\n  /**\n   * Kills the Bullet, freeing it up for re-use by the Weapon bullet pool.\n   * Also dispatches the `Weapon`s kill signal.\n   * @returns {Bullet} This instance of the bullet class\n   */\n  kill() {\n    console.log(`Killing bullet ${this.bulletID}`)\n\n    // Reproduce Phaser.Physics.Arcade.Components.Enable.disableBody because\n    // we can't assume that the bullet class has it built in.\n    this.body.stop();\n    this.body.enable = false;\n    this.setActive(false);\n    this.setVisible(false);\n    this.body.debugShowBody = false;\n    this.body.debugShowVelocity = false;\n\n    // TODO: potentially we don't need to destroy the time event and we can\n    // just pause when the bullet is killed and restart it when it's refired.\n    // For now though do the simple thing and discard it.\n    // Another option would be to use Date.now() and manually process pause\n    // events with a flag and some math.\n    // Both of those are probably premature optimizations.\n    if (this.data.timeEvent !== null) {\n      this.data.timeEvent.destroy();\n      this.data.timeEvent = null;\n    }\n\n    this.data.bulletManager.eventEmitter.emit('kill', this);\n\n    return this;\n  }\n\n  /**\n   * Updates the Bullet, killing as required.\n   * @returns {Bullet} This instance of the bullet class\n   */\n  update() {\n    if (!this.active) {\n      // this was previously a check to this.exists\n      return;\n    }\n\n    if (this.data.killType > consts.KILL_LIFESPAN) {\n      if (this.data.killType === consts.KILL_DISTANCE) {\n        if (\n          new Phaser.Math.Vector2(this.data.fromX, this.data.fromY).distance(this) >\n          this.data.killDistance\n        ) {\n          this.kill();\n        }\n      } else if (!Phaser.Geom.Intersects.RectangleToRectangle(\n          this.data.bulletManager.bulletBounds,\n          this.body.getBounds(this.data.bodyBounds)\n        )) {\n        this.kill();\n      }\n    }\n\n    if (this.data.rotateToVelocity) {\n      this.rotation = this.body.velocity.atan();\n    }\n\n    if (this.data.bulletManager.bulletWorldWrap) {\n      this.scene.physics.world.wrap(\n        this,\n        this.data.bulletManager.bulletWorldWrapPadding\n      );\n    }\n  }\n}\n\nmodule.exports = Bullet;\n\n\n\n// WEBPACK FOOTER //\n// ./Bullet.js","/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n */\nconst Weapon = require('./Weapon');\nconst Bullet = require('./Bullet');\nconst consts = require('./consts');\n\n/**\n * The Weapon Plugin provides the ability to easily create a bullet pool\n * and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with Impact or Matter Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, such as move it around the display list, iterate it, etc can\n * be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.set(300, 300);\n * this.input.onDown.add(weapon.fire, this); // Update this\n * ```\n */\nclass WeaponPlugin extends Phaser.Plugins.ScenePlugin {\n  /**\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   * @param {Phaser.Plugins.PluginManager} pluginManager - A reference to the\n   *  Phaser.Plugins.PluginManager instance.\n   */\n  constructor(scene, pluginManager) {\n    super(scene, pluginManager);\n\n    this.weapons = [];\n\n    // Register our new Game Object type\n    // pluginManager.registerGameObject('weapon', this.add);\n  }\n\n  add(bulletLimit, key, frame, group, weaponClass) {\n    if (!weaponClass) {\n      weaponClass = Weapon\n    }\n    const weapon = new weaponClass(this.scene, bulletLimit, key, frame, group);\n\n    this.weapons.push(weapon);\n\n    return weapon;\n  }\n\n  /**\n   * Called by the PluginManager when this plugin is started.\n   * If a plugin is stopped, and then started again, this will get called again.\n   * Typically called immediately after `BasePlugin.init`.\n   *\n   * @returns {void}\n   */\n  start() {\n    eventEmitter.on('postrender', this.postRender, this);\n  }\n\n  /**\n   * If this is a Scene Plugin (i.e. installed into a Scene) then this method is called when the Scene boots.\n   * By this point the plugin properties `scene` and `systems` will have already been set.\n   * In here you can listen for Scene events and set-up whatever you need for this plugin to run.\n   * @returns {void}\n   */\n  boot() {\n    const eventEmitter = this.systems.events;\n\n    //  Listening to the following events is entirely optional, although we would recommend cleanly shutting down and destroying at least.\n    //  If you don't need any of these events then remove the listeners and the relevant methods too.\n\n    eventEmitter.on('preupdate', this.preUpdate, this);\n    eventEmitter.on('update', this.update, this);\n    eventEmitter.on('postupdate', this.postUpdate, this);\n\n    eventEmitter.on('pause', this.pause, this);\n    eventEmitter.on('resume', this.resume, this);\n\n    eventEmitter.on('sleep', this.sleep, this);\n    eventEmitter.on('wake', this.wake, this);\n\n    eventEmitter.on('shutdown', this.shutdown, this);\n    eventEmitter.on('destroy', this.destroy, this);\n  }\n\n  //  Called every Scene step - phase 1\n  preUpdate(time, delta) {\n    // Empty\n  }\n\n  /**\n   * Internal update method, called by the PluginManager.\n   *\n   * @protected\n   * @param {number} time - Current game time\n   * @param {number} delta - Time since last call\n   * @returns {void}\n   */\n  update(time, delta) {\n    this.weapons.forEach(weapon => {\n      weapon.update();\n    });\n  }\n\n  //  Called every Scene step - phase 3\n  postUpdate(time, delta) {\n    // Empty\n  }\n\n  /**\n   * Internal update method, called by the PluginManager.\n   *\n   * @protected\n   * @returns {void}\n   */\n  postRender() {\n    this.weapons.forEach(weapon => {\n      weapon.postRender();\n    });\n  }\n\n  //  Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n  pause() {\n    // Empty\n  }\n\n  //  Called when a Scene is resumed from a paused state.\n  resume() {\n    // Empty\n  }\n\n  //  Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n  sleep() {\n    // Empty\n  }\n\n  //  Called when a Scene is woken from a sleeping state.\n  wake() {\n    // Empty\n  }\n\n  //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n  shutdown() {\n    // Empty\n  }\n\n  /**\n   * Destroys this Weapon.\n   * You must release everything in here, all references, all objects, free it all up.\n   * @returns {void}\n   */\n  destroy() {\n    this.pluginManager = null;\n    this.game = null;\n    this.scene = null;\n    this.systems = null;\n  }\n}\n\nWeaponPlugin.Weapon = Weapon;\nWeaponPlugin.Bullet = Bullet;\n\nWeaponPlugin.consts = consts\n\n//  Make sure you export the plugin for webpack to expose\n\nmodule.exports = WeaponPlugin;\n\n\n\n// WEBPACK FOOTER //\n// ./main.js","/**\n * @author       Patrick Sletvold\n * @author       jdotr <https://github.com/jdotrjs>\n * @author       Richard Davey\n * @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}\n */\nconst Bullet = require('./Bullet');\nconst consts = require('./consts');\n\n/**\n * The Weapon provides the ability to easily create a bullet pool and manager.\n *\n * Weapons fire {@link Bullet} objects, which are essentially Sprites with a\n * few extra properties. The Bullets are enabled for Arcade Physics. They do\n * not currently work with P2 Physics.\n *\n * The Bullets are created inside of {@link #bullets weapon.bullets}, which is\n * a {@link Phaser.GameObjects.Group} instance. Anything you can usually do\n * with a Group, such as move it around the display list, iterate it, etc can\n * be done to the bullets Group too.\n *\n * Bullets can have textures and even animations. You can control the speed at\n * which they are fired, the firing rate, the firing angle, and even set things\n * like gravity for them.\n *\n * A small example, using add.weapon, assumed to be running from within a\n * {@link Phaser.Scene#create} method:\n *\n * ```javascript\n * var weapon = this.add.weapon(10, 'bullet');\n * weapon.fireFrom.set(300, 300);\n * this.input.onDown.add(weapon.fire, this); // Update this\n * ```\n */\nclass Weapon {\n  /**\n   * TODO: a builder style interface would be neat. Can be kicked way forward\n   * into polishing.\n   * @param {Phaser.Scene} scene - A reference to the Phaser.Scene instance.\n   */\n  constructor(scene, bulletLimit, key, frame, group) {\n    this.scene = scene;\n\n    this.debugPhysics = null;\n\n    /**\n     * This is the Phaser.Group that contains all of the bullets managed by this plugin.\n     * @type {Phaser.GameObjects.Group}\n     */\n    this.bullets = null;\n\n    /**\n     * Should the bullet pool run out of bullets (i.e. they are all in flight) then this\n     * boolean controls if the Group will create a brand new bullet object or not.\n     * @type {boolean}\n     * @default\n     */\n    this.autoExpandBulletsGroup = false;\n\n    /**\n     * Will this weapon auto fire? If set to true then a new bullet will be fired\n     * based on the {@link #fireRate} value.\n     * @type {boolean}\n     * @default\n     */\n    this.autofire = false;\n\n    /**\n     * The total number of bullets this Weapon has fired so far.\n     * You can limit the number of shots allowed (via {@link #fireLimit}), and reset\n     * this total via {@link #resetShots}.\n     * @type {number}\n     * @default\n     */\n    this.shots = 0;\n\n    /**\n     * The maximum number of shots that this Weapon is allowed to fire before it stops.\n     * When the limit is his the {@link #onFireLimit} Signal is dispatched.\n     * You can reset the shot counter via {@link #resetShots}.\n     * @type {number}\n     * @default\n     */\n    this.fireLimit = 0;\n\n    /**\n     * The minimum interval between shots, in milliseconds.\n     * @type {number}\n     * @default\n     */\n    this.fireRate = 100;\n\n    /**\n     * This is a modifier that is added to the {@link #fireRate} each update to add variety\n     * to the firing rate of the Weapon. The value is given in milliseconds.\n     * If you've a `fireRate` of 200 and a `fireRateVariance` of 50 then the actual\n     * firing rate of the Weapon will be between 150 and 250.\n     * @type {number}\n     * @default\n     */\n    this.fireRateVariance = 0;\n\n    /**\n     * This is a Rectangle from within which the bullets are fired. By default it's a 1x1\n     * rectangle, the equivalent of a Point. But you can change the width and height, and if\n     * larger than 1x1 it'll pick a random point within the rectangle to launch the bullet from.\n     * @type {Phaser.Geom.Rectangle}\n     */\n    this.fireFrom = new Phaser.Geom.Rectangle(0, 0, 1, 1);\n\n    /**\n     * The angle at which the bullets are fired. This can be a const such as Phaser.ANGLE_UP\n     * or it can be any number from 0 to 360 inclusive, where 0 degrees is to the right.\n     * @type {integer}\n     * @default\n     */\n    this.fireAngle = consts.ANGLE_UP;\n\n    /**\n     * When a Bullet is fired it can optionally inherit the velocity of the `trackedSprite` if set.\n     * @type {boolean}\n     * @default\n     */\n    this.bulletInheritSpriteSpeed = false;\n\n    /**\n     * The string based name of the animation that the Bullet will be given on launch.\n     * This is set via {@link #addBulletAnimation}.\n     * @type {string}\n     * @default\n     */\n    this.bulletAnimation = '';\n\n    /**\n     * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n     * chose for each Bullet fired to pick a random frame from the set.\n     * @type {boolean}\n     * @default\n     */\n    this.bulletFrameRandom = false;\n\n    /**\n     * If you've added a set of frames via {@link #setBulletFrames} then you can optionally\n     * chose for each Bullet fired to use the next frame in the set. The frame index is then\n     * advanced one frame until it reaches the end of the set, then it starts from the start\n     * again. Cycling frames like this allows you to create varied bullet effects via\n     * sprite sheets.\n     * @type {boolean}\n     * @default\n     */\n    this.bulletFrameCycle = false;\n\n    /**\n     * Should the Bullets wrap around the world bounds? This automatically calls\n     * `World.wrap` on the Bullet each frame. See the docs for that method for details.\n     * @type {boolean}\n     * @default\n     */\n    this.bulletWorldWrap = false;\n\n    /**\n     * If `bulletWorldWrap` is true then you can provide an optional padding value with this\n     * property. It's added to the calculations determining when the Bullet should wrap around\n     * the world or not. The value is given in pixels.\n     * @type {integer}\n     * @default\n     */\n    this.bulletWorldWrapPadding = 0;\n\n    /**\n     * An optional angle offset applied to the Bullets when they are launched.\n     * This is useful if for example your bullet sprites have been drawn facing up, instead of\n     * to the right, and you want to fire them at an angle. In which case you can set the\n     * angle offset to be 90 and they'll be properly rotated when fired.\n     * @type {number}\n     * @default\n     */\n    this.bulletAngleOffset = 0;\n\n    /**\n     * This is a variance added to the angle of Bullets when they are fired.\n     * If you fire from an angle of 90 and have a `bulletAngleVariance` of 20 then the actual\n     * angle of the Bullets will be between 70 and 110 degrees. This is a quick way to add a\n     * great 'spread' effect to a Weapon.\n     * @type {number}\n     * @default\n     */\n    this.bulletAngleVariance = 0;\n\n    /**\n     * The initial velocity of fired bullets, in pixels per second.\n     * @type {number}\n     * @default\n     */\n    this.bulletSpeed = 200;\n\n    /**\n     * This is a variance added to the speed of Bullets when they are fired.\n     * If bullets have a {@link #bulletSpeed} value of 200, and a `bulletSpeedVariance` of 50\n     * then the actual speed of the Bullets will be between 150 and 250 pixels per second.\n     * @type {number}\n     * @default\n     */\n    this.bulletSpeedVariance = 0;\n\n    /**\n     * If you've set {@link #bulletKillType} to `consts.KILL_LIFESPAN` this controls the amount\n     * of lifespan the Bullets have set on launch. The value is given in milliseconds.\n     * When a Bullet hits its lifespan limit it will be automatically killed.\n     * @type {number}\n     * @default\n     */\n    this.bulletLifespan = 0;\n\n    /**\n     * If you've set {@link #bulletKillType} to `consts.KILL_DISTANCE` this controls the distance\n     * the Bullet can travel before it is automatically killed. The distance is given in pixels.\n     * @type {number}\n     * @default\n     */\n    this.bulletKillDistance = 0;\n\n    /**\n     * This is the amount of {@link Phaser.Physics.Arcade.Body#gravity} added to the Bullets physics body when fired.\n     * Gravity is expressed in pixels / second / second.\n     * @type {Phaser.Math.Vector2}\n     */\n    this.bulletGravity = new Phaser.Math.Vector2(0, 0);\n\n    /**\n     * Bullets can optionally adjust their rotation in-flight to match their velocity.\n     * This can create the effect of a bullet 'pointing' to the path it is following, for example\n     * an arrow being fired from a bow, and works especially well when added to {@link #bulletGravity}.\n     * @type {boolean}\n     * @default\n     */\n    this.bulletRotateToVelocity = false;\n\n    /**\n     * The Texture Key that the Bullets use when rendering.\n     * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n     * @type {string}\n     * @default\n     */\n    this.bulletKey = key || '';\n\n    /**\n     * The Texture Frame that the Bullets use when rendering.\n     * Changing this has no effect on bullets in-flight, only on newly spawned bullets.\n     * @type {string|integer}\n     * @default\n     */\n    this.bulletFrame = frame || '';\n\n    /**\n     * Private var that holds the public `bulletClass` property.\n     * @type {function}\n     * @private\n     */\n    this._bulletClass = Bullet;\n\n    /**\n     * Private var that holds the public `bulletCollideWorldBounds` property.\n     * @type {boolean}\n     * @private\n     */\n    this._bulletCollideWorldBounds = false;\n\n    /**\n     * Private var that holds the public `bulletKillType` property.\n     * @type {integer}\n     * @private\n     */\n    this._bulletKillType = consts.KILL_WORLD_BOUNDS;\n\n    /**\n     * Holds internal data about custom bullet body sizes.\n     *\n     * @type {Object}\n     * @private\n     */\n    this._data = {\n      customBody: false,\n      width: 0,\n      height: 0,\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    /**\n     * This Rectangle defines the bounds that are used when determining if a Bullet should be killed or not.\n     * It's used in combination with {@link #bulletKillType} when that is set to either `consts.KILL_WEAPON_BOUNDS`\n     * or `consts.KILL_STATIC_BOUNDS`. If you are not using either of these kill types then the bounds are ignored.\n     * If you are tracking a Sprite or Point then the bounds are centered on that object every frame.\n     *\n     * @type {Phaser.Geom.Rectangle}\n     */\n    this.bounds = new Phaser.Geom.Rectangle();\n\n    /**\n     * The Rectangle used to calculate the bullet bounds from.\n     *\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     */\n    this.bulletBounds = this.scene.physics.world.bounds;\n\n    /**\n     * This array stores the frames added via @link #setBulletFrames.\n     *\n     * @type {Array}\n     * @protected\n     */\n    this.bulletFrames = [];\n\n    /**\n     * The index of the frame within {@link #bulletFrames} that is currently being used.\n     * This value is only used if {@link #bulletFrameCycle} is set to `true`.\n     * @type {number}\n     * @private\n     */\n    this.bulletFrameIndex = 0;\n\n    /**\n     * An internal object that stores the animation data added via {@link #addBulletAnimation}.\n     * @type {Object}\n     * @private\n     */\n    this.anims = {};\n\n    /**\n     * The Sprite currently being tracked by the Weapon, if any.\n     * This is set via the {@link #trackSprite} method.\n     *\n     * @type {Phaser.GameObjects.Sprite|Object}\n     */\n    this.trackedSprite = null;\n\n    /**\n     * The Pointer currently being tracked by the Weapon, if any.\n     * This is set via the {@link #trackPointer} method.\n     *\n     * @type {Phaser.Input.Pointer}\n     */\n    this.trackedPointer = null;\n\n    /**\n     * If you want this Weapon to be able to fire more than 1 bullet in a single\n     * update, then set this property to `true`. When `true` the Weapon plugin won't\n     * set the shot / firing timers until the `postRender` phase of the game loop.\n     * This means you can call `fire` (and similar methods) as often as you like in one\n     * single game update.\n     *\n     * @type {boolean}\n     * @default\n     */\n    this.multiFire = false;\n\n    /**\n     * Internal multiFire test flag.\n     *\n     * @type {boolean}\n     */\n    this._hasFired = false;\n\n    /**\n     * If the Weapon is tracking a Sprite, should it also track the Sprites rotation?\n     * This is useful for a game such as Asteroids, where you want the weapon to fire based\n     * on the sprites rotation.\n     *\n     * @type {boolean}\n     * @default\n     */\n    this.trackRotation = false;\n\n    /**\n     * The Track Offset is a Vector2 object that allows you to specify a pixel offset that bullets use\n     * when launching from a tracked Sprite or Pointer. For example if you've got a bullet that is 2x2 pixels\n     * in size, but you're tracking a Sprite that is 32x32, then you can set `trackOffset.x = 16` to have\n     * the bullet launched from the center of the Sprite.\n     *\n     * @type {Phaser.Math.Vector2}\n     */\n    this.trackOffset = new Phaser.Math.Vector2();\n\n    /**\n     * Internal firing rate time tracking variable.\n     *\n     * @type {number}\n     * @private\n     */\n    this._nextFire = 0;\n\n    /**\n     * Internal firing rate time tracking variable used by multiFire.\n     *\n     * @type {number}\n     * @private\n     */\n    this._tempNextFire = 0;\n\n    /**\n     * Internal firing rotation tracking point.\n     *\n     * @type {Phaser.Math.Vector2}\n     * @private\n     */\n    this._rotatedPoint = new Phaser.Math.Vector2();\n\n    this.eventEmitter = new Phaser.Events.EventEmitter();\n\n    this.createBullets(bulletLimit, key, frame, group);\n  }\n\n  /**\n   * This method performs two actions: First it will check to see if the {@link #bullets} Group exists or not,\n   * and if not it creates it, adding it the `group` given as the 4th argument.\n   *\n   * Then it will seed the bullet pool with the `quantity` number of Bullets, using the texture key and frame\n   * provided (if any).\n   *\n   * If for example you set the quantity to be 10, then this Weapon will only ever be able to have 10 bullets\n   * in-flight simultaneously. If you try to fire an 11th bullet then nothing will happen until one, or more, of\n   * the in-flight bullets have been killed, freeing them up for use by the Weapon again.\n   *\n   * If you do not wish to have a limit set, then pass in -1 as the quantity. In this instance the Weapon will\n   * keep increasing the size of the bullet pool as needed. It will never reduce the size of the pool however,\n   * so be careful it doesn't grow too large.\n   *\n   * You can either set the texture key and frame here, or via the {@link #bulletKey} and {@link #bulletFrame}\n   * properties. You can also animate bullets, or set them to use random frames. All Bullets belonging to a\n   * single Weapon instance must share the same texture key however.\n   *\n   * @param {integer} [quantity=1] - The quantity of bullets to seed the Weapon with. If -1 it will set the pool to automatically expand.\n   * @param {string} [key] - The Game.cache key of the image that this Sprite will use.\n   * @param {integer|string} [frame] - If the Sprite image contains multiple frames you can specify which one to use here.\n   * @param {Phaser.GameObjects.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n   * @return {Weapon} This Weapon instance.\n   */\n  createBullets(quantity, key, frame, group, bulletClass) {\n    if (quantity === undefined) {\n      quantity = 1;\n    }\n    if (bulletClass) {\n      this._bulletClass = bulletClass\n    }\n    /*if (group === undefined) {\n      group = this.game.world;\n    }*/\n\n    if (this.bullets && !this.bullets.scene) {\n      this.bullets = null;\n    }\n\n    if (!this.bullets) {\n      this.bullets = this.scene.add.group({\n        classType: this._bulletClass,\n        maxSize: quantity,\n        runChildUpdate: true\n      });\n    }\n\n    if (quantity !== 0) {\n      if (quantity === -1) {\n        this.autoExpandBulletsGroup = true;\n        quantity = 1;\n      }\n\n      this.bullets.createMultiple({\n        key,\n        frame,\n        repeat: quantity,\n        active: false,\n        visible: false\n      });\n\n      this.bullets.children.each(function (child) {\n        child.data.bulletManager = this\n      }, this);\n\n      this.bulletKey = key;\n      this.bulletFrame = frame;\n\n      if (group) {\n        group.addMultiple(this.bullets.children.entries)\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Call a function on each in-flight bullet in this Weapon.\n   *\n   * See {@link Phaser.GameObjects.Group#forEachExists forEachExists} for more details.\n   *\n   * @param {function} callback - The function that will be called for each applicable child. The child will be passed as the first argument.\n   * @param {object} callbackContext - The context in which the function should be called (usually 'this').\n   * @param {...any} [args=(none)] - Additional arguments to pass to the callback function, after the child item.\n   * @return {Weapon} This Weapon instance.\n   */\n  forEach(callback, callbackContext) {\n    const extraArgs = arguments;\n\n    this.bullets.children.each(child => {\n      if (child.active) {\n        callback.call(callbackContext, child, extraArgs);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `false` on each bullet in this Weapon.\n   * This has the effect of stopping them in-flight should they be moving.\n   * It also stops them being able to be checked for collision.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  pauseAll() {\n    this.bullets.children.each(child => {\n      child.body.enable = false;\n      if (child.data.timeEvent !== null) {\n        child.data.timeEvent.paused = true;\n      }\n    }, this);\n\n    return this;\n  }\n\n  /**\n   * Sets {@link Phaser.Physics.Arcade.Body#enable} to `true` on each bullet in this Weapon.\n   * This has the effect of resuming their motion should they be in-flight.\n   * It also enables them for collision checks again.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  resumeAll() {\n    this.bullets.children.each(child => {\n      child.body.enable = true;\n      if (child.data.timeEvent !== null) {\n        child.data.timeEvent.paused = false;\n      }\n    }, this);\n\n    return this;\n  }\n\n  /**\n   * Calls {@link Phaser.Bullet#kill} on every in-flight bullet in this Weapon.\n   * Also re-enables their physics bodies, should they have been disabled via {@link #pauseAll}.\n   *\n   * @return {Weapon} This Weapon instance.\n   */\n  killAll() {\n    this.bullets.children.each(child => {\n      if (child.active) {\n        child.kill();\n      }\n      child.body.enable = true;\n    });\n\n    return this;\n  }\n\n  /**\n   * Resets the {@link #shots} counter back to zero. This is used when you've set\n   * {@link #fireLimit} and have hit (or just wish to reset) your limit.\n   *\n   * @param {integer} [newLimit] - Optionally set a new {@link #fireLimit}.\n   * @return {Weapon} This Weapon instance.\n   */\n  resetShots(newLimit) {\n    this.shots = 0;\n\n    if (newLimit !== undefined) {\n      this.fireLimit = newLimit;\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets this Weapon to track the given Sprite, or any Object with a public {@link Phaser.Component.Core#world world} Point object.\n   * When a Weapon tracks a Sprite it will automatically update its {@link #fireFrom} value to match the Sprite's\n   * position within the Game World, adjusting the coordinates based on the offset arguments.\n   *\n   * This allows you to lock a Weapon to a Sprite, so that bullets are always launched from its location.\n   *\n   * Calling `trackSprite` will reset {@link #trackedPointer} to null, should it have been set, as you can\n   * only track _either_ a Sprite, or a Pointer, at once, but not both.\n   *\n   * @param {Phaser.GameObjects.Sprite|Object} sprite - The Sprite to track the position of.\n   * @param {integer} [offsetX=0] - The horizontal offset from the Sprites position to be applied to the Weapon.\n   * @param {integer} [offsetY=0] - The vertical offset from the Sprites position to be applied to the Weapon.\n   * @param {boolean} [trackRotation=false] - Should the Weapon also track the Sprites rotation?\n   * @return {Weapon} This Weapon instance.\n   */\n  trackSprite(sprite, offsetX, offsetY, trackRotation) {\n    if (offsetX === undefined) {\n      offsetX = 0;\n    }\n    if (offsetY === undefined) {\n      offsetY = 0;\n    }\n    if (trackRotation === undefined) {\n      trackRotation = false;\n    }\n\n    this.trackedPointer = null;\n    this.trackedSprite = sprite;\n    this.trackRotation = trackRotation;\n\n    this.trackOffset.set(offsetX, offsetY);\n\n    return this;\n  }\n\n  /**\n   * Sets this Weapon to track the given Pointer.\n   * When a Weapon tracks a Pointer it will automatically update its {@link #fireFrom} value to match the Pointer's\n   * position within the Game World, adjusting the coordinates based on the offset arguments.\n   *\n   * This allows you to lock a Weapon to a Pointer, so that bullets are always launched from its location.\n   *\n   * Calling `trackPointer` will reset {@link #trackedSprite} to null, should it have been set, as you can\n   * only track _either_ a Pointer, or a Sprite, at once, but not both.\n   *\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to track the position of. Defaults to `Input.activePointer` if not specified.\n   * @param {integer} [offsetX=0] - The horizontal offset from the Pointers position to be applied to the Weapon.\n   * @param {integer} [offsetY=0] - The vertical offset from the Pointers position to be applied to the Weapon.\n   * @return {Weapon} This Weapon instance.\n   */\n  trackPointer(pointer, offsetX, offsetY) {\n    if (pointer === undefined && this.scene.input) {\n      pointer = this.scene.input.activePointer;\n    }\n    if (offsetX === undefined) {\n      offsetX = 0;\n    }\n    if (offsetY === undefined) {\n      offsetY = 0;\n    }\n\n    this.trackedPointer = pointer;\n    this.trackedSprite = null;\n    this.trackRotation = false;\n\n    this.trackOffset.set(offsetX, offsetY);\n\n    return this;\n  }\n\n  /**\n   * Attempts to fire multiple bullets from the positions defined in the given array.\n   *\n   * If you provide a `from` argument, or if there is a tracked Sprite or Pointer, then\n   * the positions are treated as __offsets__ from the given objects position.\n   *\n   * If `from` is undefined, and there is no tracked object, then the bullets are fired\n   * from the given positions, as they exist in the world.\n   *\n   * Calling this method sets {@link #multiFire} to `true`.\n   *\n   * If there are not enough bullets available in the pool, and the pool cannot be extended,\n   * then this method may not fire from all of the given positions.\n   *\n   * When the bullets are launched they have their texture and frame updated, as required.\n   * The velocity of the bullets are calculated based on Weapon properties like {@link #bulletSpeed}.\n   *\n   * @param {array} positions - An array of positions. Each position can be any Object, as long as it has public `x` and `y` properties, such as Phaser.Point, { x: 0, y: 0 }, Phaser.Sprite, etc.\n   * @param {Phaser.GameObject.Sprite|Phaser.Math.Vector2|Object|string} [from] - Optionally fires the bullets **from** the `x` and `y` properties of this object, _instead_ of any {@link #trackedSprite} or `trackedPointer` that is set.\n   * @return {array} An array containing all of the fired Phaser.Bullet objects, if a launch was successful, otherwise an empty array.\n   */\n  fireMany(positions, from) {\n    this.multiFire = true;\n\n    const bullets = [];\n\n    if (from || this.trackedSprite || this.trackedPointer) {\n      positions.forEach(offset => {\n        bullets.push(this.fire(from, null, null, offset.x, offset.y));\n      });\n    } else {\n      positions.forEach(position => {\n        bullets.push(this.fire(position));\n      });\n    }\n\n    return bullets;\n  }\n\n  /**\n   * Attempts to fire a single Bullet from a tracked Sprite or Pointer, but applies an offset\n   * to the position first. This is the same as calling {@link #fire} and passing in the offset arguments.\n   *\n   * If there are no more bullets available in the pool, and the pool cannot be extended,\n   * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n   * the Weapon was fired, as defined in the {@link #fireRate} property.\n   *\n   * Otherwise the first available bullet is selected, launched, and returned.\n   *\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n   * calculated based on Weapon properties like {@link #bulletSpeed}.\n   *\n   * If you wish to fire multiple bullets in a single game update, then set {@link #multiFire} to `true`\n   * and you can call this method as many times as you like, per loop. See also {@link #fireMany}.\n   *\n   * @param {number} [offsetX=0] - The horizontal offset from the position of the tracked Sprite or Pointer, as set with {@link #trackSprite}.\n   * @param {number} [offsetY=0] - The vertical offset from the position of the tracked Sprite or Pointer, as set with {@link #trackSprite}.\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n   */\n  fireOffset(offsetX, offsetY) {\n    if (offsetX === undefined) {\n      offsetX = 0;\n    }\n    if (offsetY === undefined) {\n      offsetY = 0;\n    }\n\n    return this.fire(null, null, null, offsetX, offsetY);\n  }\n\n  /**\n   * Fires a bullet **at** the given Pointer. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtPointer(pointer) {\n    if (pointer === undefined && this.scene.input) {\n      pointer = this.scene.input.activePointer;\n    }\n\n    return this.fire(null, pointer.x, pointer.y);\n  }\n\n  /**\n   * Fires a bullet **at** the given Sprite. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {Phaser.GameObjects.Sprite} [sprite] - The Sprite to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtSprite(sprite) {\n    return this.fire(null, sprite.x, sprite.y);\n  }\n\n  /**\n   * Fires a bullet **at** the given coordinates. The bullet will be launched from the {@link #fireFrom} position,\n   * or from a Tracked Sprite or Pointer, if you have one set.\n   *\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet towards.\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet towards.\n   * @return {Bullet} The fired bullet if successful, null otherwise.\n   */\n  fireAtXY(x, y) {\n    return this.fire(null, x, y);\n  }\n\n  /**\n   * Attempts to fire a single Bullet. If there are no more bullets available in the pool, and the pool cannot be extended,\n   * then this method returns `null`. It will also return `null` if not enough time has expired since the last time\n   * the Weapon was fired, as defined in the {@link #fireRate} property.\n   *\n   * Otherwise the first available bullet is selected, launched, and returned.\n   *\n   * The arguments are all optional, but allow you to control both where the bullet is launched from, and aimed at.\n   *\n   * If you don't provide any of the arguments then it uses those set via properties such as {@link #trackedSprite},\n   * {@link #bulletAngle} and so on.\n   *\n   * When the bullet is launched it has its texture and frame updated, as required. The velocity of the bullet is\n   * calculated based on Weapon properties like `bulletSpeed`.\n   *\n   * If you wish to fire multiple bullets in a single game update, then set `Weapon.multiFire = true`\n   * and you can call `fire` as many times as you like, per loop. Multiple fires in a single update\n   * only counts once towards the `shots` total, but you will still receive a Signal for each bullet.\n   *\n   * @param {Phaser.GameObjects.Sprite|Phaser.Math.Vector2|Object|string} [from] - Optionally fires the bullet **from** the `x` and `y` properties of this object. If set this overrides {@link #trackedSprite} or `trackedPointer`. Pass `null` to ignore it.\n   * @param {number} [x] - The x coordinate, in world space, to fire the bullet **towards**. If left as `undefined`, or `null`, the bullet direction is based on its angle.\n   * @param {number} [y] - The y coordinate, in world space, to fire the bullet **towards**. If left as `undefined`, or `null`, the bullet direction is based on its angle.\n   * @param {number} [offsetX=0] - If the bullet is fired from a tracked Sprite or Pointer, or the `from` argument is set, this applies a horizontal offset from the launch position.\n   * @param {number} [offsetY=0] - If the bullet is fired from a tracked Sprite or Pointer, or the `from` argument is set, this applies a vertical offset from the launch position.\n   * @return {Bullet} The fired bullet, if a launch was successful, otherwise `null`.\n   */\n  fire(from, x, y, offsetX, offsetY) {\n    if (x === undefined) {\n      x = null;\n    }\n    if (y === undefined) {\n      y = null;\n    }\n\n    if (\n      this.scene.time.now < this._nextFire ||\n      (this.fireLimit > 0 && this.shots === this.fireLimit)\n    ) {\n      return null;\n    }\n\n    let speed = this.bulletSpeed;\n\n    //  Apply +- speed variance\n    if (this.bulletSpeedVariance !== 0) {\n      speed += Phaser.Math.Between(-this.bulletSpeedVariance, this.bulletSpeedVariance);\n    }\n\n    if (from) {\n      if (this.fireFrom.width > 1) {\n        this.fireFrom.CenterOn(from.x, from.y);\n      } else {\n        this.fireFrom.x = from.x;\n        this.fireFrom.y = from.y;\n      }\n    } else if (this.trackedSprite) {\n      if (this.trackRotation) {\n        this._rotatedPoint.set(\n          this.trackedSprite.x + this.trackOffset.x,\n          this.trackedSprite.y + this.trackOffset.y\n        );\n        Phaser.Math.RotateAround(this._rotatedPoint,\n          this.trackedSprite.x,\n          this.trackedSprite.y,\n          this.trackedSprite.rotation\n        );\n\n        if (this.fireFrom.width > 1) {\n          this.fireFrom.CenterOn(this._rotatedPoint.x, this._rotatedPoint.y);\n        } else {\n          this.fireFrom.x = this._rotatedPoint.x;\n          this.fireFrom.y = this._rotatedPoint.y;\n        }\n      } else if (this.fireFrom.width > 1) {\n        this.fireFrom.CenterOn(\n          this.trackedSprite.x + this.trackOffset.x,\n          this.trackedSprite.y + this.trackOffset.y\n        );\n      } else {\n        this.fireFrom.x = this.trackedSprite.x + this.trackOffset.x;\n        this.fireFrom.y = this.trackedSprite.y + this.trackOffset.y;\n      }\n\n      if (this.bulletInheritSpriteSpeed) {\n        speed += this.trackedSprite.body.speed;\n      }\n    } else if (this.trackedPointer) {\n      if (this.fireFrom.width > 1) {\n        this.fireFrom.CenterOn(\n          this.trackedPointer.x + this.trackOffset.x,\n          this.trackedPointer.y + this.trackOffset.y\n        );\n      } else {\n        this.fireFrom.x = this.trackedPointer.x + this.trackOffset.x;\n        this.fireFrom.y = this.trackedPointer.y + this.trackOffset.y;\n      }\n    }\n\n    if (offsetX !== undefined) {\n      this.fireFrom.x += offsetX;\n    }\n\n    if (offsetY !== undefined) {\n      this.fireFrom.y += offsetY;\n    }\n\n    const randomX = this.fireFrom.x + Math.random() * this.fireFrom.width;\n    const randomY = this.fireFrom.y + Math.random() * this.fireFrom.height;\n\n    const fromX = this.fireFrom.width > 1 ? randomX : this.fireFrom.x;\n    const fromY = this.fireFrom.height > 1 ? randomY : this.fireFrom.y;\n\n    let angle = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;\n\n    //  The position (in world space) to fire the bullet towards, if set\n    if (x !== null && y !== null) {\n      angle = Phaser.Math.RadToDeg(Math.atan2(y - fromY, x - fromX));\n    }\n\n    //  Apply +- angle variance\n    if (this.bulletAngleVariance !== 0) {\n      angle += Phaser.Math.Between(-this.bulletAngleVariance, this.bulletAngleVariance);\n    }\n\n    let moveX = 0;\n    let moveY = 0;\n\n    //  Avoid sin/cos for right-angled shots\n    if (angle === 0 || angle === 180) {\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n    } else if (angle === 90 || angle === 270) {\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    } else {\n      moveX = Math.cos(Phaser.Math.DegToRad(angle)) * speed;\n      moveY = Math.sin(Phaser.Math.DegToRad(angle)) * speed;\n    }\n\n    let bullet = null;\n\n    if (this.autoExpandBulletsGroup) {\n      bullet = this.bullets.getFirstDead(true, fromX, fromY, this.bulletKey, this.bulletFrame);\n\n      bullet.data.bulletManager = this;\n    } else {\n      bullet = this.bullets.getFirstDead(false);\n    }\n\n    console.log(`Got bullet: ${bullet ? bullet.bulletID : 'none, :('}`)\n\n    if (bullet) {\n      bullet.prepare(fromX, fromY);\n      bullet.data.fromX = fromX;\n      bullet.data.fromY = fromY;\n      bullet.data.killType = this.bulletKillType;\n      bullet.data.killDistance = this.bulletKillDistance;\n      bullet.data.rotateToVelocity = this.bulletRotateToVelocity;\n\n      if (this.bulletKillType === consts.KILL_LIFESPAN) {\n        if (this.bulletLifespan <= 0) {\n          throw new Error('Invalid bulletLifespan; must be > 0')\n        }\n        bullet.data.timeEvent = this.scene.time.addEvent({\n          delay: this.bulletLifespan,\n          callback: bullet.kill.bind(bullet),\n        })\n        bullet.lifespan = this.bulletLifespan;\n      }\n\n      bullet.angle = angle + this.bulletAngleOffset;\n\n      //  Frames and Animations\n      if (this.bulletAnimation) {\n        bullet.anims.play(this.bulletAnimation);\n      } else if (this.bulletFrameCycle) {\n        bullet.frame = this.bulletFrames[this.bulletFrameIndex];\n\n        this.bulletFrameIndex++;\n\n        if (this.bulletFrameIndex >= this.bulletFrames.length) {\n          this.bulletFrameIndex = 0;\n        }\n      } else if (this.bulletFrameRandom) {\n        bullet.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)];\n      }\n\n      if (bullet.data.bodyDirty) {\n        if (this._data.customBody) {\n          bullet.body.setSize(this._data.width, this._data.height);\n          bullet.body.setOffset(this._data.offsetX, this._data.offsetY);\n        }\n\n        bullet.body.collideWorldBounds = this.bulletCollideWorldBounds;\n\n        bullet.data.bodyDirty = false;\n      }\n\n      bullet.body.setVelocity(moveX, moveY);\n      bullet.body.setGravity(this.bulletGravity.x, this.bulletGravity.y);\n\n      let next = 0;\n\n      if (this.bulletSpeedVariance !== 0) {\n        let rate = this.fireRate;\n\n        rate += Phaser.Math.Between(-this.fireRateVariance, this.fireRateVariance);\n\n        if (rate < 0) {\n          rate = 0;\n        }\n\n        next = this.scene.time.now + rate;\n      } else {\n        next = this.scene.time.now + this.fireRate;\n      }\n\n      if (this.multiFire) {\n        if (!this._hasFired) {\n          //  We only add 1 to the 'shots' count for multiFire shots\n          this._hasFired = true;\n          this._tempNextFire = next;\n          this.shots++;\n        }\n      } else {\n        this._nextFire = next;\n\n        this.shots++;\n      }\n\n      this.eventEmitter.emit('fire', bullet, this, speed);\n\n      if (this.fireLimit > 0 && this.shots === this.fireLimit) {\n        this.eventEmitter('firelimit', this, this.fireLimit);\n      }\n    }\n\n    return bullet;\n  }\n\n  /**\n   * You can modify the size of the physics Body the Bullets use to be any dimension you need.\n   * This allows you to make it smaller, or larger, than the parent Sprite.\n   * You can also control the x and y offset of the Body. This is the position of the\n   * Body relative to the top-left of the Sprite _texture_.\n   *\n   * For example: If you have a Sprite with a texture that is 80x100 in size,\n   * and you want the physics body to be 32x32 pixels in the middle of the texture, you would do:\n   *\n   * `setSize(32 / Math.abs(this.scale.x), 32 / Math.abs(this.scale.y), 24, 34)`\n   *\n   * Where the first two parameters are the new Body size (32x32 pixels) relative to the Sprite's scale.\n   * 24 is the horizontal offset of the Body from the top-left of the Sprites texture, and 34\n   * is the vertical offset.\n   *\n   * @param {number} width - The width of the Body.\n   * @param {number} height - The height of the Body.\n   * @param {number} [offsetX] - The X offset of the Body from the top-left of the Sprites texture.\n   * @param {number} [offsetY] - The Y offset of the Body from the top-left of the Sprites texture.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  setBulletBodyOffset(width, height, offsetX, offsetY) {\n    if (offsetX === undefined) {\n      offsetX = 0;\n    }\n    if (offsetY === undefined) {\n      offsetY = 0;\n    }\n\n    this._data.customBody = true;\n    this._data.width = width;\n    this._data.height = height;\n    this._data.offsetX = offsetX;\n    this._data.offsetY = offsetY;\n\n    //  Update all bullets in the pool\n    this.bullets.children.each(child => {\n      child.body.setSize(width, height);\n      child.body.setOffset(offsetX, offsetY);\n    });\n    //this.bullets.setAll('data.bodyDirty', false);\n\n    return this;\n  }\n\n  /**\n   * Sets the texture frames that the bullets can use when being launched.\n   *\n   * This is intended for use when you've got numeric based frames, such as those loaded via a Sprite Sheet.\n   *\n   * It works by calling `Phaser.Utils.Array.NumberArray` internally, using the min and max values\n   * provided. Then it sets the frame index to be zero.\n   *\n   * You can optionally set the cycle and random booleans, to allow bullets to cycle through the frames\n   * when they're fired, or pick one at random.\n   *\n   * @param {integer} min - The minimum value the frame can be. Usually zero.\n   * @param {integer} max - The maximum value the frame can be.\n   * @param {boolean} [cycle=true] - Should the bullet frames cycle as they are fired?\n   * @param {boolean} [random=false] - Should the bullet frames be picked at random as they are fired?\n   * @return {Weapon} The Weapon Plugin.\n   */\n  setBulletFrames(min, max, cycle, random) {\n    if (cycle === undefined) {\n      cycle = true;\n    }\n    if (random === undefined) {\n      random = false;\n    }\n\n    this.bulletFrames = Phaser.Utils.Array.NumberArray(min, max);\n\n    this.bulletFrameIndex = 0;\n\n    this.bulletFrameCycle = cycle;\n    this.bulletFrameRandom = random;\n\n    return this;\n  }\n\n  /**\n   * Adds a new animation under the given key. Optionally set the frames, frame rate and loop.\n   * The arguments are all the same as for `Animation.add`, and work in the same way.\n   *\n   * {@link #bulletAnimation} will be set to this animation after it's created. From that point on, all\n   * bullets fired will play using this animation. You can swap between animations by calling this method\n   * several times, and then just changing the {@link #bulletAnimation} property to the name of the animation\n   * you wish to play for the next launched bullet.\n   *\n   * If you wish to stop using animations at all, set {@link #bulletAnimation} to '' (an empty string).\n   *\n   * @param {string} name - The unique (within the Weapon instance) name for the animation, i.e. \"fire\", \"blast\".\n   * @param {Array} [frames=null] - An array of numbers/strings that correspond to the frames to add to this animation and in which order. e.g. [1, 2, 3] or ['run0', 'run1', run2]). If null then all frames will be used.\n   * @param {number} [frameRate=60] - The speed at which the animation should play. The speed is given in frames per second.\n   * @param {number} [loop=1] - Number of times to repeat the animation. Set to -1 to repeat forever.\n   * @return {Weapon} The Weapon Plugin.\n   */\n  addBulletAnimation(name, frames, frameRate, loop) {\n    if (!this.scene.sys.anims.anims.contains(name)) {\n      this.scene.sys.anims.create({\n        key: name,\n        frames,\n        frameRate,\n        loop,\n      });\n\n      this.anims[name] = this.scene.sys.anims.anims.entries[name];\n    }\n\n    this.bulletAnimation = name;\n\n    return this;\n  }\n\n  /**\n   * Uses `Game.Debug` to draw some useful information about this Weapon, including the number of bullets\n   * both in-flight, and available. And optionally the physics debug bodies of the bullets.\n   *\n   * @param {integer} [x=16] - The coordinate, in screen space, at which to draw the Weapon debug data.\n   * @param {integer} [y=32] - The coordinate, in screen space, at which to draw the Weapon debug data.\n   * @param {boolean} [debugBodies=false] - Optionally draw the physics body of every bullet in-flight.\n   */\n  debug(x, y, debugBodies) {\n    /*if (x === undefined) {\n      x = 16;\n    }\n    if (y === undefined) {\n      y = 32;\n    }\n    if (debugBodies === undefined) {\n      debugBodies = false;\n    }\n\n    this.game.debug.text('Weapon Plugin', x, y);\n    this.game.debug.text(\n      'Bullets Alive: ' + this.bullets.total + ' - Total: ' + this.bullets.length,\n      x,\n      y + 24\n    );\n\n    if (debugBodies) {\n      this.bullets.forEachExists(this.game.debug.body, this.game.debug, 'rgba(255, 0, 255, 0.8)');\n    }*/\n  }\n\n  /**\n   * Internal update method, called by the Weapon Plugin.\n   * @returns {void}\n   */\n  update() {\n    if (this._bulletKillType === consts.KILL_WEAPON_BOUNDS) {\n      if (this.trackedSprite) {\n        this.trackedSprite.updateTransform();\n        this.bounds.centerOn(this.trackedSprite.x, this.trackedSprite.y);\n      } else if (this.trackedPointer) {\n        this.bounds.centerOn(this.trackedPointer.x, this.trackedPointer.y);\n      }\n    }\n\n    if (this.autofire) {\n      this.fire();\n    }\n  }\n\n  /**\n   * Internal update method, called by the Weapon Plugin.\n   *\n   * @protected\n   * @returns {void}\n   */\n  postRender() {\n    if (!this.multiFire || !this._hasFired) {\n      return;\n    }\n\n    this._hasFired = false;\n\n    this._nextFire = this._tempNextFire;\n  }\n\n  /**\n   * Destroys this Weapon.\n   * You must release everything in here, all references, all objects, free it all up.\n   * @returns {void}\n   */\n  destroy() {\n    this.scene = null;\n\n    this.bullets.destroy(true);\n  }\n}\n\n/**\n * The Class of the bullets that are launched by this Weapon. Defaults to {@link Phaser.Bullet}, but can be\n * overridden before calling `createBullets` and set to your own class type.\n *\n * It should be a constructor function accepting `(game, x, y, key, frame)`.\n *\n * @name Weapon#bulletClass\n * @property {function} bulletClass\n */\nObject.defineProperty(Weapon.prototype, 'bulletClass', {\n  get() {\n    return this._bulletClass;\n  },\n\n  set(classType) {\n    this._bulletClass = classType;\n\n    // `this.bullets` exists only after createBullets()\n    if (this.bullets) {\n      this.bullets.classType = this._bulletClass;\n    }\n  },\n});\n\n/**\n * This controls how the bullets will be killed. The default is `consts.KILL_WORLD_BOUNDS`.\n *\n * There are 7 different \"kill types\" available:\n *\n * * `consts.KILL_NEVER`\n * The bullets are never destroyed by the Weapon. It's up to you to destroy them via your own code.\n *\n * * `consts.KILL_LIFESPAN`\n * The bullets are automatically killed when their `bulletLifespan` amount expires.\n *\n * * `consts.KILL_DISTANCE`\n * The bullets are automatically killed when they exceed `bulletDistance` pixels away from their original launch position.\n *\n * * `consts.KILL_WEAPON_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n *\n * * `consts.KILL_CAMERA_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.Camera#bounds} rectangle.\n *\n * * `consts.KILL_WORLD_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link Phaser.World#bounds} rectangle.\n *\n * * `consts.KILL_STATIC_BOUNDS`\n * The bullets are automatically killed when they no longer intersect with the {@link #bounds} rectangle.\n * The difference between static bounds and weapon bounds, is that a static bounds will never be adjusted to\n * match the position of a tracked sprite or pointer.\n *\n * @name Weapon#bulletKillType\n * @property {integer} bulletKillType\n */\nObject.defineProperty(Weapon.prototype, 'bulletKillType', {\n  get() {\n    return this._bulletKillType;\n  },\n\n  set(type) {\n    console.log(`setting bulletKillType: ${type}`)\n    switch (type) {\n      case consts.KILL_STATIC_BOUNDS:\n      case consts.KILL_WEAPON_BOUNDS:\n        this.bulletBounds = this.bounds;\n        break;\n\n      case consts.KILL_CAMERA_BOUNDS:\n        this.bulletBounds = this.scene.sys.cameras.main._bounds;\n        break;\n\n      case consts.KILL_WORLD_BOUNDS:\n        this.bulletBounds = this.scene.physics.world.bounds;\n        break;\n    }\n\n    this._bulletKillType = type;\n  },\n});\n\n/**\n * Should bullets collide with the World bounds or not?\n *\n * @name Weapon#bulletCollideWorldBounds\n * @property {boolean} bulletCollideWorldBounds\n */\nObject.defineProperty(Weapon.prototype, 'bulletCollideWorldBounds', {\n  get() {\n    return this._bulletCollideWorldBounds;\n  },\n\n  set(value) {\n    this._bulletCollideWorldBounds = value;\n\n    this.bullets.children.each(child => {\n      child.body.collideWorldBounds = value;\n      child.data.bodyDirty = false;\n    });\n  },\n});\n\n/**\n * The x coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.x`, and\n * can be overridden by the {@link #fire} arguments.\n *\n * @name Weapon#x\n * @property {number} x\n */\nObject.defineProperty(Weapon.prototype, 'x', {\n  get() {\n    return this.fireFrom.x;\n  },\n\n  set(value) {\n    this.fireFrom.x = value;\n  },\n});\n\n/**\n * The y coordinate from which bullets are fired. This is the same as `Weapon.fireFrom.y`, and\n * can be overridden by the {@link #fire} arguments.\n *\n * @name Weapon#y\n * @property {number} y\n */\nObject.defineProperty(Weapon.prototype, 'y', {\n  get() {\n    return this.fireFrom.y;\n  },\n\n  set(value) {\n    this.fireFrom.y = value;\n  },\n});\n\nmodule.exports = Weapon;\n\n\n\n// WEBPACK FOOTER //\n// ./Weapon.js"],"sourceRoot":""}